<?php
/**
 * @file
 * Page theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */

/**
 * Returns HTML for the default title of a taxon page.
 *  * The returned title is a formatted taxon name.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon: The taxon name being formatted for the title.
 *   - uuid: UUID for the taxon.
 *
 * @ingroup themeable
 */
function theme_cdm_taxon_page_title($variables) {
  $taxon = $variables['taxon'];
  $uuid = $variables['uuid'];
  RenderHints::pushToRenderStack('taxon_page_title');
  $referenceUri = '';
  $out = '';
  if (isset($taxon->name->nomenclaturalReference)) {
    $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
  }

  $out .= theme('cdm_taxonName', array(
    'taxonName' => $taxon->name,
    'nameLink' => NULL,
    'refenceLink' => $referenceUri,
    'show_annotations' => FALSE,
  ));
  RenderHints::popFromRenderStack();

  return '<span class="' . $taxon->class . '">' . $out . '</span>';
}

/**
 * Returns HTML for the default title for a name page.
 *
 * The returned title is a formatted name.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon_name: The taxon name object.
 *
 * @ingroup themeable
 */
function theme_cdm_name_page_title($variables) {
  $taxon_name = $variables['taxon_name'];
  RenderHints::pushToRenderStack('taxon_page_title');
  if (isset($taxon_name->nomenclaturalReference)) {
    $referenceUri = url(path_to_reference($taxon_name->nomenclaturalReference->uuid));
  }

  $out = '<span class="' . $taxon_name->class . '">' . theme('cdm_taxonName', array(
    'taxonName' => $taxon_name,
    'nameLink' => NULL,
    'refenceLink' => $referenceUri,
    'show_annotations' => FALSE,
  )) . '</span>';
  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * Returns HTML for a taxon page.
 *
 * A wrapper function that groups available information to show by default,
 * when a taxon page is requested by the browser.
 * Individual themeing has to decide what this page should include (see methods
 * beneath) and what information should go into tabs or should not be shown
 * at all.
 *
 * It is headed by the name of the accepted taxon without author and reference.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon: The taxon object for which to theme the page.
 *   - page_part: Name of the part to display, valid values are:
 *   'description', 'images', 'synonymy', 'all'.
 *
 * @ingroup themeable
 */
function theme_cdm_taxon_page($variables) {

  $taxon = $variables['taxon'];
  $page_part = $variables['page_part'];
  global $theme;

  $render_array = array();
  $weight = 0; // the weight for the render array elements

  $tabsToDisplay = variable_get('cdm_taxonpage_tabs_visibility', unserialize(TAXONPAGE_VISIBILITY_OPTIONS_DEFAULT));

  $page_part = variable_get('cdm_dataportal_taxonpage_tabs', 1) ? $page_part : 'all';

  $media = _load_media_for_taxon($taxon);


  if (!isset($media[0]) || ($tabsToDisplay["Images"] == '0')) {
    taxon_page_tabs_hidden('images');
  }

  // HideImage flag depending on administative preset.
  $hideImages = FALSE;
  if (variable_get('image_hide_rank', '0') != '0' && isset($taxon->name->rank->uuid)) {
    $rankCompare = rank_compare($taxon->name->rank->uuid, variable_get('image_hide_rank', '-99'));
    $hideImages = ($rankCompare > -1);
  }

  // --- GET specimensOrObservations --- //
  $specimensOrObservations = cdm_ws_get(CDM_WS_TAXON, array( $taxon->uuid, 'specimensOrObservations'));

  $specimensOrObservationsCount = is_array($specimensOrObservations) ? count($specimensOrObservations) : 0;
  if ($specimensOrObservationsCount == 0 || ($tabsToDisplay["Specimens"] == '0')) {
    taxon_page_tabs_hidden('specimens');
  }

  // --- GET polytomousKeys --- //
  $polytomousKeysPager = cdm_ws_get(CDM_WS_POLYTOMOUSKEY, NULL, "findByTaxonomicScope=$taxon->uuid");
  $identificationKeyCount = 0;
  if ($polytomousKeysPager) {
    $identificationKeyCount += $polytomousKeysPager->count;
  }
  if ($identificationKeyCount == 0 || ($tabsToDisplay["Keys"] == '0')) {
    taxon_page_tabs_hidden('keys');
  }

  if ($tabsToDisplay["Synonymy"] == '0') {
    taxon_page_tabs_hidden('synonymy');
  }

  // -------------------------------------------- //

  $render_array['back_to_search'] = markup_to_render_array(theme('cdm_back_to_search_result_button'), $weight++);

  if (variable_get('cdm_dataportal_display_is_accepted_for', CDM_DATAPORTAL_DISPLAY_IS_ACCEPTED_FOR)) {
    $render_array['accepted_for'] = theme('cdm_acceptedFor', 'page_general');
  }

  // --- PAGE PART: DESCRIPTION --- //
  if ($page_part == 'description' || $page_part == 'all') {

    $markerTypesEmpty = array();
    $markerTypesEmpty['markerTypes'] = '';
    $queryString = $markerTypesEmpty['markerTypes'] ? queryString($markerTypesEmpty) : '';
    // Retrieve all descriptions for the taxon.
    $taxonDescriptions = cdm_ws_get(CDM_WS_PORTAL_TAXON_DESCRIPTIONS, $taxon->uuid, $queryString);

    $nonStructuredDescriptions = array();
    if ($taxonDescriptions != NULL) {
      foreach ($taxonDescriptions as $taxonDescription) {
        // Check if structured description.
        $hasStructuredData = cdm_ws_get(CDM_WS_DESCRIPTION_HAS_STRUCTRURED_DATA, $taxonDescription->uuid);
        if (isset($hasStructuredData->Boolean)) {
          $hasStructuredData = $hasStructuredData->Boolean == 'TRUE';
        }
        if ($hasStructuredData) {
          $structured_description_featuretree_uuid = variable_get(CDM_DATAPORTAL_STRUCTURED_DESCRIPTION_FEATURETREE_UUID, FALSE);
          if($structured_description_featuretree_uuid) {
            // if a feature tree for natural language generation has been defined use it,
            // otherwise natural language generation is skipped
            $naturallanguage_textData = cdm_ws_get(CDM_WS_DESCRIPTION_NATURALLANGUAGE_DESCRIPTION, array(
              $taxonDescription->uuid,
              $structured_description_featuretree_uuid,
            ));

            if (!isset($naturallanguage_textData)) {
              drupal_set_message(
                t(
                "The 'FeatureTree' for the generation of natural language representations is not configured correctly,"
                ." please select a 'FeatureTree' in the !settings",
                array(
                  '!settings' => l(t('CDM Dataportal Settings'), 'admin/config/cdm_dataportal/layout/taxon'))
                  ),
                'warning');
            } else {
              $taxonDescription->elements = NULL;
              $taxonDescription->elements = array(
                $naturallanguage_textData,
              );
            }
          }
        }
        $nonStructuredDescriptions[] = $taxonDescription;
      }
      // Release memory.
      $taxonDescriptions = NULL;
    }

    $mergedTrees = cdm_ws_descriptions_by_featuretree(get_profile_featureTree(), $nonStructuredDescriptions, variable_get('cdm_dataportal_descriptions_separated', FALSE));

    $profile_html = '<div id="general">';
    $profile_html .= theme('cdm_taxon_page_profile', array(
      'taxon' => $taxon,
      'mergedTrees' => $mergedTrees,
      'media' => $media,
      'hideImages' => $hideImages,
      ));
    $profile_html .= '</div>';
    $render_array['profile'] = markup_to_render_array($profile_html, $weight++);
  }

  // --- PAGE PART: IMAGES --- //
  if ((!$hideImages && $page_part == 'images' || $page_part == 'all')) {
    $images_html = '<div id="images">';
    if ($page_part == 'all') {
      $images_html .= '<h2>' . t('Images') . '</h2>';
    }
    // Get the image gallery as configured by the admin.
    $taxon_image_gallery = call_user_func_array('taxon_image_gallery_' . variable_get('image_gallery_viewer', 'default'), array(
      $taxon,
      $media,
    ));
    $images_html .= $taxon_image_gallery;
    $images_html .= '</div>';
    $render_array['images'] = markup_to_render_array($images_html, $weight++);
  }

  // --- PAGE PART: SYNONYMY --- //
  if (($page_part == 'synonymy' || $page_part == 'all')) {
    $synonymy_html = '<div id="synonymy">';
    if ($page_part == 'all') {
      $synonymy_html .= '<h2>' . t('Synonymy') . '</h2>';
    }
    $addAcceptedTaxon = variable_get('cdm_dataportal_nomref_in_title', CDM_DATAPORTAL_NOMREF_IN_TITLE);
    $synonymy_html .= theme('cdm_taxon_page_synonymy', array('taxon' => $taxon, 'addAcceptedTaxon' => $addAcceptedTaxon));

    $synonymy_html .= '</div>';
    $render_array['synonymy'] = markup_to_render_array($synonymy_html, $weight++);
  }

  // --- PAGE PART: SPECIMENS --- //
  if ($specimensOrObservationsCount > 0 && ($page_part == 'specimens' || $page_part == 'all')) {
    $render_array['specimens'] = array(
        '#prefix' => '<div id="specimens">' . ($page_part == 'all' ? '<h2>' . t('Specimens') . '</h2>' : ''),
        'content' => cdm_dataportal_taxon_page_specimens($taxon), // returns render array
        '#suffix' => '</div>',
    );
  }

  // --- PAGE PART: KEYS --- //
  if ($identificationKeyCount > 0 && ($page_part == 'keys' || $page_part == 'all')) {
    $keys_html = '<div id="keys">';
    if ($page_part == 'all') {
      $keys_html .= '<h2>' . t('Keys') . '</h2>';
    }
    $keys_html .= theme('cdm_block_IdentificationKeys', array('taxonUuid' => $taxon->uuid));
    $keys_html .= '</div>';
    $render_array['keys'] = markup_to_render_array($keys_html, $weight++);
  }

  return $render_array;
}

/**
 * Returns HTML containing descriptive data and preferred picture.
 *
 * Outputs all descriptive data and shows the preferred picture of the
 * accepted taxon.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon
 *   - mergedTrees
 *   - media:
 *   - hideImages
 *
 * @ingroup themeable
 */
function theme_cdm_taxon_page_profile($variables) {
  $taxon = $variables['taxon'];
  $mergedTrees = $variables['mergedTrees'];
  $media = $variables['media'];
  $hideImages = $variables['hideImages'];
  $out = '';
  if (variable_get('cdm_dataportal_show_default_image', FALSE) && !$hideImages) {

    // Preferred image hardcoded for testing.
    $defaultRepresentationPart = new stdClass();
    $defaultRepresentationPart->width = 184;
    $defaultRepresentationPart->height = 144;
    $defaultRepresentationPart->uri = base_path() .  drupal_get_path('module', 'cdm_dataportal') . '/images/no_picture.png';

    // Preferred image size 184px Ã— 144.
    $imageMaxExtend = 184;
    $out .= '<div id="taxonProfileImage">' . theme('cdm_preferredImage', array(
      'media' => $media,
      'defaultRepresentationPart' => $defaultRepresentationPart,
      'imageMaxExtend' => $imageMaxExtend,
      )) . '</div>';
  }

  // Description TOC.
  $out .= theme('cdm_featureTreeTOCs', array('mergedTrees' => $mergedTrees));

  // Description.
  $out .= theme('cdm_featureTrees', array('mergedTrees' => $mergedTrees, 'taxon' => $taxon));

  return $out;
}



/**
 * Returns HTML containing the synonymy for the accepted taxon.
 *
 * Shows the whole synonymy for the accepted taxon.
 * The synonymy list is headed by the complete scientific name
 * of the accepted taxon with nomenclatural reference.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon
 *   - addAcceptedTaxon
 *
 * @ingroup themeable
 */
function theme_cdm_taxon_page_synonymy($variables) {
  $taxon = $variables['taxon'];
  $addAcceptedTaxon = $variables['addAcceptedTaxon'];

  RenderHints::pushToRenderStack('taxon_page_synonymy');

  // footnote key for the homotypic group and accepted taxon,
  // both should have the same footnote key
  RenderHints::setFootnoteListKey(RenderHints::getRenderPath());

  $synomymie = cdm_ws_get(CDM_WS_PORTAL_TAXON_SYNONYMY, $taxon->uuid);
  $skip = array(
    UUID_BASIONYM,
  );
  $out = '';

  // Render accepted taxon.
  //
  // foonotes of the accepted taxon will be rendered in the homotypic group section
  // even if there are not synonyms in the homotypic group
  // homotypic group and accepted taxon should have the same footnote key
  $referenceUri = '';
  if ($addAcceptedTaxon) {
    if (isset($taxon->name->nomenclaturalReference)) {
      $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
    }

    $accepted_name = '<span class="accepted-name">';
    $accepted_name .= theme('cdm_taxonName', array(
      'taxonName' => $taxon->name,
      'nameLink' => NULL,
      'refenceLink' => $referenceUri,
      ));
    $accepted_name .= '</span>';

    // handle annotations of the name and taxon
    $special_annotations_array = array();
    $special_annotations_array[] = $taxon->name;
    $special_annotations_array[] = $taxon;
    $accepted_name .= theme('cdm_annotations_as_footnotekeys', array(
        'cdmBase_list' => $special_annotations_array,
        'footnote_list_key' => RenderHints::getRenderPath() . '-annotations')
      );
  }

  // --- Render homotypic synonymy group
  if (!empty($accepted_name)) {
    $out .= $accepted_name;
  }

  // Render the homotypicSynonymyGroup including the type information.
  $out .= theme('cdm_homotypicSynonymyGroup', array('synonymList' => $synomymie->homotypicSynonymsByHomotypicGroup, 'accepted_taxon_uuid' => $taxon->uuid));


  // Render accepted taxon heterotypic synonymy groups.
  if ($synomymie->heterotypicSynonymyGroups) {
    foreach ($synomymie->heterotypicSynonymyGroups as $homotypicalGroup) {
      $out .= theme('cdm_heterotypicSynonymyGroup', array('homotypicalGroup' => $homotypicalGroup));
    }
  }
  // Render taxon relationships.
  if (variable_get(CDM_DATAPORTAL_DISPLAY_TAXON_RELATIONSHIPS, CDM_DATAPORTAL_DISPLAY_TAXON_RELATIONSHIPS_DEFAULT)) {
    $taxonRelationships = cdm_ws_get(CDM_WS_PORTAL_TAXON_RELATIONS, $taxon->uuid);
    $out .= theme('cdm_taxonRelationships', array('taxonRelationships' => $taxonRelationships, 'focusedTaxon' => $taxon));
  }
  // Render name relationships.
  $name_rels_to_show = variable_get('name_relationships_to_show', NULL);
  $skip = array();
  if ($name_rels_to_show) {
    foreach ($name_rels_to_show as $key => $value) {
      if ($value === 0) {
        $skip[] = $key;
      }
    }
    if (sizeof($name_rels_to_show) != sizeof($skip)) {
      $nameRelationships = cdm_ws_get(CDM_WS_PORTAL_TAXON_TO_NAMERELATIONS, $taxon->uuid);
      $out .= theme('cdm_nameRelationships', array('nameRelationships' => $nameRelationships, 'skipTypes' => $skip));
    }
  }

  RenderHints::popFromRenderStack();

  return $out;
}


/**
 * Returns HTML for the given result page including a pager.
 *
 * @param array $variables
 *   An associative array containing:
 *   - pager: The cdmlib pager object containing the result set of cdm base
 *     objects (currently this function can only handle taxon instances =>
 *     TODO)
 *   - path: The target path for the pager links, this will usually point to
 *     'cdm_dataportal/search/results/taxon'
 *
 * @ingroup themeable
 */
function theme_cdm_search_results($variables) {
  $pager = $variables['pager'];
  $path = $variables['path'];

  $freetextSearchResults = array();

  // The $query_parameters must not contain the 'q' parameter
  // since this would conflict with the desired target $path.
  // unset($search_params['q']);
  // If the pager contains records of SearchResults, extract the taxa and use
  // them as records instead.
  if (isset($pager->records[0]) && $pager->records[0]->class == "SearchResult") {
    $freetextSearchResults = $pager->records;
    $taxa = array();
    // $highlightedFragments = array();
    foreach ($pager->records as $searchResult) {
      $taxa[] = &$searchResult->entity;
      /*
       if(!isset($searchResult->fieldHighlightMap)){
      $searchResult->fieldHighlightMap = NULL;
      }
      $fragmentHighlighting[] = $searchResult->fieldHighlightMap;
      */
    }
    $pager->records = $taxa;
  }

  $out = '';
  // Add thumbnails checkbox and refine search link.
  $out = '<div class="page_options">';
  if (isset($_REQUEST['ws'])) {
    if (cdm_dataportal_search_form_path_for_ws($_REQUEST['ws'])) {
      $out .= '<div id="backButton">' . l(t('Modify search'), cdm_dataportal_search_form_path_for_ws($_REQUEST['ws'])) . '</div>';
    }
  }
  $out .= '<form name="pageoptions"><input id="showThumbnails" type="checkbox" name="showThumbnails" ' . (do_showThumbnails() == 1 ? 'checked="checked"' : '') . '> ' . t('Show Thumbnails') . '</form>';
  $out .= '</div>';
  $out .= '<div id="search-summary">' . t('results for') . ' ';
  $classification = cdm_dataportal_searched_in_classification();
  if ($classification != NULL) {
    $out .=  $classification->titleCache ;
  } else {
   $out .= t('any classification');
  }
  $out .= ':</div>';

  // List results.
  if (isset($pager->records) && count($pager->records) > 0) {
    $out .= '<div id="search_results">';
    $out .= theme('cdm_list_of_taxa',
        array(
          'records' => $pager->records,
          'freetextSearchResults' => $freetextSearchResults,
          'show_classification' => $classification === NULL
        )
      );
    $out .= '</div>';
    $out .= theme('cdm_pager', array(
        'pager' => $pager,
        'path' => $path,
        'parameters' => $_REQUEST,
    ));
  }
  else {
    $out .= '<h4 class="error">Sorry, no matching entries found.</h4>';
  }
  return $out;
}


/**
 * TODO Implementation of Hook taxon_image_gallery()
 *
 * @param unknown_type $taxon
 * @param unknown_type $media
 *
 * @return unknown_type
 */
function taxon_image_gallery_default($taxon, $media) {
  $hasImages = isset($media[0]);

  if ($hasImages) {

    $maxExtend = 150;
    $cols = 3;
    $maxRows = FALSE;
    $alternativeMediaUri = NULL;
    /* Comment @WA: was in D5:
    $captionElements = array(
      'title',
      'rights',
      '#uri' => t('open Image'),
    );
    */
    $captionElements = array(
      'title',
      'description',
      'artist',
      'location',
      'rights',
      '#uri' => t('open Image'),
    );
    $gallery_name = $taxon->uuid;
    $mediaLinkType = 'LIGHTBOX';

    // $gallery_settings = getGallerySettings(CDM_DATAPORTAL_MEDIA_GALLERY_NAME);

    $gallery_settings = getGallerySettings(CDM_DATAPORTAL_TAXON_MEDIA_GALLERY_NAME_TAB);

    $out = '<div class="image-gallerie">';
    $out .= theme('cdm_media_gallerie', array(
      'mediaList' => $media,
      'galleryName' => $gallery_name,
      'maxExtend' => $gallery_settings['cdm_dataportal_media_maxextend'],
      'cols' => $gallery_settings['cdm_dataportal_media_cols'],
      'maxRows' => 0, // Ignore maxrows settings.
      'captionElements' => $captionElements,
      'mediaLinkType' => $mediaLinkType,
      'alternativeMediaUri' => NULL,
      'galleryLinkUri' => NULL,
      'showCaption' => $gallery_settings['cdm_dataportal_show_thumbnail_captions'],
    ));
    $out .= '</div>';
  }
  else {
    $out = 'No images available.';
  }
  return $out;
}

/**
 * TODO Implementation of Hook taxon_image_gallery()
 *
 * @param unknown_type $taxon
 * @param unknown_type $media
 *
 * @return unknown_type
 */
function taxon_image_gallery_fsi($taxon, $media) {
  $flashLink = isset($media[0]);

  if ($flashLink) {

    if (module_exists("fsi_gallery")) {
      $out = theme("fsi_gallery", array('taxon' => $taxon, 'media' => $media));
    }
    else {
      $message = t('In order to use the FSI gallery you must enable the according ') . l(t("module"), "admin/modules");
      drupal_set_message($message, "error");
      $out = '<h3>' . $message . '</h3>';
    }
  }
  else {
    $out = 'No images available.';
  }
  return $out;
}

/**
 * Returns HTML for a single reference page.
 *
 * Renders a page with all data on a single reference.
 *
 * @param array $variables
 *   An associative array containing:
 *   - reference: Object.
 *
 * @ingroup themeable
 */
function theme_cdm_reference_page($variables) {
  $reference = $variables['reference'];

  $out = '';

  if (isset($reference->titleCache)) {
    drupal_set_title($reference->titleCache, PASS_THROUGH);
  }

  $field_order = array(
    "title",
    // "titleCache",
    // "citation",
    "authorTeam",
    "editor",
    "publisher",
    "placePublished",
    "datePublished",
    "year",
    "edition",// Class Book.
    "volume",// Class Article.
    "seriesPart",
    "inReference",
    "nomRefBase", // Class BookSection, Book, Article.
    "pages",// Class Article.
    "series",// Class Article, PrintSeries.
    "school",// Class Thesis.
    "institution",// Class Report.
    "organization",// Class Proceedings.
    "nextVersion",
    "previousVersion",
    "isbn",// Class Book.
    "issn",// Class Journal.
    "uri",
  );

  $header = array(
    t('Field'),
    t('Value'),
  );
  $table_rows = array();

  if (!isset($reference->authorTeam)) {
    $authorTeam = cdm_ws_get(CDM_WS_REFERENCE_AUTHORTEAM, $reference->uuid);
    $reference->authorTeam = isset($authorTeam->titleCache) ? $authorTeam->titleCache : '';
  }

  if (!isset($reference->inReference)) {
    $reference->inReference = cdm_ws_get(CDM_WS_REFERENCE, array(
      $reference->uuid,
      "inReference",
    ));
  }

  foreach ($field_order as $fieldname) {

    if (isset($reference->$fieldname)) {

      if ($fieldname == "datePublished") {
        $period = $reference->$fieldname;
        $datePublished = timePeriodToString($period);
        if (isset($datePublished) && $datePublished != '') {
          $table_rows[] = array(
            t(ucfirst(strtolower($fieldname))),
            $datePublished,
          );
        }
        // $datePublished = array(t(ucfirst(strtolower($fieldname))),
        // $datePublished);
      }
      elseif (is_object($reference->$fieldname)) {
        if ($fieldname == "authorTeam") {
          $dump = $reference->$fieldname;
          $teammembers = "teamMembers";
          $team = $dump->$teammembers;
          $nameArray = array();

          foreach ($team as $member) {
            if (strlen($member->lastname) > 0) {
              $nname = $member->lastname;
              $name = $nname;
              if (strlen($member->firstname) > 0) {
                $vname = $member->firstname;
                $name = $vname . " " . $nname;
              }
              $nameArray[] = $name;
            }
            else {
              if (strlen($member->titleCache) > 0) {
                $nameArray[] = $member->titleCache;
              }
            }
          }
          $value = join($nameArray, ", ");
        }
        elseif ($fieldname == "inReference") {
          $type = $reference->$fieldname->type;
          $value = l($reference->$fieldname->titleCache, path_to_reference($reference->$fieldname->uuid));
          switch ($type) {
            case "Book":
              $fieldname = "in book";
              break;
            case "Journal":
              $fieldname = "in journal";
              break;
            case "Proceedings":
              $fieldname = "in proceedings";
              break;
          }
        }
        else {
          $value = $reference->$fieldname->titleCache;
        }
        if (isset($value) && $value != '') {
          $table_rows[] = array(
            t(ucfirst(strtolower($fieldname))),
            $value,
          );
        }
      }
      else {
        if (isset($reference->$fieldname) && $reference->$fieldname != '') {
          $table_rows[] = array(
            t(ucfirst(strtolower($fieldname))),
            $reference->$fieldname,
          );
        }
      }
    }
  }

  $out = theme_table(array(
      'header' => array(),
      'rows' => $table_rows,
      'attributes' => array(),
      'caption' => NULL,
      'colgroups' => NULL,
      'sticky' => NULL,
     'empty' => NULL,
  ));

  // Annotations below the table.
  $annotations = cdm_ws_getAnnotationsFor($reference);
  $out .= theme("cdm_annotations", array('annotations' => $annotations));

  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_media_page($variables) {
  $media = $variables['media'];
  $mediarepresentation_uuid = $variables['mediarepresentation_uuid'];
  $partId = $variables['partId'];
  $out = '';
  // Determine which reprresentation and which part to show.
  $representationIdx = 0;
  if ($mediarepresentation_uuid) {
    $i = 0;
    foreach ($media->representations as $representation) {
      if ($representation->uuid == $mediarepresentation_uuid) {
        $representationIdx = $i;
      }
      $i++;
    }
  }
  else {
    $mediarepresentation_uuid = $media->representations[0]->uuid;
  }

  $partIdx = 0;
  if (!is_numeric($partId)) {
    // Assuming it is an uuid.
    $i = 0;
    foreach ($media->representations[$representationIdx]->parts as $part) {
      if ($part->uuid == $partId) {
        $partIdx = $i;
      }
      $i++;
    }
  }
  else {
    // Assuming it is an index.
    $partIdx = $partId;
  }

  $media_metadata = cdm_read_media_metadata($media);
  // $title = $media->titleCache;
  $title = $media_metadata['title'];

  $imageMaxExtend = variable_get('image-page-maxextend', 400);

  if (!$title) {
    $title = 'Media ' . $media->uuid . '';
  }

  drupal_set_title($title, PASS_THROUGH);

  $out .= '<div class="media cdm_media_viewer_image">';

  $out .= theme('cdm_back_to_image_gallery_button', array());
  $out .= '<div class="viewer">';
  $out .= theme('cdm_openlayers_image', array('mediaRepresentationPart' => $media->representations[$representationIdx]->parts[$partIdx], 'maxExtend' => $imageMaxExtend));
  $out .= '</div>';

  // General media metadata.
  /*
  $media_metadata = cdm_ws_get(CDM_WS_MEDIA_METADATA, array($media->uuid));
  vardump("PRINTING MEDIA METADATA");
  vardump($media_metadata);
  vardump("PRINTING MEDIA");
  vardump($media);
  */
  $metadataToPrint = theme('cdm_media_caption', array('media' => $media));
  $out .= $metadataToPrint;

  // Tabs for the different representations.
  // ul.secondary
  $out .= '<ul class="primary">';
  foreach ($media->representations as $representation) {
    $out .= '<li>' . l($media->representations[$representationIdx]->mimeType, path_to_media($media->uuid, $mediarepresentation_uuid, $partIdx)) . '</li>';
  }
  $out .= '</ul>';

  // Representation(-part) specific metadata.
  $thumbnailMaxExtend = 100;
  $out .= '<table>';
  $i = 0;
  foreach ($media->representations[$representationIdx]->parts as $part) {
    $out .= '<tr><th>' . t('Part') . ' ' . ($i + 1) . '</th><td>';
    switch ($part->class) {
      case 'ImageFile':
        $out .= $part->width . ' x ' . $part->height . ' - ' . $part->size . 'k';
        break;
      case 'AudioFile':
      case 'MovieFile':
        $out .= t('Duration') . ': ' . $part->duration . 's - ' . $part->size . 'k';
        break;
      default:
        $out .= $part->size . 'k';
    }

    $out .= '</td><td><a href="' . url(path_to_media($media->uuid, $mediarepresentation_uuid, $i)) . '">' . theme('cdm_media_gallerie_image', array('mediaRepresentationPart' => $part, 'maxExtend' => $thumbnailMaxExtend, 'addPassePartout' => TRUE));
    $i++;
  }
  $out .= '</table>';
  $out .= '</div>';

  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_polytomousKey_page($variables) {
  $polytomousKey = $variables['polytomousKey'];
  drupal_set_title($polytomousKey->titleCache, PASS_THROUGH);

  $out = theme("cdm_IdentificationKey", array(
    'identificationKey' => $polytomousKey,
    'doLinkToKeyPage' => FALSE,
    'showIdentificationKeyTitle' => FALSE,
    ));

  // Key nodes in linked style.
  $out .= theme('cdm_polytomousKey', array('polytomousKey' => $polytomousKey));
  /*
  FIXME implement node type for keys !!! (wrapping the content in the
  cdm_dataportal.node becomes obsolete then).
  */
  return '<div id="cdm_dataportal.node">' . $out . '</div>';
}

/**
 * Returns HTML for taxon page tabs.
 *
 * Allows theming of the taxon page tabs.
 *
 * @param array $variables
 *   An associative array containing:
 *   - tabname
 *
 * @ingroup themeable
 */
function theme_cdm_taxonpage_tab($variables) {
  $tabname = $variables['tabname'];
  // TODO replace by using translations or theme the menue tabs itself instead?
  switch ($tabname) {
    default:
      return t($tabname);
  }
}
