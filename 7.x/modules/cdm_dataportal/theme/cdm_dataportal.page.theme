<?php
/**
 * @file
 * Page theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */

/**
 * Returns HTML for the default title of a taxon page.
 *  * The returned title is a formatted taxon name.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon: The taxon name being formatted for the title.
 *   - uuid: UUID for the taxon.
 *
 * @ingroup themeable
 */
function theme_cdm_taxon_page_title($variables) {
  $taxon = $variables['taxon'];
  RenderHints::pushToRenderStack('taxon_page_title');
  $referenceUri = '';
  $out = '';
  if (isset($taxon->name->nomenclaturalReference)) {
    $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
  }

  $out .= theme('cdm_taxonName', array(
    'taxonName' => $taxon->name,
    'nameLink' => NULL,
    'refenceLink' => $referenceUri,
    'show_annotations' => FALSE,
  ));
  RenderHints::popFromRenderStack();

  return '<span class="' . $taxon->class . '">' . $out . '</span>';
}

/**
 * Returns HTML for the default title for a name page.
 *
 * The returned title is a formatted name.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon_name: The taxon name object.
 *
 * @ingroup themeable
 */
function theme_cdm_name_page_title($variables) {
  $taxon_name = $variables['taxon_name'];
  RenderHints::pushToRenderStack('taxon_page_title');
  if (isset($taxon_name->nomenclaturalReference)) {
    $referenceUri = url(path_to_reference($taxon_name->nomenclaturalReference->uuid));
  }

  $out = '<span class="' . $taxon_name->class . '">' . theme('cdm_taxonName', array(
    'taxonName' => $taxon_name,
    'nameLink' => NULL,
    'refenceLink' => $referenceUri,
    'show_annotations' => FALSE,
  )) . '</span>';
  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * Returns HTML for a taxon page.
 *
 * A wrapper function that groups available information to show by default,
 * when a taxon page is requested by the browser.
 * Individual themeing has to decide what this page should include (see methods
 * beneath) and what information should go into tabs or should not be shown
 * at all.
 *
 * It is headed by the name of the accepted taxon without author and reference.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon: The taxon object for which to theme the page.
 *   - page_part: Name of the part to display, valid values are:
 *   'description', 'images', 'synonymy', 'all'.
 *
 * @ingroup themeable
 */
function theme_cdm_taxon_page($variables) {
  $taxon = $variables['taxon'];
  $page_part = $variables['page_part'];
  global $theme;

  // we better cache here since drupal_get_query_parameters has no internal static cache variable
  $http_request_params = drupal_get_query_parameters();

  // add all mandatory js sources
  _add_js_footnotes();


  $render_array = array();
  $weight = 0; // the weight for the render array elements

  $tabsToDisplay = variable_get('cdm_taxonpage_tabs_visibility', unserialize(TAXONPAGE_VISIBILITY_OPTIONS_DEFAULT));

  $page_part = variable_get('cdm_dataportal_taxonpage_tabs', 1) ? $page_part : 'all';

  $media = _load_media_for_taxon($taxon);


  if (!isset($media[0]) || ($tabsToDisplay["Images"] == '0')) {
    taxon_page_tabs_hidden('images');
  }

  // --- GET specimensOrObservations --- //
  $specimensOrObservations = cdm_ws_get(CDM_WS_TAXON, array( $taxon->uuid, 'specimensOrObservations'));

  $specimensOrObservationsCount = is_array($specimensOrObservations) ? count($specimensOrObservations) : 0;
  if ($specimensOrObservationsCount == 0 || ($tabsToDisplay["Specimens"] == '0')) {
    taxon_page_tabs_hidden('specimens');
  }

  // --- GET polytomousKeys --- //
  $polytomousKeysPager = cdm_ws_get(CDM_WS_POLYTOMOUSKEY, NULL, "findByTaxonomicScope=$taxon->uuid");
  $identificationKeyCount = 0;
  if ($polytomousKeysPager) {
    $identificationKeyCount += $polytomousKeysPager->count;
  }
  if ($identificationKeyCount == 0 || ($tabsToDisplay["Keys"] == '0')) {
    taxon_page_tabs_hidden('keys');
  }

  if ($tabsToDisplay["Synonymy"] == '0') {
    taxon_page_tabs_hidden('synonymy');
  }

  // -------------------------------------------- //

  $render_array['back_to_search'] = markup_to_render_array(theme('cdm_back_to_search_result_button'), -103);

  if (variable_get('cdm_dataportal_display_is_accepted_for', CDM_DATAPORTAL_DISPLAY_IS_ACCEPTED_FOR) && isset($_REQUEST['acceptedFor'])) {
      $render_array['accepted_for'] = markup_to_render_array(theme('cdm_acceptedFor', array('acceptedFor' => $_REQUEST['acceptedFor'])), $weight++);
  }

  // --- PAGE PART: DESCRIPTION --- //
  if ($page_part == 'description' || $page_part == 'all') {

    $merged_tree = cdm_ws_descriptions_by_featuretree(get_profile_featureTree(), $taxon->uuid);

    $render_array['profile'] = compose_cdm_taxon_page_profile($taxon, $merged_tree, $media);
    $render_array['profile']['#weight'] = $weight++;
    $render_array['profile']['#prefix'] = '<div id="general">';
    $render_array['profile']['#suffix'] = '</div>';
    $toc_elements['profile'] = l(t('General'), $_GET['q'], array('fragment' => 'general', 'query' => $http_request_params));
  }

  // --- PAGE PART: IMAGES --- //
  if (array_search('images', taxon_page_tabs_hidden()) === FALSE && ($page_part == 'images' || $page_part == 'all')) {
    $images_html = '<div id="images">';
    if ($page_part == 'all') {
      $images_html .= '<h2>' . t('Images') . '</h2>';
    }
    // Get the image gallery as configured by the admin.
    $taxon_image_gallery = call_user_func_array('taxon_image_gallery_' . variable_get('image_gallery_viewer', 'default'), array(
      $taxon,
      $media,
    ));
    $images_html .= $taxon_image_gallery;
    $images_html .= '</div>';
    $render_array['images'] = markup_to_render_array($images_html, $weight++);
    $toc_elements['images'] = l(t('Images'), $_GET['q'], array('fragment' => 'images', 'query' => $http_request_params));
  }

  // --- PAGE PART: SYNONYMY --- //
  if (($page_part == 'synonymy' || $page_part == 'all')) {
    $synonymy_html = '<div id="synonymy">';
    if ($page_part == 'all') {
      $synonymy_html .= '<h2>' . t('Synonymy') . '</h2>';
    }
    $addAcceptedTaxon = variable_get('cdm_dataportal_nomref_in_title', CDM_DATAPORTAL_NOMREF_IN_TITLE);
    $synonymy_html .= theme('cdm_taxon_page_synonymy', array('taxon' => $taxon, 'addAcceptedTaxon' => $addAcceptedTaxon));

    $synonymy_html .= '</div>';
    $render_array['synonymy'] = markup_to_render_array($synonymy_html, $weight++);
    $toc_elements['synonymy'] = l(t('Synonymy'), $_GET['q'], array('fragment' => 'synonymy', 'query' => $http_request_params));
  }

  // --- PAGE PART: SPECIMENS --- //
  if ($specimensOrObservationsCount > 0 && ($page_part == 'specimens' || $page_part == 'all')) {
    $render_array['specimens'] = array(
        '#prefix' => '<div id="specimens">' . ($page_part == 'all' ? '<h2>' . t('Specimens') . '</h2>' : ''),
        'content' => cdm_dataportal_taxon_page_specimens($taxon), // returns render array
        '#suffix' => '</div>',
    );
    $toc_elements['specimens'] = l(t('Specimens'), $_GET['q'], array('fragment' => 'specimens', 'query' => $http_request_params));
  }

  // --- PAGE PART: KEYS --- //
  if ($identificationKeyCount == 1 && $page_part == 'keys'){
    drupal_goto(path_to_key($polytomousKeysPager->records[0]->class, $polytomousKeysPager->records[0]->uuid));
  }
  else if ($identificationKeyCount > 0 && ($page_part == 'keys' || $page_part == 'all')) {
    $keys_html = '<div id="keys">';
    if ($page_part == 'all') {
      $keys_html .= '<h2>' . t('Keys') . '</h2>';
    }
    $keys_html .= theme('cdm_block_IdentificationKeys', array('taxonUuid' => $taxon->uuid));
    $keys_html .= '</div>';
    $render_array['keys'] = markup_to_render_array($keys_html, $weight++);
    $toc_elements['keys'] = l(t('Keys'), $_GET['q'], array('fragment' => 'keys', 'query' => $http_request_params));
  }


  if($page_part == 'all') {
    if(isset($render_array['profile'])) {
      // in case all tabs are shown at once the feature tocs
      // should be integrated into the tabs toc as sub list
      // and the profile image should be on top of the page
      if(isset($render_array['profile']['taxon_description_feature_toc'])){
//         $toc_elements['profile'] = array(
//             'data' => $toc_elements['profile'],
//             'children' => $render_array['profile']['taxon_description_feature_toc']['items']
//         );
        $toc_elements = array_merge($render_array['profile']['taxon_description_feature_toc']['#items'], $toc_elements);
        unset($toc_elements['profile']);
        unset($render_array['profile']['taxon_description_feature_toc']);
      }
      if($render_array['profile']['taxon_profile_image']){
        $render_array['profile_image'] = $render_array['profile']['taxon_profile_image'];
        $render_array['profile_image']['#weight'] = -100;
        unset($render_array['profile']['taxon_profile_image']);
      }
    }

    // finally add the table of contents to the render array
    $render_array['toc'] = array(
        '#theme' => 'item_list',
        '#items' => $toc_elements,
        '#title' => t('Content'),
        '#weight' => -101,
        '#suffix' => '</div>',
        '#prefix'=> '<div id="featureTOC">' // reusing id featureTOC even if this is semantically not correct
    );
  }
  return $render_array;
}




/**
 * Returns HTML containing the synonymy for the accepted taxon.
 *
 * Shows the whole synonymy for the accepted taxon.
 * The synonymy list is headed by the complete scientific name
 * of the accepted taxon with nomenclatural reference.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon
 *   - addAcceptedTaxon
 *
 * @ingroup themeable
 */
function theme_cdm_taxon_page_synonymy($variables) {
  $taxon = $variables['taxon'];
  $addAcceptedTaxon = $variables['addAcceptedTaxon'];

  RenderHints::pushToRenderStack('taxon_page_synonymy');

  // footnote key for the homotypic group and accepted taxon,
  // both should have the same footnote key
  RenderHints::setFootnoteListKey(RenderHints::getRenderPath());

  $synomymie = cdm_ws_get(CDM_WS_PORTAL_TAXON_SYNONYMY, $taxon->uuid);
  $skip = array(
    UUID_BASIONYM,
  );
  $out = '';

  // Render accepted taxon.
  //
  // foonotes of the accepted taxon will be rendered in the homotypic group section
  // even if there are not synonyms in the homotypic group
  // homotypic group and accepted taxon should have the same footnote key
  $referenceUri = '';
  if ($addAcceptedTaxon) {
    if (isset($taxon->name->nomenclaturalReference)) {
      $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
    }

    $accepted_name = '<span class="accepted-name">';
    $accepted_name .= theme('cdm_taxonName', array(
      'taxonName' => $taxon->name,
      'nameLink' => NULL,
      'refenceLink' => $referenceUri,
      ));
    $accepted_name .= '</span>';

    // handle annotations of the name and taxon
    $special_annotations_array = array();
    $special_annotations_array[] = $taxon->name;
    $special_annotations_array[] = $taxon;
    $accepted_name .= theme('cdm_annotations_as_footnotekeys', array(
        'cdmBase_list' => $special_annotations_array,
        'footnote_list_key' => RenderHints::getRenderPath() . '-annotations')
      );
  }

  // --- Render homotypic synonymy group
  if (!empty($accepted_name)) {
    $out .= $accepted_name;
  }

  // Render the homotypicSynonymyGroup including the type information.
  $out .= theme('cdm_homotypicSynonymyGroup', array('synonymList' => $synomymie->homotypicSynonymsByHomotypicGroup, 'accepted_taxon_uuid' => $taxon->uuid));


  // Render accepted taxon heterotypic synonymy groups.
  if ($synomymie->heterotypicSynonymyGroups) {
    foreach ($synomymie->heterotypicSynonymyGroups as $homotypicalGroup) {
      $out .= theme('cdm_heterotypicSynonymyGroup', array('homotypicalGroup' => $homotypicalGroup));
    }
  }
  // Render taxon relationships.
  if (variable_get(CDM_DATAPORTAL_DISPLAY_TAXON_RELATIONSHIPS, CDM_DATAPORTAL_DISPLAY_TAXON_RELATIONSHIPS_DEFAULT)) {
    $taxonRelationships = cdm_ws_get(CDM_WS_PORTAL_TAXON_RELATIONS, $taxon->uuid);
    $out .= theme('cdm_taxonRelationships', array('taxonRelationships' => $taxonRelationships, 'focusedTaxon' => $taxon));
  }
  // Render name relationships.
  $name_rels_to_show = variable_get('name_relationships_to_show', NULL);
  $skip = array();
  if ($name_rels_to_show) {
    foreach ($name_rels_to_show as $key => $value) {
      if ($value === 0) {
        $skip[] = $key;
      }
    }
    if (sizeof($name_rels_to_show) != sizeof($skip)) {
      $nameRelationships = cdm_ws_get(CDM_WS_PORTAL_TAXON_TO_NAMERELATIONS, $taxon->uuid);
      $out .= theme('cdm_nameRelationships', array('nameRelationships' => $nameRelationships, 'skipTypes' => $skip));
    }
  }

  RenderHints::popFromRenderStack();

  return $out;
}


/**
 * Returns HTML for the given result page including a pager.
 *
 * @param array $variables
 *   An associative array containing:
 *   - pager: The cdmlib pager object containing the result set of cdm base
 *     objects (currently this function can only handle taxon instances =>
 *     TODO)
 *   - path: The target path for the pager links, this will usually point to
 *     'cdm_dataportal/search/results/taxon'
 *
 * @ingroup themeable
 */
function theme_cdm_search_results($variables) {
  $pager = $variables['pager'];
  $path = $variables['path'];

  $freetextSearchResults = array();

  // If the pager contains records of SearchResults, extract the taxa and use
  // them as records instead.
  if (isset($pager->records[0]) && $pager->records[0]->class == "SearchResult") {
    $freetextSearchResults = $pager->records;
    $taxa = array();
    // $highlightedFragments = array();
    foreach ($pager->records as $searchResult) {
      $taxa[] = &$searchResult->entity;
      /*
       if(!isset($searchResult->fieldHighlightMap)){
      $searchResult->fieldHighlightMap = NULL;
      }
      $fragmentHighlighting[] = $searchResult->fieldHighlightMap;
      */
    }
    $pager->records = $taxa;
  }

  $out = '';
  // Add thumbnails checkbox and refine search link.
  $out = '<div class="page_options">';
  if (isset($_REQUEST['ws'])) {
    if (cdm_dataportal_search_form_path_for_ws($_REQUEST['ws'])) {
      $out .= '<div id="backButton">' . l(t('Modify search'), cdm_dataportal_search_form_path_for_ws($_REQUEST['ws'])) . '</div>';
    }
  }
  $out .= '<form name="pageoptions"><div id="showThumbnails"><input type="checkbox" name="showThumbnails" ' . (do_showThumbnails() == 1 ? 'checked="checked"' : '') . '> ' . t('Show Thumbnails') . '</div></form>';
  $out .= '</div>';
  $out .= '<div id="search-summary">' . t('results for') . ' ';
  $classification = cdm_dataportal_searched_in_classification();
  if ($classification != NULL) {
    $out .=  $classification->titleCache ;
  } else {
   $out .= t('any classification');
  }
  $out .= ':</div>';

  // List results.
  if (isset($pager->records) && count($pager->records) > 0) {
    $out .= '<div id="search_results">';
    $out .= theme('cdm_list_of_taxa',
        array(
          'records' => $pager->records,
          'freetextSearchResults' => $freetextSearchResults,
          'show_classification' => $classification === NULL
        )
      );
    $out .= '</div>';
    $out .= theme('cdm_pager', array(
        'pager' => $pager,
        'path' => $path,
        'parameters' => $_REQUEST,
    ));
  }
  else {
    $out .= '<h4 class="error">Sorry, no matching entries found.</h4>';
  }
  return $out;
}


/**
 * TODO Implementation of Hook taxon_image_gallery()
 *
 * @param unknown_type $taxon
 * @param unknown_type $media
 *
 * @return unknown_type
 */
function taxon_image_gallery_default($taxon, $media) {
  $hasImages = isset($media[0]);

  if ($hasImages) {

    $maxExtend = 150;
    $cols = 3;
    $maxRows = FALSE;
    $alternativeMediaUri = NULL;
    /* Comment @WA: was in D5:
    $captionElements = array(
      'title',
      'rights',
      '#uri' => t('open Image'),
    );
    */
    $captionElements = array(
      'title',
      'description',
      'artist',
      'location',
      'rights',
      '#uri' => t('open Image'),
    );
    $gallery_name = $taxon->uuid;
    $mediaLinkType = 'LIGHTBOX';

    // $gallery_settings = getGallerySettings(CDM_DATAPORTAL_MEDIA_GALLERY_NAME);

    $gallery_settings = getGallerySettings(CDM_DATAPORTAL_TAXON_MEDIA_GALLERY_NAME_TAB);

    $out = '<div class="image-gallerie">';
    $out .= theme('cdm_media_gallerie', array(
      'mediaList' => $media,
      'galleryName' => $gallery_name,
      'maxExtend' => $gallery_settings['cdm_dataportal_media_maxextend'],
      'cols' => $gallery_settings['cdm_dataportal_media_cols'],
      'maxRows' => 0, // Ignore maxrows settings.
      'captionElements' => $captionElements,
      'mediaLinkType' => $mediaLinkType,
      'alternativeMediaUri' => NULL,
      'galleryLinkUri' => NULL,
      'showCaption' => $gallery_settings['cdm_dataportal_show_thumbnail_captions'],
    ));
    $out .= '</div>';
  }
  else {
    $out = 'No images available.';
  }
  return $out;
}

/**
 * TODO Implementation of Hook taxon_image_gallery()
 *
 * @param unknown_type $taxon
 * @param unknown_type $media
 *
 * @return unknown_type
 */
function taxon_image_gallery_fsi($taxon, $media) {
  $flashLink = isset($media[0]);

  if ($flashLink) {

    if (module_exists("fsi_gallery")) {
      $out = theme("fsi_gallery", array('taxon' => $taxon, 'media' => $media));
    }
    else {
      $message = t('In order to use the FSI gallery you must enable the according ') . l(t("module"), "admin/modules");
      drupal_set_message($message, "error");
      $out = '<h3>' . $message . '</h3>';
    }
  }
  else {
    $out = 'No images available.';
  }
  return $out;
}

/**
 * Returns HTML for a single reference page.
 *
 * Renders a page with all data on a single reference.
 *
 * @param array $variables
 *   An associative array containing:
 *   - reference: Object.
 *
 * @ingroup themeable
 */
function theme_cdm_reference_page($variables) {
  $reference = $variables['reference'];

  $out = '';

  if (isset($reference->titleCache)) {
    drupal_set_title($reference->titleCache, PASS_THROUGH);
  }

  $field_order = array(
    "title",
    // "titleCache",
    // "citation",
    "authorTeam",
    "editor",
    "publisher",
    "placePublished",
    "datePublished",
    "year",
    "edition",// Class Book.
    "volume",// Class Article.
    "seriesPart",
    "inReference",
    "nomRefBase", // Class BookSection, Book, Article.
    "pages",// Class Article.
    "series",// Class Article, PrintSeries.
    "school",// Class Thesis.
    "institution",// Class Report.
    "organization",// Class Proceedings.
    "nextVersion",
    "previousVersion",
    "isbn",// Class Book.
    "issn",// Class Journal.
    "uri",
  );

  $header = array(
    t('Field'),
    t('Value'),
  );
  $table_rows = array();

  if (!isset($reference->authorTeam)) {
    $authorTeam = cdm_ws_get(CDM_WS_REFERENCE_AUTHORTEAM, $reference->uuid);
    $reference->authorTeam = isset($authorTeam->titleCache) ? $authorTeam->titleCache : '';
  }

  if (!isset($reference->inReference)) {
    $reference->inReference = cdm_ws_get(CDM_WS_REFERENCE, array(
      $reference->uuid,
      "inReference",
    ));
  }

  foreach ($field_order as $fieldname) {

    if (isset($reference->$fieldname)) {

      if ($fieldname == "datePublished") {
        $period = $reference->$fieldname;
        $datePublished = timePeriodToString($period);
        if (isset($datePublished) && $datePublished != '') {
          $table_rows[] = array(
            t(ucfirst(strtolower($fieldname))),
            $datePublished,
          );
        }
        // $datePublished = array(t(ucfirst(strtolower($fieldname))),
        // $datePublished);
      }
      elseif (is_object($reference->$fieldname)) {
        if ($fieldname == "authorTeam") {
          $dump = $reference->$fieldname;
          $teammembers = "teamMembers";
          $team = $dump->$teammembers;
          $nameArray = array();

          foreach ($team as $member) {
            if (strlen($member->lastname) > 0) {
              $nname = $member->lastname;
              $name = $nname;
              if (strlen($member->firstname) > 0) {
                $vname = $member->firstname;
                $name = $vname . " " . $nname;
              }
              $nameArray[] = $name;
            }
            else {
              if (strlen($member->titleCache) > 0) {
                $nameArray[] = $member->titleCache;
              }
            }
          }
          $value = join($nameArray, ", ");
        }
        elseif ($fieldname == "inReference") {
          $type = $reference->$fieldname->type;
          $value = l($reference->$fieldname->titleCache, path_to_reference($reference->$fieldname->uuid));
          switch ($type) {
            case "Book":
              $fieldname = "in book";
              break;
            case "Journal":
              $fieldname = "in journal";
              break;
            case "Proceedings":
              $fieldname = "in proceedings";
              break;
          }
        }
        else {
          $value = $reference->$fieldname->titleCache;
        }
        if (isset($value) && $value != '') {
          $table_rows[] = array(
            t(ucfirst(strtolower($fieldname))),
            $value,
          );
        }
      }
      else {
        if (isset($reference->$fieldname) && $reference->$fieldname != '') {
          $table_rows[] = array(
            t(ucfirst(strtolower($fieldname))),
            $reference->$fieldname,
          );
        }
      }
    }
  }

  $out = theme_table(array(
      'header' => array(),
      'rows' => $table_rows,
      'attributes' => array(),
      'caption' => NULL,
      'colgroups' => NULL,
      'sticky' => NULL,
     'empty' => NULL,
  ));

  // Annotations below the table.
  $annotations = cdm_ws_getAnnotationsFor($reference);
  $out .= theme("cdm_annotations", array('annotations' => $annotations));

  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_media_page($variables) {
  $media = $variables['media'];
  $mediarepresentation_uuid = $variables['mediarepresentation_uuid'];
  $partId = $variables['partId'];
  $out = '';
  // Determine which reprresentation and which part to show.
  $representationIdx = 0;
  if ($mediarepresentation_uuid) {
    $i = 0;
    foreach ($media->representations as $representation) {
      if ($representation->uuid == $mediarepresentation_uuid) {
        $representationIdx = $i;
      }
      $i++;
    }
  }
  else {
    $mediarepresentation_uuid = $media->representations[0]->uuid;
  }

  $partIdx = 0;
  if (!is_numeric($partId)) {
    // Assuming it is an uuid.
    $i = 0;
    foreach ($media->representations[$representationIdx]->parts as $part) {
      if ($part->uuid == $partId) {
        $partIdx = $i;
      }
      $i++;
    }
  }
  else {
    // Assuming it is an index.
    $partIdx = $partId;
  }

  $media_metadata = cdm_read_media_metadata($media);
  // $title = $media->titleCache;
  $title = $media_metadata['title'];

  $imageMaxExtend = variable_get('image-page-maxextend', 400);

  if (!$title) {
    $title = 'Media ' . $media->uuid . '';
  }

  drupal_set_title($title, PASS_THROUGH);

  $out .= '<div class="media cdm_media_viewer_image">';

  $out .= theme('cdm_back_to_image_gallery_button', array());
  $out .= '<div class="viewer">';
  $out .= theme('cdm_openlayers_image', array('mediaRepresentationPart' => $media->representations[$representationIdx]->parts[$partIdx], 'maxExtend' => $imageMaxExtend));
  $out .= '</div>';

  // General media metadata.
  /*
  $media_metadata = cdm_ws_get(CDM_WS_MEDIA_METADATA, array($media->uuid));
  vardump("PRINTING MEDIA METADATA");
  vardump($media_metadata);
  vardump("PRINTING MEDIA");
  vardump($media);
  */
  $metadataToPrint = theme('cdm_media_caption', array('media' => $media));
  $out .= $metadataToPrint;

  // Tabs for the different representations.
  // ul.secondary
  $out .= '<ul class="primary">';
  foreach ($media->representations as $representation) {
    $out .= '<li>' . l($media->representations[$representationIdx]->mimeType, path_to_media($media->uuid, $mediarepresentation_uuid, $partIdx)) . '</li>';
  }
  $out .= '</ul>';

  // Representation(-part) specific metadata.
  $thumbnailMaxExtend = 100;
  $out .= '<table>';
  $i = 0;
  foreach ($media->representations[$representationIdx]->parts as $part) {
    $out .= '<tr><th>' . t('Part') . ' ' . ($i + 1) . '</th><td>';
    switch ($part->class) {
      case 'ImageFile':
        $out .= $part->width . ' x ' . $part->height . ' - ' . $part->size . 'k';
        break;
      case 'AudioFile':
      case 'MovieFile':
        $out .= t('Duration') . ': ' . $part->duration . 's - ' . $part->size . 'k';
        break;
      default:
        $out .= $part->size . 'k';
    }

    $out .= '</td><td><a href="' . url(path_to_media($media->uuid, $mediarepresentation_uuid, $i)) . '">' . theme('cdm_media_gallerie_image', array('mediaRepresentationPart' => $part, 'maxExtend' => $thumbnailMaxExtend, 'addPassePartout' => TRUE));
    $i++;
  }
  $out .= '</table>';
  $out .= '</div>';

  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_polytomousKey_page($variables) {
  $polytomousKey = $variables['polytomousKey'];
  drupal_set_title($polytomousKey->titleCache, PASS_THROUGH);

  $out = theme("cdm_IdentificationKey", array(
    'identificationKey' => $polytomousKey,
    'doLinkToKeyPage' => FALSE,
    'showIdentificationKeyTitle' => FALSE,
    ));

  // Key nodes in linked style.
  $out .= theme('cdm_polytomousKey', array('polytomousKey' => $polytomousKey));
  /*
   * FIXME implement node type for keys !!!
   * (wrapping the content in the cdm_dataportal.node becomes obsolete then).
   */
  return '<div id="identificationKey">' . $out . '</div>';
}

/**
 * Returns HTML for taxon page tabs.
 *
 * Allows theming of the taxon page tabs.
 *
 * @param array $variables
 *   An associative array containing:
 *   - tabname
 *
 * @ingroup themeable
 */
function theme_cdm_taxonpage_tab($variables) {
  $tabname = $variables['tabname'];
  // TODO replace by using translations or theme the menue tabs itself instead?
  switch ($tabname) {
    default:
      return t($tabname);
  }
}
