<?php
/**
 * @file
 * Taxon Theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */

/**
 * Returns HTML for misapplied names and invalid designations.
 *
 * Both relation types are currently treated the same!
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxonRelationships
 *   - focusedTaxon
 *
 * @ingroup themeable
 */
function theme_cdm_taxonRelationships($variables) {
  $taxonRelationships = $variables['taxonRelationships'];
  $focusedTaxon = $variables['focusedTaxon'];
  if (!$taxonRelationships) {
    return;
  }

  RenderHints::pushToRenderStack('taxonRelationships');
  $footnoteListKey = 'taxonRelationships';
  RenderHints::setFootnoteListKey($footnoteListKey);

  $misapplied = array();
  $joinedAuthorTeams = array();

  $taxon_relationship_types = variable_get(CDM_TAXON_RELATIONSHIP_TYPES, unserialize(CDM_TAXON_RELATIONSHIP_TYPES_DEFAULT));

  // Aggregate misapplied names having the same fullname:
  foreach ($taxonRelationships as $taxonRelation) {

    if (in_array($taxonRelation->type->uuid, $taxon_relationship_types)) {

      if ($taxonRelation->type->uuid == UUID_MISAPPLIED_NAME_FOR || $taxonRelation->type->uuid == UUID_INVALID_DESIGNATION_FOR) {

        $name = $taxonRelation->fromTaxon->name->titleCache;

        $authorteam = cdm_ws_get(CDM_WS_REFERENCE_AUTHORTEAM, $taxonRelation->fromTaxon->sec->uuid);
        $authorteam = $authorteam->titleCache;

        if (!isset($misapplied[$name])) {
          // Render the first name found as representative for all others.
          $misapplied[$name]['out'] = cdm_related_taxon($taxonRelation->fromTaxon, UUID_MISAPPLIED_NAME_FOR);
        }
        else {
          // We need to add the anchors for all of the other mispplied names not
          // being rendered explicitly.
          $misapplied[$name]['out'] = uuid_anchor($taxonRelation->fromTaxon->uuid, $misapplied[$name]['out']);
        }

        // Collect all authors for this fullname.
        if (isset($authorteam)) {
          $misapplied[$name]['authorteam'][$authorteam] = '';
          $joinedAuthorTeams[$authorteam] = 'sensu ' . theme('cdm_reference', array('reference' => $taxonRelation->fromTaxon->sec));
        }
      }
      else {
        // All relationsship types but misapplied_name_for
        // invalid_designation_for.
        $taxon_relationships_lines[] = cdm_taxonRelationship($taxonRelation, TRUE, _is_invers_taxonRelationship($taxonRelation, $focusedTaxon), TRUE);
      }
    }
  }

  // Sort the joinedAuthorTeams and create footnotes and footnotekeys.
  ksort($joinedAuthorTeams);
  foreach ($joinedAuthorTeams as $authorteam => $sensuCitation) {
    $footnoteKey = FootnoteManager::addNewFootnote($footnoteListKey, $sensuCitation);
    $joinedAuthorTeams[$authorteam] = '<span class="sensu">sensu ' . $authorteam . theme('cdm_footnote_key', array('footnoteKey' => $footnoteKey)) . '</span>';
  }

  // ---- Generate output ---- //

  $out = '<div class="taxon-relationships">';
  if (is_array($misapplied) && count($misapplied) > 0) {
    $out .= '<ul class="misapplied">';
    foreach ($misapplied as $misapplied_name) {

      $out .= '<li class="synonym"><span class="misapplied">' . $misapplied_name['out'] . ' </span>';

      if (isset($misapplied_name['authorteam'])) {
        // Fill authors with the renderedFootnoteKey and sorting 'em.
        foreach ($misapplied_name['authorteam'] as $authorteam => &$renderedFootnoteKey) {
          $renderedFootnoteKey = $joinedAuthorTeams[$authorteam];
        }
        ksort($misapplied_name['authorteam']);
        $out .= join('; ', $misapplied_name['authorteam']);
      }
      $out .= '</li>';
    }
    $out .= '</ul>';
  }

  if (isset($taxon_relationships_lines) && is_array($taxon_relationships_lines) && count($taxon_relationships_lines) > 0) {
    $out .= '<ul class="taxonRelationships">';
    foreach ($taxon_relationships_lines as $taxon_relationship_line) {
      $out .= '<li class="synonym">' . $taxon_relationship_line . '</li>';
    }
    $out .= '</ul>';
  }

  $footnotes = theme('cdm_footnotes', array('footnoteListKey' => $footnoteListKey, 'enclosingTag' => 'li'));
  $footnotes .= theme('cdm_annotation_footnotes', array('footnoteListKey' => $footnoteListKey, 'enclosingTag' => 'li'));

// AK: why splitting footnotes at the sennsu string ??? this is weired and hacky
//     TODO remove below dead code
//   $tr_footnotes_exploded = explode('sensu', $tr_footnotes);
//   $tr_footnotes_aux = '';
//   foreach ($tr_footnotes_exploded as $element) {
//     $tr_footnotes_aux .= $element;
//   }

  $out .= '<ul class="footnotes">' . $footnotes . '</ul>';

  $out .= '</div>';

  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_acceptedFor($variables) {
  $accepted_for_uuid = $variables['acceptedFor'];

  if(!is_uuid($accepted_for_uuid)){
    return '';
  }

  RenderHints::pushToRenderStack('acceptedFor');
  $out = '';

  $synonym = cdm_ws_get(CDM_WS_PORTAL_TAXON, $accepted_for_uuid);
  if ($synonym) {
    $out .= '<span class="acceptedFor">';
    $out .= t('is accepted for ');
    if (isset($synonym->name->nomenclaturalReference)) {
      $referenceUri = url(path_to_reference($synonym->name->nomenclaturalReference->uuid));
    }
    $out .= theme('cdm_taxonName', array(
      'taxonName' => $synonym->name,
      'nameLink' => NULL,
      'refenceLink' => $referenceUri,
      ));
    $out .= theme('cdm_annotations_as_footnotekeys', array('cdmBase_list' => $synonym));
    $out .= '</span>';
  }
  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * @todo document this function.
 */
function theme_cdm_list_of_taxa($variables) {

  $unclassified_snippet = '<span class="unclassified">' . t('unclassified') . '</span>';

  $records = $variables['records'];
  $freetextSearchResults = $variables['freetextSearchResults'];
  $show_classification = $variables['show_classification'];

  RenderHints::pushToRenderStack('list_of_taxa');

  $form_name = 'search_gallery';
  // $default_values = unserialize(CDM_DATAPORTAL_GALLERY_SETTINGS);
  // $gallery_settings = variable_get($form_name, $default_values);
  $gallery_settings = getGallerySettings(CDM_DATAPORTAL_SEARCH_GALLERY_NAME);

  $showMedia_taxa = $gallery_settings['cdm_dataportal_show_taxon_thumbnails'];
  $showMedia_synonyms = $gallery_settings['cdm_dataportal_show_synonym_thumbnails'];
  // $showMedia_taxa =
  // variable_get('cdm_dataportal_findtaxa_show_taxon_thumbnails', 1);
  // $showMedia_synonyms =
  // variable_get('cdm_dataportal_findtaxa_show_synonym_thumbnails', 0);
  $classification_uuid = get_taxonomictree_uuid_selected();

  // .. Well, for sure not as performant as before, but better than nothing.
  $synonym_uuids = array();
  $misappied_uuids = array();
  foreach ($records as $taxon) {
    if ($taxon->class == "Synonym") {
      if (!array_key_exists($taxon->uuid, $synonym_uuids)) {
        $synonym_uuids[$taxon->uuid] = $taxon->uuid;
      }
    }
    elseif (!_cdm_dataportal_acceptedByCurrentView($taxon)) {
      // Assuming that it is a misappied name, will be further examined below.
      $misappied_uuids[$taxon->uuid] = $taxon->uuid;
    }
  }

  // Batch service not jet implemented:
  // $table_of_accepted = cdm_ws_property(CDM_WS_TAXON_ACCEPTED,
  // join(',', $synonym_uuids));
  // thus ...
  $table_of_accepted = array();

  foreach ($synonym_uuids as $relatedUuid) {
    $table_of_accepted[$relatedUuid] = cdm_ws_get(CDM_WS_TAXON_ACCEPTED, array(
      $relatedUuid,
      $classification_uuid,
    ));
  }

  foreach ($misappied_uuids as $relatedUuid) {
    $taxonRelations = cdm_ws_get(CDM_WS_PORTAL_TAXON_RELATIONS, array(
      $relatedUuid,
    ));
    foreach ($taxonRelations as $relation) {
      if ($relation->type->uuid == UUID_MISAPPLIED_NAME_FOR && _cdm_dataportal_acceptedByCurrentView($relation->toTaxon)) {
        $table_of_accepted[$relatedUuid][] = $relation->toTaxon;
      }
    }
  }

  $out = '<ul class="cdm_names" style="background-image: none;">';
  $itemCnt = -1;
  foreach ($records as $taxon) {
    $itemCnt++;
    if (isset($table_of_accepted[$taxon->uuid])) {
      // Its a synonym or misapplied name.
      $is_synonym = isset($synonym_uuids[$taxon->uuid]);
      $class_name = $is_synonym ? "Synonym" : "misapplied-name";

      $acceptedTaxa = $table_of_accepted[$taxon->uuid];

      if (count($acceptedTaxa) == 1) {

        $acceptedTaxon = $acceptedTaxa[0];
        $taxonUri = uri_to_synonym($taxon->uuid, $acceptedTaxon->uuid, 'synonymy');
        $referenceUri = '';
        if (isset($acceptedTaxon->name->nomenclaturalReference)) {
          $referenceUri = url(path_to_reference($acceptedTaxon->name->nomenclaturalReference->uuid));
        }
        $out .= '<li class="' . $class_name . '">' . theme('cdm_taxonName', array(
          'taxonName' => $taxon->name,
          'nameLink' => $taxonUri,
          'refenceLink' => $referenceUri,
          ));
        if (!$is_synonym) {
          $out .= '<span class="sensu"> sensu ' . theme('cdm_reference', array('reference' => $taxon->sec)) . '</span>';
        }
        if ($show_classification) {
          $classifications = get_classifications_for_taxon($taxon);
          $classification_titles = array();
          foreach ($classifications as $classification) {
            if (isset($classification->titleCache)) {
              $classification_titles[] = $classification->titleCache;
            }
          }
          if(count($classification_titles) == 0){
            $classification_titles[] = $unclassified_snippet;
          }
          $out .= ' : <span class="classifications">' . implode(', ', $classification_titles) . '</span>';
        }
        $out .= theme('cdm_annotations_as_footnotekeys', array('cdmBase_list' => $taxon));
        if ($showMedia_synonyms) {
          $out .= theme('cdm_taxon_list_thumbnails', array('taxon' => $acceptedTaxon));
        }
      }
      else {

        // TODO avoid using Ajax in the cdm_dynabox .... why?
        // TODO add media.
        $out .= cdm_dynabox(
            $taxon->uuid,// dynabox uuid
            // taxon name as label:
            theme('cdm_taxonName', array(
              'taxonName' => $taxon->name,
              'nameLink' => NULL,
              'refenceLink' => NULL,
              'show_annotations' => FALSE,
            )),
            // content_url:
            cdm_compose_url(CDM_WS_TAXON_ACCEPTED,
                array(
                    $taxon->uuid,
                    $classification_uuid
                )
            ),
            // theme to use for rendering:
            'cdm_list_of_taxa',
            // label to toggle open:
            'Click for accepted taxon'
         );
      }
    }
    else {
      // Its a Taxon.
      $taxonUri = url(path_to_taxon($taxon->uuid));
      $referenceUri = '';
      if (isset($taxon->name->nomenclaturalReference)) {
        $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
      }
      $out .= '<li class="Taxon">' . theme('cdm_taxonName', array(
        'taxonName' => $taxon->name,
        'nameLink' => $taxonUri,
        'refenceLink' => $referenceUri,
        ));
      if ($show_classification) {
        $classifications = get_classifications_for_taxon($taxon);
        $classification_titles = array();
        foreach ($classifications as $classification) {
          if (isset($classification->titleCache)) {
            $classification_titles[] = $classification->titleCache;
          }
        }
        if(count($classification_titles) == 0){
          $classification_titles[] = $unclassified_snippet;
        }
        $out .= ' : <span class="classifications">' . implode(', ', $classification_titles) . '</span>';
      }
      $out .= theme('cdm_annotations_as_footnotekeys', array('cdmBase_list' => $taxon));

      if ($showMedia_taxa) {
        $out .= theme('cdm_taxon_list_thumbnails', array('taxon' => $taxon));
      }
    }

    /*
     * the score field will be empty in case of MultiTermQueries like
     * WildcardQueries, since these are  constant score by default
     * since Lucene 2.9
     */
    if(isset($freetextSearchResults[$itemCnt]) && $freetextSearchResults[$itemCnt]->score && $freetextSearchResults[$itemCnt]->maxScore){
      $percentage =  ( $freetextSearchResults[$itemCnt]->score / $freetextSearchResults[$itemCnt]->maxScore ) * 100;
      $out .= '<div class="score-bar"><div class="score-bar-indicator" style="width:' . $percentage .'% "></div></div>';
      $out .= '<div class="score-bar-value">' . number_format($percentage, 2) .'%</div>';
    }

    // Render highlighted fragments, these are made available by free text
    // searches.
    if (isset($freetextSearchResults[$itemCnt]->fieldHighlightMap)) {
      $field_fragments = (array) $freetextSearchResults[$itemCnt]->fieldHighlightMap;
      if (count($field_fragments) > 0) {
        $fragments_out = '';
        foreach ($field_fragments as $fieldName => $fragments) {
          $fragments_out .= '... <span class="' . $fieldName. '">' . filter_xss(join(" ... ", $fragments), array('b') ) . '</span>';
        }
        $out .= '<div class="fragment_highlight">' . $fragments_out . ' ...</div>';
      }
    }

    $out .= '</li>';
  }

  $out .= '</ul>';
  RenderHints::popFromRenderStack();

  return $out;
}

/**
 * Renders a representation of the given taxon relationship.
 *
 * According name relationships are also being rendered.
 *
 * @param unknown_type $taxonRelationship
 * @param boolean $doLinkTaxon
 *     whether to create a link to the related taxon
 * @param boolean $inverse
 *     whether the $taxonRelationship should be treaded as invers relation
 * @param unknown_type $showSecReference
 *     whether the secundum reference for the related taxon should be shown
 *
 * @return void|string
 */
function cdm_taxonRelationship($taxonRelationship, $doLinkTaxon = FALSE, $inverse = FALSE, $showSecReference = FALSE) {

  // Validate object.
  if (!(isset($taxonRelationship->toTaxon) && isset($taxonRelationship->fromTaxon) && isset($taxonRelationship->type))) {
    return;
  }

  $reltype_uuid = $taxonRelationship->type->uuid;
  $taxonRelationType = $taxonRelationship->type;

  $reltype_representation = '';

  if ($inverse) {
    $toTaxon = $taxonRelationship->fromTaxon;
    $fromTaxon = $taxonRelationship->toTaxon;
    $relsign = $taxonRelationType->inverseRepresentation_L10n_abbreviatedLabel;
    $reltype_representation = $taxonRelationType->inverseRepresentation_L10n;
  }
  else {
    $toTaxon = $taxonRelationship->toTaxon;
    $fromTaxon = $taxonRelationship->fromTaxon;
    $relsign = $taxonRelationType->representation_L10n_abbreviatedLabel;
    $reltype_representation = $taxonRelationType->representation_L10n;
  }

  return cdm_related_taxon($toTaxon, NULL, $relsign, $reltype_representation, $doLinkTaxon, $showSecReference);
}

/**
 * Renders a representation of the given taxon relationship.
 *
 * According name relationships are also being rendered.
 */
function cdm_related_taxon($taxon, $reltype_uuid = NULL, $relsign = NULL, $reltype_representation = NULL, $doLinkTaxon = FALSE, $showSecReference = FALSE) {
  static $relsign_homo = '≡';
  static $relsign_hetero = '=';
  static $relsign_invalid = '&ndash;';

  // 'taxonRelationships';
  $footnoteListKey = NULL;

  $name_prefix = '';
  $name_postfix = '';

  $skiptags = array();

  if (!$relsign) {

    $relsign = '';
    switch ($reltype_uuid) {
      case UUID_HETEROTYPIC_SYNONYM_OF:
      case UUID_SYNONYM_OF:
        $relsign = $relsign_hetero;
        break;

      case UUID_HOMOTYPIC_SYNONYM_OF:
        $relsign = $relsign_homo;
        break;

      case UUID_MISAPPLIED_NAME_FOR:
      case UUID_INVALID_DESIGNATION_FOR:
        $skiptags[] = 'authors';
        $relsign = $relsign_invalid;
        $name_prefix = '"';
        $name_postfix = '"';
        break;

      default:
        $relsign = $relsign_invalid;
    }
  }
  /*
  Names with status invalid or nudum are to be displayed with the
  $relsign_invalid, these names appear at the end of all names in their
  homotypic group (ordered correctly by the java cdm_lib).
  */
  if (isset($taxon->name->status) && is_array($taxon->name->status)) {
    foreach ($taxon->name->status as $status) {
      if ($status->type->uuid == UUID_NOMENCLATURALSTATUS_TYPE_INVALID || $status->type->uuid == UUID_NOMENCLATURALSTATUS_TYPE_NUDUM) {
        $relsign = $relsign_invalid;
      }
    }
  }

  // Now rendering starts ..
  RenderHints::pushToRenderStack('related_taxon');

  if (isset($taxon->name->nomenclaturalReference)) {
    $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
  }
  $taxonUri = '';
  if ($doLinkTaxon) {
    $taxonUri = url(path_to_taxon($taxon->uuid, "synonymy"));
  }
  // Printing the taxonName and the handling the special case of annotations.
  if (!isset($referenceUri)) {
    $referenceUri = FALSE;
  }
  $out_taxon_part = theme('cdm_taxonName', array(
    'taxonName' => $taxon->name,
    'nameLink' => $taxonUri,
    'refenceLink' => $referenceUri,
    'show_annotations' => TRUE,
    'is_type_designation' => FALSE,
    'skiptags' => $skiptags,
    ));
  $out_taxon_part .= theme('cdm_annotations_as_footnotekeys',
       array('cdmBase_list' => array(
         $taxon->name,
         $taxon,
       ),
       'footnote_list_key' => $footnoteListKey)
  );

  if ($showSecReference) {
    $out_taxon_part .= ' sec. ' . theme('cdm_reference', array('reference' => $taxon->sec));
  }


  // =========== START OF HOMONYMS ========== //
  RenderHints::pushToRenderStack('homonym');
  // the render stack element homonyms is being used in the default render templates !!!, see CDM_NAME_RENDER_TEMPLATES_DEFAULT

  // Later homonym or treated as later homonym AND bloking names.
  // TODO apply filter ? $name_rels_to_show = variable_get('name_relationships_to_show', NULL);
  $from_name_relations = cdm_ws_get(CDM_WS_PORTAL_TAXON_FROM_NAMERELATIONS, $taxon->uuid);
  $to_name_relations = cdm_ws_get(CDM_WS_PORTAL_TAXON_TO_NAMERELATIONS, $taxon->uuid);
  $name_relations  = array_merge($from_name_relations, $to_name_relations);

  $homonyms_array = array();

  if ($name_relations) {
    foreach ( $name_relations as $element ) {
      $taxon_html = null;
      switch ($element->type->uuid) {
          case UUID_LATER_HOMONYM :
              $elementTaxonBasesUuid = isset ($element->toName->taxonBases [0]->uuid) ? $element->toName->taxonBases [0]->uuid : '';

              //from relation ships -> only shown at fromName-synonym
              if ($taxon->name->uuid == $element->fromName->uuid) {
                  $taxon_html = theme('cdm_taxonName', array(
                      'taxonName' => $element->toName,
                      'nameLink' => path_to_name($element->toName->uuid, $taxon->uuid, $elementTaxonBasesUuid)
                  ));
              }
              break;
          case UUID_TREATED_AS_LATER_HOMONYM :
              $elementTaxonBasesUuid = isset ($element->toName->taxonBases [0]->uuid) ? $element->toName->taxonBases [0]->uuid : '';

              //from relation ships -> only shown at fromName-synonym
              if ($taxon->name->uuid == $element->fromName->uuid) {
                  $taxon_html = theme('cdm_taxonName', array(
                      'taxonName' => $element->toName,
                      'nameLink' => path_to_name($element->toName->uuid)
                  ));
              }
              break;
          case UUID_BLOCKING_NAME_FOR :
              $elementTaxonBasesUuid = isset ($element->fromName->taxonBases [0]->uuid) ? $element->fromName->taxonBases [0]->uuid : '';

              //to relation ships -> only shown at toName-synonym
              if ($taxon->name->uuid == $element->toName->uuid) {
                  $taxon_html = theme('cdm_taxonName', array(
                      'taxonName' => $element->fromName,
                      'nameLink' => path_to_name($element->fromName->uuid, $taxon->uuid, $elementTaxonBasesUuid)
                  ));
              }
              break;
          default:
              $taxon_html = null;
      }
      if (isset($taxon_html) && $taxon_html) {
        if (count ( $homonyms_array )) {
          $homonyms_array [] = 'nec ' . $taxon_html;
        } else {
          $homonyms_array [] = 'non ' . $taxon_html;
        }
      }
    }
  }

  RenderHints::popFromRenderStack();
  // =========== END OF HOMONYMS ========== //

  $out = '<span class="relation_sign" title="' . $reltype_representation . '">' . $relsign . '</span>'
      . $name_prefix . $out_taxon_part . $name_postfix . ' '
      . (count($homonyms_array) ?'[' . trim(join(" ", $homonyms_array)) . ']' : '');

  $out = uuid_anchor($taxon->uuid, $out);

  RenderHints::popFromRenderStack();

  return $out;
}

/**
 * @todo document this function.
 */
function theme_cdm_taxon_list_thumbnails($variables) {

  $taxon = $variables['taxon'];
  $out = '';
  $gallery_settings = getGallerySettings(CDM_DATAPORTAL_SEARCH_GALLERY_NAME);
  $showCaption = $gallery_settings['cdm_dataportal_show_thumbnail_captions'];
  if ($showCaption) {
    $captionElements = array(
      'title',
      'rights',
    );
  } else {
    $captionElements = array();
  }

  $gallery_name = $taxon->uuid;

  $mediaList = _load_media_for_taxon($taxon);

  $galleryLinkUri = path_to_taxon($taxon->uuid, 'images');

  $out .= theme('cdm_media_gallerie', array(
    'mediaList' => $mediaList,
    'galleryName' => $gallery_name,
    'maxExtend' => $gallery_settings['cdm_dataportal_media_maxextend'],
    'cols' => $gallery_settings['cdm_dataportal_media_cols'],
    'maxRows' => $gallery_settings['cdm_dataportal_media_maxRows'],
    'captionElements' => $captionElements,
    'mediaLinkType' => 'LIGHTBOX',
    'alternativeMediaUri' => NULL,
    'galleryLinkUri' => $galleryLinkUri,
     ));

  return $out;
}
