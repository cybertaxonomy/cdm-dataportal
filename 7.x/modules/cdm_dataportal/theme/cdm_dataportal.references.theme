<?php
/**
 * @file
 * Reference theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_reference_pager($variables) {
  $referencePager = $variables['referencePager'];
  $path = $variables['path'];
  $parameters = $variables['parameters'];
  drupal_set_title(t('Bibliographic index'), PASS_THROUGH);
  $out = '';
  if (count($referencePager->records) > 0) {
    $out .= '<ul>';
    foreach ($referencePager->records as $reference) {
      // FIXME remove hack.
      $reference->fullCitation = $reference->titleCache;
      // For matching cdm entity to STO.
      $out .= '<li>' . theme('cdm_reference', array(
        'reference' => $reference,
        'microReference' => NULL,
        'doLink' => TRUE,
        )) . '</li>';
    }
    $out .= '</ul>';
    $out .= theme('cdm_pager', array(
      'pager' => $referencePager,
      'path' => $path,
      'parameters' => $parameters,
    ));
  }
  else {
    $out = '<h4 class="error">Sorry, this page contains not entries.</h4>';
  }
  return $out;
}

/**
 * Returns HTML for a reference.
 *
 * Used by:
 * - theme_cdm_typedesignations
 * - theme_cdm_reference_pager
 * - theme_cdm_taxonRelationships
 *
 * @param array $variables
 *   An associative array containing:
 *   - reference
 *   - microReference
 *   - doLink
 *   - referenceStyle
 *
 * @ingroup themeable
 */
function theme_cdm_reference($variables) {
  $reference = $variables['reference'];
  $microReference = $variables['microReference'];
  $doLink = $variables['doLink'];
  $referenceStyle = $variables['referenceStyle'];

  if(!isset($reference->authorTeam)){
    $author_team = cdm_ws_get(CDM_WS_REFERENCE_AUTHORTEAM, $reference->uuid);
  } else {
    $author_team = $reference->authorTeam;
  }

  if ($referenceStyle == "zoology") {
    $year = '';
    if (isset($reference->datePublished->start)) {
      $year = partialToYear($reference->datePublished->start);
    }
    $citation = $author_team->titleCache . (!empty($year) ? '. ' . $year : '');
  }
  else {
    $citation = $reference->titleCache;
  }

  if (isset($doLink) && $doLink === TRUE) {
    $out = '<span class="reference">';
    $out .= l($citation, path_to_reference($reference->uuid), array(
      'attributes' => array(
        "class" => "reference",
      ),
      'absolute' => TRUE,
      'html' => TRUE,
    ));
    $out .= '</span>';
  }
  else {
    $out = '<span class="reference">' . $citation . '</span>';
  }

  if (!empty($microReference)) {
    $out .= ": " . $microReference;
  }

  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function _short_form_of_author_team($author_team) {
  $number_of_authors = substr_count($author_team, ' & ') + 1;
  // var_dump($author_team);
  // var_dump($number_of_authors);
  switch ($number_of_authors) {
    case 1:
      $result = $author_team;
      break;

    case 2:
      $result = str_replace(' & ', ' and ', $author_team);
      break;

    default:
      $result_parts = explode(' & ', $author_team);
      $result = $result_parts[0] . ' et al.';
  }
  return $result;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_OriginalSource($variables) {
  $out = '';
  $source = $variables['source'];
  $doLink = $variables['doLink'];

  if (isset($source->citation)) {
    $out = theme('cdm_reference', array(
        'reference' => $source->citation,
        'microReference' => $source->citationMicroReference,
        'doLink' => $doLink,
    ));

    $name_in_source = '';
    if (isset($source->nameUsedInSource)) {
      $name_in_source = theme('cdm_taxonName', array(
          'taxonName' => $source->nameUsedInSource
      ));
    } else if (isset($source->originalNameString) && !empty($source->originalNameString)) {
      // the name used in source can not be expressed as valid taxon name,
      // so the editor has chosen to put the freetext name into ReferencedEntityBase.originalNameString
      // field
      // using the originalNameString as key to avoid duplicate entries
      $name_in_source = $source->originalNameString;
    }
    if($name_in_source) {
      $out .=  ' <span class="nameUsedInSource">(' . t('as') . ' ' . $name_in_source . ')</span>';
    }

    $id_with_namespace = '';
    if( isset($source->idNamespace) && $source->idNamespace ) {
      $id_with_namespace = $source->idNamespace . '/';
    }
    if( isset($source->idInSource) && $source->idInSource ) {
      $id_with_namespace .= $source->idInSource;
    } else {
      $id_with_namespace = NULL;
    }

    if($id_with_namespace){
      $out .=  ' <span class="idInSource">[' . $id_with_namespace . ']</span>';
    }
  }
  return $out;
}
