<?php
/**
 * @file
 * Description theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */


/**
 * Theme function to alter the feature representation.
 *
 * It is highly qeutionalbe if this function should be completely removed.
 * If a feature needs a different representation this should be edited directly
 * in the cdm data but it shoud not be tweeked like this in the portal.
 *
 * Used in:
 *  - theme_cdm_feature_nodesTOC()
 *  - theme_cdm_feature_nodes()
 *  - theme_cdm_media_mime_application()
 *  - theme_cdm_media_mime_text()
 *
 * TODO delete this function? (a.kohlbecker feb 2013)
 *
 */
function theme_cdm_feature_name($variables) {
  $feature_name = $variables['feature_name'];
  return t($feature_name);
}

/**
 * Returns a set of feature blocks for a taxon profile from the $mergedFeatureNodes of a given $taxon.
 *
 * The taxon profile consists of drupal block elements, one for the description elements
 * of a specific feature. The structure is defined by specific FeatureTree.
 * The chosen FeatureTree is merged with the list of description elements prior to using this method.
 *
 * The merged nodes can be obtained by making use of the
 * function cdm_ws_descriptions_by_featuretree().
 *
 * @see cdm_ws_descriptions_by_featuretree()
 *
 * @param $mergedFeatureNodes
 *
 * @param $taxon
 *
 * @return array
 *  A Drupal render array containing feature blocks and the table of content
 *
 * @ingroup compose
 */
function compose_cdm_feature_nodes($mergedFeatureNodes, $taxon) {

  $block_list = array();

  RenderHints::pushToRenderStack('feature_nodes');

  $gallery_settings = getGallerySettings(CDM_DATAPORTAL_DESCRIPTION_GALLERY_NAME);

  // Create a drupal block for each feature
  foreach ($mergedFeatureNodes as $node) {

    if ((isset($node->descriptionElements['#type']) ||
        has_feature_node_description_elements($node)) && $node->feature->uuid != UUID_IMAGE) { // skip empty or supressed features

      $feature_name = cdm_term_representation($node->feature, 'Unnamed Feature');

      $block = feature_block($feature_name, $node->feature);
      $block->content = array();
      $block_content_is_empty = TRUE;
      $block_content_weight = 0;

      /*
       * Content/DISTRIBUTION.
       */

      if ($node->feature->uuid == UUID_DISTRIBUTION) {
        $block = compose_feature_block_distribution($taxon, $node->descriptionElements, $node->feature);
        $block_content_is_empty = FALSE;
      }
      /*
       * Content/COMMON_NAME.
       */
      else if ($node->feature->uuid == UUID_COMMON_NAME) {
        $common_names_render_array = compose_cdm_common_names($node->descriptionElements, $node->feature);
        $block->content[] = $common_names_render_array;
        $block_content_is_empty = FALSE;
      }

      else if ($node->feature->uuid == UUID_USE_RECORD) {
        $block_uses_content_html = theme('cdm_block_Uses', array('taxonUuid' => $taxon->uuid));
        $block->content[] = markup_to_render_array($block_uses_content_html);
        $block_content_is_empty = FALSE;
      }

      /*
       * Content/ALL OTHER FEATURES.
       */
      else {

        $media_list = array();
        $out_child_elements = '';

        if (isset($node->descriptionElements)) {
          $taxon_uuid = NULL;
          if(isset($taxon) ) {
            $taxon_uuid = $taxon->uuid;
          }
          $elements_render_array = compose_cdm_descriptionElements($node->descriptionElements, $node->feature, $taxon_uuid);
          $block_content_is_empty = empty($elements_render_array);
          $block->content[] = $elements_render_array;
        }

          // Content/ALL OTHER FEATURES/Subordinate Features
          // subordinate features are printed inline in one floating text,
          // it is expected hat subordinate features can "contain" TextData,
          // Qualitative- and Qualitative- DescriptioneElements
          if (isset($node->childNodes[0])) {

          // TODO support more than one level of children.
          // can this be solved by recursively calling this function?
          // @see http://dev.e-taxonomy.eu/trac/ticket/2393
          $text = '';
          foreach ($node->childNodes as $child) {

            if (isset($child->descriptionElements) && is_array($child->descriptionElements)) {
              foreach ($child->descriptionElements as $element) {

                //TODO it woud be better if we could use compose_cdm_descriptionElements() directly instead of the below stuff

                if (is_array($element->media)) {
                  // Append media of supordinate elements to list of main
                  // feature.
                  $media_list = array_merge($media_list, $element->media);
                }

                switch ($element->class) {
                  case 'TextData':
                    // FIXME use theme_cdm_descriptionElementTextData()
                    if(isset($element->multilanguageText_L10n->text)){
                      $out_child_elements = str_replace("\n", "<br/>", $element->multilanguageText_L10n->text);
                    }
                    $out_child_elements = str_replace($child->feature->titleCache, '<em>' . $child->feature->representation_L10n . '</em>', $out_child_elements);
                    break;
                  case 'CategoricalData':
                    $out_child_elements  = '<em>' . $child->feature->representation_L10n . '</em> '
                      . theme('cdm_descriptionElement_CategoricalData', array('element' => $element));
                    break;
                  case 'QuantitativeData':
                    $out_child_elements = '<em>' . $child->feature->representation_L10n . '</em> '
                      . theme('cdm_descriptionElement_QuantitativeData', array('element' => $element));

                }

              }
              $text .= " " . $out_child_elements;
              $out_child_elements = '';
            }
          }
          $block_content_is_empty = $block_content_is_empty && empty($text);
          $block->content[] = markup_to_render_array($text);
          $block_content_is_empty = $block_content_is_empty && empty($media_list);
          $block->content[] = compose_feature_media_gallery($node, $media_list, $gallery_settings);


          }
        /*
         * Footnotes for the feature block
         */
        $block->content[] = markup_to_render_array(theme('cdm_footnotes', array('footnoteListKey' => $node->feature->uuid)));
        $block->content[] = markup_to_render_array(theme('cdm_annotation_footnotes', array('footnoteListKey' => $node->feature->uuid)));
      } // END all other features

      if(!$block_content_is_empty){ // skip empty block content
        $block_list[] = $block;
        cdm_toc_list_add_item(cdm_term_representation($node->feature), $node->feature->uuid);
      } // END: skip empty block content
    } // END: skip empty or supressed features
  } // END: creating a block per feature

  drupal_alter('cdm_feature_node_blocks', $block_list, $taxon);

  RenderHints::popFromRenderStack();

  return _block_get_renderable_array($block_list);
}

  /**
   * @param $node
   * @param $media_list
   * @param $gallery_settings
   * @return array
   */
  function compose_feature_media_gallery($node, $media_list, $gallery_settings) {
    if (isset($node->descriptionElements)) {
      $media_list = array_merge($media_list, cdm_dataportal_media_from_descriptionElements($node->descriptionElements));
    }
    $captionElements = array('title', 'rights');
    $gallery = '';
    if (isset($gallery_settings['cdm_dataportal_media_maxextend']) && isset($gallery_settings['cdm_dataportal_media_cols'])) {
      $gallery = theme('cdm_media_gallerie', array(
        'mediaList' => $media_list,
        'galleryName' => CDM_DATAPORTAL_DESCRIPTION_GALLERY_NAME . '_' . $node->feature->uuid,
        'maxExtend' => $gallery_settings['cdm_dataportal_media_maxextend'],
        'cols' => $gallery_settings['cdm_dataportal_media_cols'],
        'captionElements' => $captionElements,
      ));
      return markup_to_render_array($gallery);
    }
    return markup_to_render_array($gallery);
  }

  /**
   * @param $taxon
   * @param $descriptionElements
   *   an associative array with two elements:
   *   - '#type': must be 'DTO'
   *   - 'DistributionInfoDTO': a CDM DistributionInfoDTO object as returned by the DistributionInfo web service
   * @param $feature
   *
   * @ingroup compose
   */
  function compose_feature_block_distribution($taxon, $descriptionElements, $feature) {
    $text_data_glue = '';
    $text_data_sortOutArray = FALSE;
    $text_data_enclosingTag = 'ul';
    $text_data_out_array = array();

    $distributionElements = NULL;
    $distribution_info_dto = NULL;
    $distribution_sortOutArray = FALSE;

    if (variable_get('distribution_sort', 'NO_SORT') != 'NO_SORT') {
      $distribution_glue = '';
      $distribution_enclosingTag = 'dl';
    } else {
      $distribution_glue = '';
      $distribution_enclosingTag = 'ul';
    }

    if (!isset($descriptionElements['#type']) || !$descriptionElements['#type'] == 'DTO') {
      // skip the DISTRIBUTION section if there is no DTO type element
      return array(); // FIXME is it ok to return an empty array?
    }

    $block = feature_block(
      cdm_term_representation($feature, 'Unnamed Feature'),
      $feature
    );

    // $$descriptionElements['TextData'] is added to to the feature node in merged_taxon_feature_tree()
    if (isset($descriptionElements['TextData'])) {
      // --- TextData
      foreach ($descriptionElements['TextData'] as $text_data_element) {
        $asListElement = FALSE;
        $text_data_render_array = compose_cdm_descriptionElementTextData($text_data_element, $asListElement, $text_data_element->feature->uuid);
        $repr = drupal_render($text_data_render_array);

        if (!array_search($repr, $text_data_out_array)) { // de-duplication !!
          $text_data_out_array[] = $repr;
          // TODO HINT: sorting in compose_cdm_feature_block_elements will
          // not work since this array contains html attributes with uuids
          // and what is about cases like the bibliography where
          // any content can be prefixed with some foot-note anchors?
          $text_data_sortOutArray = TRUE;
          $text_data_glue = '<br/> ';
          $text_data_enclosingTag = 'p';
        }
      }
    }


    if ($text_data_out_array && variable_get(DISTRIBUTION_TEXTDATA_DISPLAY_ON_TOP, 0)) {
      $block->content[] = compose_cdm_feature_block_elements(
        $text_data_out_array,
        $feature,
        $text_data_glue,
        $text_data_sortOutArray,
        $text_data_enclosingTag
      );
    }

    // --- Distribution map
    $distribution_map_query_parameters = NULL;
    if (isset($descriptionElements['DistributionInfoDTO'])) {
      $distribution_map_query_parameters = $descriptionElements['DistributionInfoDTO']->mapUriParams;
    }
    $map_render_element = compose_distribution_map($taxon, $distribution_map_query_parameters);
    $block->content[] = $map_render_element;

    // --- tree or list
    $dto_out_array = array();
    if (isset($descriptionElements['DistributionInfoDTO'])) {
      $distribution_info_dto = $descriptionElements['DistributionInfoDTO'];

      // --- tree
      if (is_object($distribution_info_dto->tree)) {
        $dto_out_array[] = theme('cdm_description_ordered_distributions', array('distribution_tree' => $distribution_info_dto->tree));
      }

      // --- sorted element list
      if (is_array($distribution_info_dto->elements) && count($distribution_info_dto->elements) > 0) {
        foreach ($distribution_info_dto->elements as $descriptionElement) {
          if (is_object($descriptionElement->area)) {
            $sortKey = $descriptionElement->area->representation_L10n;
            $distributionElements[$sortKey] = $descriptionElement;
          }
        }
        ksort($distributionElements);
        $distribution_element_render_array = compose_cdm_descriptionElement_Distribution($distributionElements);
        $dto_out_array[] = drupal_render($distribution_element_render_array);

      }
      //
      $block->content[] = compose_cdm_feature_block_elements(
        $dto_out_array,
        $feature,
        $distribution_glue,
        $distribution_sortOutArray,
        $distribution_enclosingTag
      );
    }

    // --- TextData at the bottom
    if ($text_data_out_array && !variable_get(DISTRIBUTION_TEXTDATA_DISPLAY_ON_TOP, 0)) {
      $block->content[] = compose_cdm_feature_block_elements(
        $text_data_out_array,
        $feature,
        $text_data_glue,
        $text_data_sortOutArray,
        $text_data_enclosingTag
      );
    }

    $block->content[] = markup_to_render_array(theme('cdm_footnotes', array('footnoteListKey' => UUID_DISTRIBUTION)));
    $block->content[] = markup_to_render_array(theme('cdm_annotation_footnotes', array('footnoteListKey' => UUID_DISTRIBUTION)));

    return $block;
  }


  /**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_FeatureTree_hierarchy($variables) {

  $FeatureTreeUuid = $variables['FeatureTreeUuid'];
  if (!is_uuid($FeatureTreeUuid)) {
    return;
  }

  $out = '';
  $featureTree = cdm_ws_get(CDM_WS_FEATURETREE, array(
    $FeatureTreeUuid,
  ));

  if (isset($featureTree) && isset($featureTree->root)) {
    $out = '<ul class="' . $featureTree->class . '">';
    $out .= theme('FeatureTree_hierarchy_children', array('node' => $featureTree->root));
    $out .= '</ul>';
  }
  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_FeatureTree_hierarchy_children($variables) {

  $node = $variables['node'];
  $out = '';
  if (isset($node->childNodes)) {

    foreach ($node->childNodes as $childNode) {
      $out .= '<li>' . check_plain($childNode->feature->representation_L10n);
      if (isset($childNode->childNodes) && count($childNode->childNodes) > 0) {
        $out .= '<ul>' . theme('FeatureTree_hierarchy_children', array('node' => $childNode)) . '</ul>';
      }
      $out .= '</li>';
    }
  }
  return $out;
}

/**
 * Returns HTML for the texts in a description $elements.
 *
 * Joins the texts in $elements and encloses with a HTML tag.
 *
 * @param  $elements
 * @param  feature:
 *  The feature to which the elements given in $elements are belonging to.
 * @param  glue:
 *  Defaults to empty string.
 * @param $sort
 *   Boolean Whether to sort the $elements alphabetically, default is FALSE
 * @param  $enclosing_tag
 *
 * @ingroup compose
 */
function compose_cdm_feature_block_elements($elements, $feature, $glue = '', $sort = FALSE, $enclosing_tag = 'ul') {

  $feature_block_settings = get_feature_block_settings($feature->uuid);
  if($feature_block_settings['as_list']){
    $enclosing_tag = $feature_block_settings['as_list'];
  }

  $out = '<' . $enclosing_tag . ' class="feature-block-elements" id="' . $feature->representation_L10n . '">';

  if ($sort) {
    sort($elements);
  }

  //TODO it would be nice if any element would get "feature-block-element" as additional class attribute
  //     this will become possible once all $elemets are real Drupal render arrays
  $out .= join($glue, $elements) ;

  $out .= '</' . $enclosing_tag . '>';
  return markup_to_render_array($out);
}


/**
 * Theme function to render CDM DescriptionElements of the type CategoricalData.
 *
 * @param array $variables
 *   An associative array containing:
 *  - element: the CategoricalData element
 * @return a html representation of the given CategoricalData element
 *
 * @ingroup themeable
 */
function theme_cdm_descriptionElement_CategoricalData($variables) {
  $element = $variables['element'];

  $state_data_strings = array();
  if (isset($element->stateData)) {
    foreach ($element->stateData as $stateData) {

      $state  = NULL;

      if(isset($stateData->state)){
        $state = cdm_term_representation($stateData->state);
      }

      if (isset($stateData->modifyingText_L10n)) {
        $state = ' ' . $stateData->modifyingText_L10n;
      }

      $modifiers_strings = cdm_modifers_representations($stateData);

      $state_data_strings[] = $state . ($modifiers_strings ? ' ' . $modifiers_strings : '');

    }
  }

  $footnote_key_list_str = cdm_create_description_element_footnotes($element);

  $out = '<span class="' . html_class_attribute_ref($element) . '">' . implode(', ', $state_data_strings) . '</span>';
  return $out . $footnote_key_list_str;
}

/**
 * Theme function to render CDM DescriptionElements of the type QuantitativeData.
 *
 * @param array $variables
 *   An associative array containing:
 *  - element: the QuantitativeData element
 * @return a html representation of the given QuantitativeData element
 *
 * @ingroup themeable
 */
function theme_cdm_descriptionElement_QuantitativeData($variables) {
  /*
   * - statisticalValues
   *   - value
   *   - modifiers
   *   - type
   * - unit->representation_L10n
   * - modifyingText
   * - modifiers
   * - sources
   */
  $element = $variables['element'];

  $out = '';

  $type_representation = NULL;
  $modifiers_strings = array();


  if (isset($element->statisticalValues)) {
    $value_array = array();
    foreach ($element->statisticalValues as $val) {
      if (isset($val->value)) {
        $value_array[] = $val->value;
      }
    }

    $out .= implode($value_array, ', ');
  }

  if (isset($element->unit)) {
    $out .= ' '. cdm_term_representation($element->unit);
  }

  if (isset($element->statisticalValues->modifyingText_L10n)) {
    $out .=  ' ' . $element->statisticalValues->modifyingText_L10n;
  }
  $modifiers_strings = cdm_modifers_representations($element->statisticalValues);
  $out .= ($modifiers_strings ? ' ' . cdm_modifers_representations($element->statisticalValues) : '');

  $footnote_key_list_str = cdm_create_description_element_footnotes($element);

  return $out . $footnote_key_list_str;

}

/**
 * Theme function to render CDM DescriptionElements of the type IndividualsAssociations.
 *
 * @param array $variables
 *   An associative array containing:
 *  - element: the IndividualsAssociations element
 * @return html representation of the given IndividualsAssociations element
 *
 * @ingroup themeable
 */
function theme_cdm_descriptionElement_IndividualsAssociation($variables) {

  $element = $variables['element'];

  $out = '';

  $render_array = compose_cdm_specimenOrObservation($element->associatedSpecimenOrObservation);

  if (isset($element->description_L10n)) {
    $out .=  ' ' . $element->description_L10n;
  }

  $out .= drupal_render($render_array);

  $footnote_key_list_str = cdm_create_description_element_footnotes($element);

  return $out . $footnote_key_list_str;


}

/**
 * Theme function to render CDM DescriptionElements of the type TaxonInteraction.
 *
 * @param array $variables
 *   An associative array containing:
 *  - element: the TaxonInteraction element
 * @return html representation of the given TaxonInteraction element
 *
 * @ingroup themeable
 */
function theme_cdm_descriptionElement_TaxonInteraction($variables) {

  $element = $variables['element'];

  $out = '';

  if (isset($element->description_L10n)) {
    $out .=  ' ' . $element->description_L10n;
  }

  if(isset($element->taxon2)){
    $out = theme('cdm_taxonName',
        array(
            'taxonName' => $element->taxon2->name,
            'nameLink' => url(path_to_taxon($element->taxon2->uuid))
        )
      );
  }

  $footnote_key_list_str = cdm_create_description_element_footnotes($element);

  return $out . $footnote_key_list_str;


}

/**
 * Composes a drupal render array for CDM TextData description elements.
 *
 * @param $element
 *    The CDM TextData description element which contains the textual  information.
 * @param $asListElement
 *    A boolean which determines whether the citations should
 *     be rendered as a list or not.
 *    TODO remove and replace $asListElement by $feature_block_settings['as_list']
 *  @param $feature_uuid
 *
 * @return array
 *   A drupal render array with the following elements being used:
 *    - #tag: either 'div', 'li', ...
 *    â» #attributes: class attributes
 *    - #value_prefix: (optionally) contains footnote anchors
 *    - #value: contains the textual content
 *    - #value_suffix: (optionally) contains footnote keys
 *
 * @ingroup compose
 */
function compose_cdm_descriptionElementTextData($element, $asListElement, $feature_uuid) {

  $footnote_list_key_suggestion = $feature_uuid;

  // FIXME $feature_block_settings should be passed as parameter!!!!!
  $feature_block_settings = get_feature_block_settings($feature_uuid);

  // FIXME remove this hack ---------------------------
  $default_theme = variable_get('theme_default', NULL);
  if($default_theme == 'garland_cichorieae' || $default_theme == 'cyprus'
    || $default_theme == 'flore_afrique_centrale' || $default_theme == 'flora_malesiana' || $default_theme == 'flore_gabon' ){
    $asListElement = $feature_block_settings['as_list'] == 'ul';
  }
  // --------------------------------------------------

  $render_array = array(
    '#type' => 'html_tag',
    '#tag' => $asListElement ? 'li' : 'span',
    '#attributes' => array(
      'class' => 'DescriptionElement DescriptionElement-' . $element->class . '
      ' .  html_class_attribute_ref($element)
    ),
    '#value' => '',
    '#value_suffix' => NULL
  );

  $element_text = '';
  if (isset($element->multilanguageText_L10n->text)) {
    // TODO replacement of \n by <br> should be configurable
    $element_text = str_replace("\n", "<br/>", $element->multilanguageText_L10n->text);
  }

  $annotations_and_sources = handle_annotations_and_sources($element, $feature_block_settings, $element_text, $footnote_list_key_suggestion);

  $names_used_in_source_markup = '';
  if (!empty($annotations_and_sources['names_used_in_source']) && empty($element_text)) {
    // $element_text ==  NULL  usually occurs only in the case of CITATIONS!!!
    $names_used_in_source_markup = join(', ', $annotations_and_sources['names_used_in_source']) . ': ';
  }

  $source_references_markup = '';
  if(!empty($annotations_and_sources['source_references'])){
    $source_references_markup = '<span class="sources">'. join(' ', $annotations_and_sources['source_references']) . '<span>';
  }

  $render_array['#value'] = $names_used_in_source_markup . $element_text . $source_references_markup;
  $render_array['#value-suffix'] = $annotations_and_sources['foot_note_keys'];

  return $render_array;
}

  /**
   * @param $element
   * @param $feature_block_settings
   * @param $element_text
   * @param $footnote_list_key_suggestion
   * @return array
   *   an associative array with the following elements:
   *   - foot_note_keys: all footnote keys as markup
   *   - source_references: an array of the source references citations
   *   - names used in source: an associative array of the names in source,
   *        the name in source string are de-duplicated
   *        !!!NOTE!!!!: this field will most probably be removed soon (TODO)
   *
   *
   */
  function handle_annotations_and_sources($element, $feature_block_settings, $element_text, $footnote_list_key_suggestion) {
    $annotations_and_sources = array(
      'foot_note_keys' => NULL,
      'source_references' => array(),
      'names_used_in_source' => array()
    );

    if ($feature_block_settings['sources_as_content']) {
      foreach ($element->sources as $source) {

        $referenceCitation = theme('cdm_OriginalSource',
          array(
            'source' => $source,
            'doLink' => $feature_block_settings['link_to_reference']
          )
        );

        if ($referenceCitation) {
          if (empty($element_text)) {
            $annotations_and_sources['source_references'][] = $referenceCitation;
          }
          else {
            $annotations_and_sources['source_references'][] = ' (' . $referenceCitation . ')';
          }
        }

        $name_in_source_render_array = compose_name_in_source(
          $source,
          $feature_block_settings['link_to_name_used_in_source']
        );

        if(!empty($name_in_source_render_array)){
          $annotations_and_sources['names_used_in_source'][$name_in_source_render_array['#_plaintext']] = drupal_render($name_in_source_render_array);
        }
      } // END of loop over sources

      // annotations footnotes separate.
      $annotations_and_sources['foot_note_keys'] = theme('cdm_annotations_as_footnotekeys',
        array(
          'cdmBase_list' => $element,
          'footnote_list_key' => $footnote_list_key_suggestion,
        )
      );

    } // END of references inline

    if (!$feature_block_settings['sources_as_content'] || $feature_block_settings['sources_as_content_to_bibliography']) {
      $annotations_and_sources['foot_note_keys'] = cdm_create_description_element_footnotes($element, ',', $footnote_list_key_suggestion);
    }

    return $annotations_and_sources;
  }

  /* compose nameInSource or originalNameString as markup
   *
   * @param $source
   * @param $do_link_to_name_used_in_source
   *
   * @return array
   *    A Drupal render array with an additional element, the render array is empty
   *    if the source had no name in source information
   *    - #_plaintext: contains the plaintext version of the name (custom element)
   *
   * @ingroup compose
   */
  function compose_name_in_source($source, $do_link_to_name_used_in_source) {

    $plaintext = NULL;
    $markup = NULL;
    $name_in_source_render_array = array();

    if (isset($source->nameUsedInSource->uuid) && isset($source->nameUsedInSource->titleCache)) {
      // it is a DescriptionElementSource !
      $plaintext = $source->nameUsedInSource->titleCache;
      $markup = theme('cdm_taxonName', array(
        'taxonName' => $source->nameUsedInSource
      ));
      if ($do_link_to_name_used_in_source) {
        $markup = l(
          $markup,
          path_to_name($source->nameUsedInSource->uuid),
          array(
            'attributes' => array(),
            'absolute' => TRUE,
            'html' => TRUE,
          ));
      }
    }
    else if (isset($source->originalNameString) && !empty($source->originalNameString)) {
      // the name used in source can not be expressed as valid taxon name,
      // so the editor has chosen to put the freetext name into ReferencedEntityBase.originalNameString
      // field
      // using the originalNameString as key to avoid duplicate entries
      $plaintext = $source->originalNameString;
      $markup = $source->originalNameString;
    }

    if ($plaintext) {
      $name_in_source_render_array = markup_to_render_array($markup);
      $name_in_source_render_array['#_plaintext'] = $plaintext;
    }

    return $name_in_source_render_array;
  }

  /**
 * Composes block of common names for the given DescriptionElements $elements which must be of the feature CommonName
 *
 * @parameter $elements
 *  an array of CDM DescriptionElements either of type CommonName or TextData
 * @parameter $feature
 *  the common feature of all $elements, must be CommonName
 *
 * @return
 *   A drupal render array
 *
 * @ingroup compose
 */
function compose_cdm_common_names($elements, $feature, $weight = FALSE) {

  $common_name_out = '';
  $common_name_feature_elements = array();
  $textData_commonNames = array();

  $footnote_key_suggestion = 'common-names-feature-block';

  if (is_array($elements)) {
    foreach ($elements as $element) {

      if ($element->class == 'CommonTaxonName') {

        // common name without a language or area, should not happen but is possible
        $language_area_key = '';
        if (isset($element->language->representation_L10n)) {
          $language_area_key .= '<b>' . $element->language->representation_L10n . '</b>';
        }
        if(isset($element->area->titleCache) && strlen($element->area->titleCache) > 0){
          $language_area_key .= ($language_area_key ? ' '  : '') . '(' . $element->area->titleCache . ')';
        }

        if(isset($common_names[$language_area_key][$element->name])) {
          // same name already exists for language and areae combination, se we merge the description elements
          cdm_merge_description_elements($common_names[$language_area_key][$element->name], $element);
        } else{
          // otherwise add as new entry
          $common_names[$language_area_key][$element->name] = $element;
        }

      }
      elseif ($element->class == 'TextData') {
        $textData_commonNames[] = $element;
      }
    }
  }
  // Handling common names.
  if (isset($common_names) && count($common_names) > 0) {
    // Sorting the array based on the key (language, + area if set).
    // Comment @WA there are common names without a language, so this sorting
    // can give strange results.
    ksort($common_names);

    // loop over set of elements per language area
    foreach ($common_names as $language_area_key => $elements) {
      ksort($elements); // sort names alphabetically
      $per_language_area_out = array();
      // loop over set of individual elements
      foreach ($elements as $element) {
        if ($element->name) {
          $per_language_area_out[] = '<span class="' . html_class_attribute_ref($element) . '">'
          . $element->name . cdm_create_description_element_footnotes($element, ',', $footnote_key_suggestion) . '</span>';
        }
      } // End of loop over set of individual elements
      $common_name_feature_elements[] = ($language_area_key ? $language_area_key . ': ' : '' ) . join(', ', $per_language_area_out);
    } // End of loop over set of elements per language area


    $common_name_feature_elements_render_array = compose_cdm_feature_block_elements(
      $common_name_feature_elements,
      $feature,
      '; ',
      FALSE,
      'div'
      );
    $common_name_out .= $common_name_feature_elements_render_array['#markup'];

  }

  // Handling commons names as text data.
  $text_data_out = array();

  foreach ($textData_commonNames as $text_data_element) {
    /* footnotes are not handled correctly in theme_cdm_descriptionElementTextData,
       need to set 'common-names-feature-block' as $footnote_key_suggestion */
    RenderHints::setFootnoteListKey($footnote_key_suggestion);
    $text_data_render_array = compose_cdm_descriptionElementTextData($text_data_element, TRUE, $text_data_element->feature->uuid);
    $text_data_out[] = drupal_render($text_data_render_array);
  }

  $common_name_out_text_data = compose_cdm_feature_block_elements(
        $text_data_out,
        $feature
      );


  $footnotes = theme('cdm_footnotes', array('footnoteListKey' => $footnote_key_suggestion)); // FIXME is this needed at all?
  $footnotes .= theme('cdm_annotation_footnotes', array('footnoteListKey' => $footnote_key_suggestion));

  return  markup_to_render_array(
    '<div class="common_names_as_common_names">' . $common_name_out . '</div>'
    .'<div class="common_names_as_text_data">' . $common_name_out_text_data['#markup'] . '</div>'
    .$footnotes,
    $weight
  );
}

/**
 * Return HTML for a list of description elements.
 *
 * Usually these are of a specific feature type.
 *
 * @param $descriptionElements
 *   array of descriptionElements which belong to the same feature.
 *   These descriptions elements of a Description must be ordered by the chosen feature tree by
 *   calling the function _mergeFeatureTreeDescriptions().
 *   @see _mergeFeatureTreeDescriptions()
 *
 * @param  $feature_uuid
 *
 * @return
 *    A drupal render array for the $descriptionElements, may be an empty array if the textual content was empty.
 *    Footnote key or anchors are not considered to be textual content.
 *
 * @ingroup compose
 */
function compose_cdm_descriptionElements($descriptionElements, $feature) {

  $render_array = array();
  $elements_out_array = array();
  $distribution_tree = null;

  /*
   * $feature_block_has_content will be set true if at least one of the
   * $descriptionElements contains some text which makes up some content
   * for the feature block. Footnote keys are not considered
   * to be content in this sense.
   */
  $feature_block_has_content = false;

  /*
  $userDefined = mixed_variable_get(LAYOUT_SETTING_PREFIX . $feature_uuid, FEATURE_TREE_LAYOUT_DEFAULTS);
  if(variable_get('distribution_sort',
      'NO_SORT') != 'NO_SORT'){
      $glue = '';
      $enclosingTag = 'dl';
      $entryEnclosingTag = NULL;
  } else if($userDefined &&
      $userDefined['enabled']){
    $glue = $userDefined['glue'];
    $enclosingTag =  $userDefined['enclosingTag'];
    $entryEnclosingTag = $userDefined['entryEnclosingTag'];
  } else { // TODO remove once  LAYOUT_SETTING_PREFIX-{uuid} setting are configured to work for all portals(selenium test still missing!!!)
    $glue = ''; $enclosingTag = 'ul';
    $entryEnclosingTag = NULL ;
  }
  */

  RenderHints::pushToRenderStack('cdm_descriptionElements');

  if (is_array($descriptionElements)) {
    // --- normal description element arrays
    foreach ($descriptionElements as $descriptionElement) {

      // --- IMAGE_SOURCES --- //
      if ($descriptionElement->feature->uuid == UUID_IMAGE_SOURCES) {
        $image_sources[] = $descriptionElement;
      }
      // --- USE TEXTDATA --- //
      elseif ($descriptionElement->feature->uuid == UUID_USE) {
        // Do nothing to avoid rendering.
      } else {
        /* decide based on the description element class
         *
         * Features handled here:
         * all except DISTRIBUTION, COMMON_NAME, USES, IMAGES,
         *
         *
         * TODO provide api_hook as extension point for this?
         */
        $feature_block_settings = get_feature_block_settings($descriptionElement->feature->uuid);
        $asListElement  = $feature_block_settings['as_list'] == 'ul';
        switch ($descriptionElement->class) {
          case 'TextData':
              $text_data_render_array = compose_cdm_descriptionElementTextData($descriptionElement, $asListElement, $descriptionElement->feature->uuid);
              $feature_block_has_content = $feature_block_has_content || !empty($text_data_render_array['#value']);
              $elements_out_array[] = drupal_render($text_data_render_array);
            break;
          case 'CategoricalData':
            $feature_block_has_content = true;
            $elements_out_array[] = theme('cdm_descriptionElement_CategoricalData', array('element' => $descriptionElement));
            break;
          case 'QuantitativeData':
            $feature_block_has_content = true;
            $elements_out_array[] = theme('cdm_descriptionElement_QuantitativeData', array('element' => $descriptionElement));
            break;
          case 'IndividualsAssociation':
            $feature_block_has_content = true;
            $elements_out_array[] = theme('cdm_descriptionElement_IndividualsAssociation', array('element' => $descriptionElement));
            break;
          case 'TaxonInteraction':
            $feature_block_has_content = true;
            $elements_out_array[] = theme('cdm_descriptionElement_TaxonInteraction', array('element' => $descriptionElement));
            break;
          case 'Uses':
          /* IGNORE Uses classes, these are handled completely in theme_cdm_UseDescription */
          break;
        default:
          $feature_block_has_content = true;
          $elements_out_array[] = '<li>No method for rendering unknown description class: ' . $descriptionElement->class . '</li>';
      }
    }
    } // --- END loop over normal description element arrays

    // If feature = CITATION sort the list of sources.
    // This is ONLY for FLORA MALESIANA and FLORE d'AFRIQUE CENTRALE.
    if ($descriptionElement->feature->uuid == UUID_CITATION) {
      sort($elements_out_array);
    }

    if (isset($image_sources)) {
      $elements_out_array[] = theme('cdm_description_element_image_source', array('image_sources' => $image_sources, 'asListElement' => TRUE));
    }
  } // END normal description element arrays

  if($feature_block_has_content){
    $render_array = compose_cdm_feature_block_elements(
      $elements_out_array,
      $feature
    );
  }

  RenderHints::popFromRenderStack();
  return $render_array;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function compare_image_sources($a, $b) {
  if ($a->multilanguageText_L10n->text == $b->multilanguageText_L10n->text) {
    return 0;
  }
  return ($a->multilanguageText_L10n->text < $b->multilanguageText_L10n->text) ? -1 : 1;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_description_element_image_source($variables) {
  $image_sources = $variables['image_sources'];
  $asListElement = $variables['asListElement'];
  $out = '';
  $separator = ',';
  RenderHints::pushToRenderStack('descriptionElementImageSource');
  RenderHints::setFootnoteListKey(UUID_IMAGE_SOURCES);

  // Sorting the image sources.
  usort($image_sources, "compare_image_sources");
  // Generate the footnotes.
  foreach ($image_sources as $image_source) {
    $footNoteKeys = cdm_annotations_as_footnotekeys($image_source);
    foreach ($image_source->sources as $source) {
      if (_is_original_source_type($source)) {
        $fn_key = FootnoteManager::addNewFootnote(original_source_footnote_list_key(), theme('cdm_OriginalSource', array(
          'source' => $source,
          'doLink' => FALSE,
        )));
        // Ensure uniqueness of the footnote keys.
        cdm_add_footnote_to_array($footNoteKeys, $fn_key);
      }
    }
    // Sort and render footnote keys.
    $footnote_key_list_str = '';
    asort($footNoteKeys);
    foreach ($footNoteKeys as $footNoteKey) {
      $footnote_key_list_str .= theme('cdm_footnote_key', array('footnoteKey' => $footNoteKey, 'separator' => ($footnote_key_list_str ? $separator : '')));
    }
    // Return value!
    $out .= '<span class="descriptionElement descriptionElement-' . $image_source->uuid . '">' . $image_source->multilanguageText_L10n->text . $footnote_key_list_str . '; </span>';
  }

  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * Composes the render array for a CDM Distribution element
 *
 * @param $descriptionElements
 *   The CDM Distribution element
 * @param $enclosingTag
 *   The html tag to be use for the enclosing element
 *
 * @return array
 *   A Drupal render array
 *
 * @ingroup compose
 */
function compose_cdm_descriptionElement_Distribution($descriptionElements, $enclosingTag = "span"){

  $out = '';
  RenderHints::pushToRenderStack('descriptionElementDistribution');
  RenderHints::setFootnoteListKey(UUID_DISTRIBUTION);

  $feature_block_settings = get_feature_block_settings(UUID_DISTRIBUTION);

  foreach ($descriptionElements as $descriptionElement) {
    $annotations_and_sources = handle_annotations_and_sources(
      $descriptionElement,
      $feature_block_settings,
      $descriptionElement->area->representation_L10n,
      UUID_DISTRIBUTION
    );



    $out .= '<' . $enclosingTag . ' class="descriptionElement descriptionElement-' . $descriptionElement->uuid . '">'
        . $descriptionElement->area->representation_L10n;
    if(!empty($annotations_and_sources['source_references'])){
      $out .= ' ' . join(' ', $annotations_and_sources['source_references'] );
    }
    $out .= $annotations_and_sources['foot_note_keys']   . ' </' . $enclosingTag . '>';
  }

  RenderHints::popFromRenderStack();
  return markup_to_render_array($out);
}


/**
 * Compare two different footnotes objects.
 *
 * The comparison is based on the footnote key. The one which is
 * displayed as footnote number.
 *
 * @param mixed $a
 *   Footnote object $a.
 * @param mixed $b
 *   Footnote object $b.
 */
function footnotes_key_compare($a, $b) {
  $res = 0;
  if (empty($a) || empty($b)) {
    return $res;
  }
  if ($a->keyStr < $b->keyStr) {
    $res = -1;
  }
  elseif ($a->keyStr > $b->keyStr) {
    $res = 1;
  }
  return $res;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_description_ordered_distributions($variables) {

  $distribution_tree = $variables['distribution_tree'];

  // Returning NULL if there are no description elements.
  if ($distribution_tree == null) {
    return NULL;
  }

  // Initialization of some variables.
  $out = '';
  $separator = ',';
  RenderHints::pushToRenderStack('descriptionElementDistribution');
  RenderHints::setFootnoteListKey(UUID_DISTRIBUTION);

  $ordered_areas = $distribution_tree;
  if (isset($ordered_areas->rootElement->children)) {
    $ordered_areas = $ordered_areas->rootElement->children;
  }

  // Printing the distributions.
  if (is_array($ordered_areas) && count($ordered_areas) > 0) {
    foreach ($ordered_areas as $element_level1) {
      // Level1.
      $out .= '<dt>' . $element_level1->nodeId->representation_L10n . ':</dt> ';
      $out .= '<dd>';

      // Level3.
      foreach ($element_level1->children as $element_level3) {
        $text_l3 = $element_level3->nodeId->representation_L10n;
        $fnKeysLevel3Str = '';
        $fnKeysLevel3 = cdm_annotations_as_footnotekeys($element_level3->data);
        if (isset($element_level3->data[0])) {
          foreach ($element_level3->data as $description_level3){
            foreach ($description_level3->sources as $source) {
              if (_is_original_source_type($source)) {
                $fn_key3 = FootnoteManager::addNewFootnote(
                  original_source_footnote_list_key(),
                  theme('cdm_OriginalSource', array('source' => $source, 'doLink' => FALSE)
                ));
                cdm_add_footnote_to_array($fnKeysLevel3, $fn_key3);
              }
            }
          }
        }
        // Level4.
        $l4_regions = array();
        foreach ($element_level3->children as $element_level4) {
          if (isset($element_level4->data[0])) {
            $text_l4 = $element_level4->nodeId->representation_L10n;
            $l4_regions[$element_level3->nodeId->representation_L10n] = array();
            $fnKeysLevel4Str = '';
            foreach($element_level4->data as $description_level4) {
              $fnKeysLevel4 = cdm_annotations_as_footnotekeys($description_level4);
              foreach ($description_level4->sources as $source) {
                if (_is_original_source_type($source)) {
                  $fn_key4 = FootnoteManager::addNewFootnote(
                      original_source_footnote_list_key(),
                      theme('cdm_OriginalSource', array('source' => $source, 'doLink' => FALSE)));
                  cdm_add_footnote_to_array($fnKeysLevel4, $fn_key4);
                }
              }
              usort($fnKeysLevel4, "footnotes_key_compare");
              if(!isset( $l4_regions[$text_l4])){
                $l4_regions[$text_l4] = $fnKeysLevel4;
              } else {
                $l4_regions[$text_l4] = array_merge($l4_regions[$text_l4], $fnKeysLevel4);
              }
            }
          }
        }// Level4.
        // Managing level3 and level4 for generating the right output.
        usort($fnKeysLevel3, "footnotes_key_compare");
        foreach ($fnKeysLevel3 as $key3) {
          foreach ($l4_regions as $key4 => $value4) {
            cdm_add_footnote_to_array($l4_regions[$key4], $key3);
          }
        }
        if ($element_level3->numberOfChildren == 1 && $text_l3 == $element_level3->children[0]->nodeId->representation_L10n) {
          // var_dump($element_level3->children[0]->data->area->representation_L10n);
          $fnStr = '';
          $region = array_pop($l4_regions);
          foreach ($region as $key) {
            $fnStr .= theme('cdm_footnote_key', array('footnoteKey' => $key, 'separator' => ($fnStr ? $separator : '')));
          }
          $out .= "$text_l3 $fnStr; ";
          // Removing whitespaces when &fnStr is empty.
          if (substr($out, -3) == ' ; ') {
            $out = substr($out, 0, -3) . '; ';
          }
        } else {
          $fnKeysLevel3Str = '';
          foreach ($fnKeysLevel3 as $key) {
            $fnKeysLevel3Str .= theme('cdm_footnote_key', array('footnoteKey' => $key, 'separator' => ($fnKeysLevel3Str ? $separator : '')));
          }
          $text_l4_aux = '';
          foreach ($l4_regions as $key => $value) {
            $fnKeysLevel4Str = '';
            if (is_array($l4_regions[$key])) {
              foreach ($l4_regions[$key] as $fnkey) {
                $fnKeysLevel4Str .= theme('cdm_footnote_key', array('footnoteKey' => $fnkey, 'separator' => ($fnKeysLevel4Str ? $separator : '')));
              }
            }
            // if ($key != $text_l3 || sizeof($l4_regions > 1)){
            if ($key != $text_l3) {
              $text_l4_aux .= "$key $fnKeysLevel4Str, ";
            }
          }
          $text_l4_aux = substr($text_l4_aux, 0, -2);

          if (strlen($text_l4_aux) > 0) {
            $out .= "$text_l3 $fnKeysLevel3Str ($text_l4_aux); ";
          }
          else {
            $out .= "$text_l3 $fnKeysLevel3Str; ";
          }
        }
      }// Level3.
      $out = substr($out, 0, -2);
      $out .= '.</dd>';
    }// Level1.
  }
  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * Returns a list of a specific type of IdentificationKeys.
 *
 * The list can be restricteded by a taxon.
 *
 * @param string $type
 *   The simple name of the cdm class implementing the interface
 *   IdentificationKey, valid values are:
 *   PolytomousKey, MediaKey, MultiAccessKey.
 * @param string $taxonUuid
 *   If given this parameter restrict the listed keys to those which have
 *   the taxon identified be this uuid in scope.
 *
 * @return array
 *   List with identification keys.
 */
function _list_IdentificationKeys($type, $taxonUuid = NULL, $pageSize = NULL, $pageNumber = NULL) {
  if (!$type) {
    drupal_set_message(t('Type parameter is missing'), 'error');
    return;
  }
  $cdm_ws_pasepath = NULL;
  switch ($type) {
    case "PolytomousKey":
      $cdm_ws_pasepath = CDM_WS_POLYTOMOUSKEY;
      break;

    case "MediaKey":
      $cdm_ws_pasepath = CDM_WS_MEDIAKEY;
      break;

    case "MultiAccessKey":
      $cdm_ws_pasepath = CDM_WS_MULTIACCESSKEY;
      break;

  }

  if (!$cdm_ws_pasepath) {
    drupal_set_message(t('Type parameter is not valid: ') . $type, 'error');
  }

  $queryParameters = '';
  if (is_numeric($pageSize)) {
    $queryParameters = "pageSize=" . $pageSize;
  }
  else {
    $queryParameters = "pageSize=0";
  }

  if (is_numeric($pageNumber)) {
    $queryParameters = "pageNumber=" . $pageNumber;
  }
  else {
    $queryParameters = "pageNumber=0";
  }
  $queryParameters = NULL;
  if ($taxonUuid) {
    $queryParameters = "findByTaxonomicScope=$taxonUuid";
  }
  $pager = cdm_ws_get($cdm_ws_pasepath, NULL, $queryParameters);

  if (!$pager || $pager->count == 0) {
    return array();
  }
  return $pager->records;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_IdentificationKey($variables) {
  $out = '';
  $identificationKey = $variables['identificationKey'];
  $doLinkToKeyPage = $variables['doLinkToKeyPage'];
  $showIdentificationKeyTitle = $variables['showIdentificationKeyTitle'];
  $parentRenderPath = RenderHints::getRenderPath();
  RenderHints::pushToRenderStack("IdentificationKey");

  if ($showIdentificationKeyTitle) {
    if ($doLinkToKeyPage) {
      $out = l($identificationKey->titleCache, path_to_key($identificationKey->class, $identificationKey->uuid));
    }
    else {
      $out = $identificationKey->titleCache;
    }
  }
  if (isset($identificationKey->sources) && is_array($identificationKey->sources)) {
    // order and display sources.
    $sources = oder_sources($identificationKey->sources, TRUE);
    $out .= '<div class="sources">';
    $out .=  implode('', $sources);
    $out .= '</div>';
  }
  // Display annotations.
  $out .= theme('cdm_annotations', array('annotations' => cdm_ws_getAnnotationsFor($identificationKey), 'enclosingTag' => 'div'));
  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_polytomousKey($variables) {
  $polytomousKey = $variables['polytomousKey'];

  // TODO settings needed.
  // @see http://en.wikipedia.org/wiki/Single_access_key#Presentation_styles
  // @see http://dev.e-taxonomy.eu/trac/ticket/2152
  $keyStyle = "linkedStyle";

  RenderHints::pushToRenderStack("polytomousKey");
  // Key nodes in linked style.
  $out = '<table class="polytomousKey polytomousKey_' . $keyStyle . '">';
  $out .= theme('cdm_polytomousKey_' . $keyStyle . '_subgraph', array('polytomousKeyNode' => $polytomousKey->root));
  $out .= '</table>';
  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_polytomousKey_linkedStyle_subgraph($variables) {
  $polytomousKeyNode = $variables['polytomousKeyNode'];
  static $statementCountCharacter = '\'';
  $out = "";

  if (is_array($polytomousKeyNode->children)) {
    $childIndex = 0;

    // Render edges of the current node.
    foreach ($polytomousKeyNode->children as &$child) {

      if (!isset($child->statement) && isset($child->taxon->uuid)) {
        // Skip node with empty statements (see below for explanation: "Special
        // case").
        // this skipping here happens always in the next deeper level of iteration
        // the check below is node on the level above
        continue;
      }

      /*
       * Special case: Child nodes with empty statements but taxa as leaf are to
       * treated as if all those taxa where direct children of the source node.
       */
      $islinkToManyTaxa = !isset($child->children[0]->statement) && isset($child->children[0]->taxon->uuid);
      $islinkToTaxon = isset($child->taxon->uuid);
      $islinkToSubKey = isset($child->subkey->uuid);
      $islinkToOtherNode = isset($child->otherNode);
      // Either NULL or 0.
      $islinkToNode = $child->nodeNumber && !$islinkToManyTaxa && !$islinkToOtherNode;
      $hasQuestion = !empty($polytomousKeyNode->question->label_l10n);
      $hasFeature = isset($polytomousKeyNode->feature);

      // $indentEdge = $hasQuestion && $childIndex > 0;
      // Question.
      if ($hasQuestion && $childIndex == 0) {
        // Place question, as extra table row.
        $out .= '<tr class="question new_section">';
        $out .= '<td class="nodeNumber">' . uuid_anchor($polytomousKeyNode->uuid, $polytomousKeyNode->nodeNumber) . "</td>";
        $out .= '<td class="question">' . $polytomousKeyNode->question->label_l10n . '</td>';
        $out .= '</tr>';
      }

      $out .= '<tr class="childCount_' . $childIndex . (!$hasQuestion && $childIndex == 0 ? ' new_section' : '') . '">';

      if ($hasQuestion) {
        $out .= '<td class="nodeNumber"></td>';
      }
      else {
        $out .= '<td class="nodeNumber">' . uuid_anchor($polytomousKeyNode->uuid, $polytomousKeyNode->nodeNumber . str_pad("", $childIndex, $statementCountCharacter)) . "</td>";
      }

      $out .= '<td ' . RenderHints::getHtmlElementID($child) . '  class="edge' . ($hasQuestion ? ' edge-indent' : '') . '">';

      // Feature.
      if ($hasFeature) {
        $out .= $polytomousKeyNode->feature->representation_L10n . ": ";
      }

      // Statement.
      $out .= $child->statement->label_l10n;

      // --- Links to nodes taxa and subkeys.
      $out .= '<div class="nodeLink">';

      // Link to a PolytomousKeyNode.
      if ($islinkToNode) {
        $out .= '<div class="nodeLinkToNode">';
        if (isset($child->modifyingText)) {
          $out .= theme('cdm_poytomousKeyNode_modifyingText', array('modifyingText' => $child->modifyingText));
        }
        $out .= l($child->nodeNumber, request_path(), array(
          'attributes' => NULL,
          'query' => NULL,
          'fragment' => $child->uuid,
        )) . '</div>';
      }

      // Link to a PolytomousKeyNode.
      if ($islinkToOtherNode) {
        $out .= '<div class="nodeLinkToOtherNode">';
        if (isset($child->modifyingText)) {
          $out .= theme('cdm_poytomousKeyNode_modifyingText', array('modifyingText' => $child->modifyingText));
        }
        $out .= l($child->otherNode->nodeNumber, $_REQUEST["q"], array(
          'attributes' => NULL,
          'query' => NULL,
          'fragment' => $child->otherNode->uuid,
        )) . '</div>';
      }

      // Link to one or many taxa.
      if ($islinkToTaxon || $islinkToManyTaxa) {

        if ($islinkToManyTaxa) {
          $taxonChildren = $child->children;
        }
        else {
          $taxonChildren = array(
            $child,
          );
        }

        foreach ($taxonChildren as $taxonChild) {
          // TODO many taxa $child->children->taxon.
          $out .= '<div class="nodeLinkToTaxon">';
          if (isset($taxonChild->modifyingText)) {
            $out .= theme('cdm_poytomousKeyNode_modifyingText', array('modifyingText' => $taxonChild->modifyingText));
          }
          $out .= theme("cdm_taxonName", array('taxonName' => $taxonChild->taxon->name, 'nameLink' => url(path_to_taxon($taxonChild->taxon->uuid))));
          $out .= '</div>';
        }

        // Link to a subkey.
        if ($islinkToSubKey) {
          $out .= '<div class="nodeLinkToSubkey">' . theme('cdm_IdentificationKey', array('identificationKey' => $child->subkey)) . '</div>';
        }
      }

      $out .= '</div>'; // End node link.
      $out .= '</td>'; // End edge.
      $out .= '</tr>';

      $childIndex++;
    }

    // Recurse into child nodes.
    foreach ($polytomousKeyNode->children as &$child) {
      $out .= theme('cdm_polytomousKey_linkedStyle_subgraph', array('polytomousKeyNode' => $child));
    }
  }

  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_poytomousKeyNode_modifyingText($variables) {
  $out = '';
  $modifyingText = $variables['modifyingText'];
  if (is_object($modifyingText)) {
    $i = 0;
    foreach (get_object_vars($modifyingText) as $lang => $languageString) {
      $out .= ($i++ > 0 ? ', ' : '') . '<span class="modifyingText">' . $languageString->text . '</span> ';
    }
  }
  return $out;
}

/**
 * Returns HTML for a list of a specific type of IdentificationKeys.
 *
 * The list can be restricteded by a taxon.
 *
 * @param array $variables
 *   An associative array containing:
 *   - type: The simple name of the cdm class implementing the interface
 *     IdentificationKey, valid values are:
 *     PolytomousKey, MediaKey, MultiAccessKey
 *   - taxonUuid: If given, this parameter restrict the listed keys to those
 *     which have the taxon identified be this uuid in scope.
 *
 * @ingroup themeable
 */
function theme_cdm_list_IdentificationKeys($variables) {
  $type = $variables['type'];
  $taxonUuid = $variables['taxonUuid'];
  $keyList = _list_IdentificationKeys($type, $taxonUuid);
  if (!$keyList || count($keyList) == 0) {
    return;
  }

  RenderHints::pushToRenderStack('list_IdentificationKeys');
  $out = '<ul>';
  foreach ($keyList as $key) {
    $out .= '<li>';
    $out .= theme('cdm_IdentificationKey', array('identificationKey' => $key));
    $out .= '</li>';
  }
  $out .= '</ul>';
  $out .= theme("cdm_annotation_footnotes", array('footnoteListKey' => RenderHints::getRenderPath()));
  RenderHints::popFromRenderStack();

  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_block_IdentificationKeys($variables) {
  $taxonUuid = $variables['taxonUuid'];
  static $types = array(
    "PolytomousKey" => "Polytomous",
    "MediaKey" => "Media",
    "MultiAccessKey" => "Multiaccess",
  );
  RenderHints::pushToRenderStack('block_IdentificationKeys');
  $out = '';
  foreach ($types as $type => $label) {
    $keylist = theme('cdm_list_IdentificationKeys', array('type' => $type, 'taxonUuid' => $taxonUuid));
    if (!$keylist) {
      continue;
    }
    $out .= '<div class="' . $type . '">';
    $out .= '<h3>' . t($label) . "</h3>";
    $out .= $keylist;
    $out .= '</div>';
  }
  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * This theming function formats the use description and use record list for
 * these descriptions.
 *
 * @see http://drupal.org/node/1354
 */
function theme_cdm_UseDescription($variables) {
  $descriptions = $variables['description'];
  $taxonUuid = $variables['taxonUuid'];
  $out = '<div id="content"><ul id="Description" class ="description">';
  if ($descriptions == NULL) {
    return;
  }
  $descriptionSynonyms = '';
  $descriptionOut = '';
  $synonymOut = '';
  $currentTaxon = cdm_ws_get(CDM_WS_PORTAL_TAXON, $taxonUuid);

  foreach ($descriptions as $description) {
    $useSummary = '';
    foreach ($description->elements as $element) {

      if ($element->feature->uuid == UUID_USE && !(strlen($useSummary) > 0) && isset($element->multilanguageText_L10n)) {
        $useSummary = $element->multilanguageText_L10n->text;
      }
    }
    // uses will be ordered by source
    foreach ($description->sources as $source) {
      $is_about_current_taxon = FALSE;
      $originalTaxonUsedInSource = NULL;
      $originalTaxonPager = NULL;
      if ($source->originalNameString) {
        $request_params = array();
        $request_params['query'] = $source->originalNameString;
        $request_params['matchMode'] = "EXACT";
        $originalTaxonPager = cdm_ws_get(CDM_WS_PORTAL_NAME_FINDBYNAME, NULL, queryString($request_params));
        if ($originalTaxonPager->count > 0) {
          $originalTaxonUsedInSource = $originalTaxonPager->records[0];
        }
        else {
          $originalTaxonUsedInSource = $currentTaxon->name;
        }
      }
      else {
        $originalTaxonUsedInSource = $currentTaxon->name;
      }

      $is_about_current_taxon = $currentTaxon->name->uuid == $originalTaxonUsedInSource->uuid;

      if (!$is_about_current_taxon) {
        $descriptionOut .= '<li class="descriptionText DescriptionElement">';
        $name_used_in_source_link_to_show_use = l($source->originalNameString, path_to_name($originalTaxonUsedInSource->uuid), array(
          'absolute' => TRUE,
          'html' => TRUE,
        ));
        $descriptionOut .= $name_used_in_source_link_to_show_use . ': ';
        $descriptionOut .= $useSummary;
        foreach ($description->sources as $source) {
          $descriptionOut .= " (" . theme('cdm_OriginalSource', array('source' => $source, 'doLink' => TRUE)) . ")";
        }
        $hasUseRecords = FALSE;
        $descriptionUseRecordOut = '<div id=useRecords><table><th>Use Category</th><th>Use Sub Category</th><th>Plant Part</th><th>Human Group</th><th>Ethnic Group</th><th>Country</th>';
        foreach ($description->elements as $descriptionElement) {
          if ($descriptionElement->feature->uuid == UUID_USE_RECORD) {
            $hasUseRecords = TRUE;
            // FIXME localization hardcoded to English
            $useRecordTags = explode(';', $descriptionElement->modifyingText_l10n);
            $descriptionUseRecordOut .= '<tr>';
            $descriptionUseRecordOut .= '<td>' . $useRecordTags[0] . '</td>' . '<td>' . $useRecordTags[1] . '</td>' . '<td>' . $useRecordTags[3] . '</td>' . '<td>' . $useRecordTags[4] . '</td>' . '<td>' . $useRecordTags[5] . '</td>' . '<td>' . $useRecordTags[2] . '</td>';
            $descriptionUseRecordOut .= '</tr>';
          }
        }
        $descriptionUseRecordOut .= '</table></div>';
        if ($hasUseRecords) {
          $descriptionOut .= $descriptionUseRecordOut . '</li>';
        }
      }
      else {
        // TODO +/- duplicate of above, unify this code
        $synonymOut .= '<li class="descriptionText DescriptionElement">';
        $name_used_in_source_link_to_show_use = l($source->originalNameString, path_to_name($originalTaxonUsedInSource->uuid), array(
          'absolute' => TRUE,
          'html' => TRUE,
        ));

        $synonymOut .= $name_used_in_source_link_to_show_use . ': ';
        $synonymOut .= $useSummary;
        foreach ($description->sources as $source) {
          $synonymOut .= " (" . theme('cdm_OriginalSource', array('source' => $source, 'doLink' => TRUE)) . ")";
        }

        $hasUseRecords = FALSE;
        $useRecordTableOut = '<div id=useRecords><table><th>Use Category</th><th>Use Sub Category</th><th>Plant Part</th><th>Human Group</th><th>Ethnic Group</th><th>Country</th>';
        foreach ($description->elements as $descriptionElement) {
          if ($descriptionElement->feature->uuid == UUID_USE_RECORD) {
            $hasUseRecords = TRUE;
            $useRecordTags = explode(';', $descriptionElement->modifyingText_l10n);
            $useRecordTableOut .= '<tr>';
            $useRecordTableOut .= '<td>' . $useRecordTags[0] . '</td>' . '<td>' . $useRecordTags[1] . '</td>' . '<td>' . $useRecordTags[3] . '</td>' . '<td>' . $useRecordTags[4] . '</td>' . '<td>' . $useRecordTags[5] . '</td>' . '<td>' . $useRecordTags[2] . '</td>';
            $useRecordTableOut .= '</tr>';
          }
        }
        $useRecordTableOut .= '</table></div>';
        if ($hasUseRecords) {
          $synonymOut .= $useRecordTableOut . '</li>';
        }
      }

      // }
    }
  }
  $out .= $descriptionOut . $synonymOut;
  $out .= "</ul></div>";
  return $out;
}


/**
 * The theming function for a block of Uses Descriptions for a given taxon.
 *
 * The Uses block has been removed from the code but the according theme function
 * is kept for compatibility reasons with existing code regarding palmweb.
 *
 */
function theme_cdm_block_Uses($variables) {
  $taxonUuid = $variables['taxonUuid'];
  RenderHints::pushToRenderStack('block_Uses');

  if ($taxonUuid == NULL) {
    return;
  }
  $out = '';
  $markerTypes = array();
  $markerTypes['markerTypes'] = UUID_MARKERTYPE_USE;
  $useDescriptions = cdm_ws_get(CDM_WS_PORTAL_TAXON_DESCRIPTIONS, $taxonUuid, queryString($markerTypes));
  if (!empty($useDescriptions)) {
    // FIXME use theme_block instaed of hardcoding the block html here !!!!
    $out .= '<div id="block-cdm_dataportal-feature-description" class="clear-block block block-cdm_dataportal-feature"><H2><a name="userecords"> </a> Uses </H2>';
    $formatUseDescriptions = theme('cdm_UseDescription', array('description' => $useDescriptions, 'taxonUuid' => $taxonUuid));

    $out .= $formatUseDescriptions;
    $out .= "</div>";
  }

  return $out;
}
