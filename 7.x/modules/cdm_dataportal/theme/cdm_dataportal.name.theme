<?php
/**
 * @file
 * Name theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */

/**
 * Return HTML for the lectotype citation with the correct layout.
 *
 * This function prints the lectotype citation with the correct layout.
 * Lectotypes are renderized in the synonymy tab of a taxon if they exist.
 *
 * @param mixed $typeDesignation
 *   Object containing the lectotype citation to print.
 *
 * @return string
 *   Valid html string.
 */
function type_designation_citation_layout($typeDesignation, $footnote_separator = ',') {
  $res = '';
  $citation = $typeDesignation->citation;
  $pages = $typeDesignation->citationMicroReference;
  if(isset($typeDesignation->typeStatus->uuid) && isset($typeDesignation->typeStatus->representation_L10n)) {
    if ( $typeDesignation->typeStatus->uuid == UUID_NTD_ORIGINAL_DESIGNATION || $typeDesignation->typeStatus->uuid == UUID_NTD_MONOTYPY) {
      $res = ' (' . $typeDesignation->typeStatus->representation_L10n . ')';
      return $res;
    }
  }

  if ($citation) {
    // $type = $typeDesignation_citation->type;
    $year = isset($citation->datePublished->start) ? substr($citation->datePublished->start, 0, 4) : '';
    $author = isset($citation->authorship->titleCache) ? $citation->authorship->titleCache : '';
    $res .= ' (designated by ';
    $res .= $author;
    $res .= ($year ? ' ' . $year : '');
    $res .= ($pages ? ': ' . $pages : '');
    // $res .= ')';

    // footnotes should be rendered in the parent element so we
    // are relying on the FootnoteListKey set there
    $fkey_typeDesignation = FootnoteManager::addNewFootnote(RenderHints::getFootnoteListKey(), $typeDesignation->citation->titleCache);
    $res .= theme('cdm_footnote_key', array(
      'footnoteKey' => $fkey_typeDesignation,
      'separator' => $footnote_separator,
      'highlightable' => TRUE,
      'separator_off' => TRUE,
    )) . ')';
  }
  return $res;
}

/**
 * Searches the $collection for the cdm entitiy given as $element.
 *
 * The elements are compared by their UUID.
 *
 * @param $element
 *  the CDM entitiy to search for
 * @param $collection
 *  the list of CDM entities to search in
 *
 * @return boolean TRUE if the $collection contains the $element, otheriwse FALSE
 *
 * TODO move into module file
 */
function contains_cdm_entitiy($element, $collection) {
  $result = FALSE;
  foreach ($collection as $a) {
    if ($a->uuid == $element->uuid) {
      $result = TRUE;
    }
  }
  return $result;
}

/**
 * Fiters the array $entity_list of CDM entities by the list
 * of $excludes. Any element contained in the $excludes will be removed
 * from included int the retuned list.
 *
 * If the $entity_list is not an array the $excludes will be returned.
 */
function filter_cdm_entity_list($entity_list, $excludes) {
  if (is_array($entity_list)) {
    $result = $entity_list;
    if ($excludes) {
      foreach ($excludes as $exclude) {
        if (!contains_cdm_entitiy($exclude, $entity_list)) {
          $result[] = $exclude;
        }
      }
    }
  }
  else {
    $result = $excludes;
  }
  return $result;
}

/**
 * Renders and array of CDM TypeDesignations
 *
 * @param array $variables
 *   - typeDesignations: an array of cdm TypeDesignation entities to render
 */
function theme_cdm_typedesignations($variables) {
  $typeDesignations = $variables['typeDesignations'];

  // need to add element to render path since type designations
  // need other name render template
  RenderHints::pushToRenderStack('typedesignations');

  $out = '<ul class="typeDesignations">';
  $typeDesignation_footnotes = FALSE;
  $is_lectotype = FALSE;
  $specimenTypeDesignations = array();
  $separator = ',';
  foreach ($typeDesignations as $typeDesignation) {
    if ($typeDesignation->class == 'SpecimenTypeDesignation') {
      // SpecimenTypeDesignations should be ordered. Collect theme here only.
      $specimenTypeDesignations[] = $typeDesignation;
    }
    // It is a lectotype?
    else {
      if (isset($typeDesignation->typeStatus->uuid) && $typeDesignation->typeStatus->uuid == UUID_NTD_LECTOTYPE) {
        $is_lectotype = TRUE;
      }
      // It's a NameTypeDesignation.
      if ($typeDesignation->notDesignated) {
        $out .= '<li class="nameTypeDesignation"><span class="status">' . ($is_lectotype ? 'Lectotype' : 'Type') . '</span>: ' . t('not designated') . '</li>';
      }
      elseif ($typeDesignation->typeName) {
        $link_to_name_page = url(path_to_name($typeDesignation->typeName->uuid));
        $out .= '<li class="nameTypeDesignation"><span class="status">' . ($is_lectotype ? 'Lectotype' : 'Type') . '</span>';

        if ($typeDesignation->citation) {
          $out .= type_designation_citation_layout($typeDesignation, $separator);

        }
        $referenceUri = '';
        if (isset($typeDesignation->typeName->nomenclaturalReference)) {
          $referenceUri = url(path_to_reference($typeDesignation->typeName->nomenclaturalReference->uuid));
        }
        $out .= ': ' . render_taxon_or_name($typeDesignation->typeName, $link_to_name_page, $referenceUri, TRUE, TRUE);
      }
    }
  }

  if (!empty($specimenTypeDesignations)) {
    // Sorting might be different for dataportals so this has to be
    // parameterized.
    usort($specimenTypeDesignations, "compare_specimenTypeDesignationStatus");
    foreach ($specimenTypeDesignations as $std) {
      $typeReference = '';
      if (!empty($std->citation)) {
        $author_team = cdm_ws_get(CDM_WS_REFERENCE_AUTHORTEAM, $std->citation->uuid);
        $shortCitation = $author_team->titleCache;

        $shortCitation .= (strlen($shortCitation) > 0 ? ' ' : '') . partialToYear($std->citation->datePublished->start);
        $missingShortCitation = FALSE;
        if (strlen($shortCitation) == 0) {
          $shortCitation = theme('cdm_reference', array('reference' => $std->citation));
          $missingShortCitation = TRUE;
        }

        $typeReference .= '&nbsp;(' . t('designated by');
        $typeReference .= '&nbsp;<span class="typeReference ' . ($missingShortCitation ? '' : 'cluetip') . ' no-print" title="' . htmlspecialchars('|' . theme('cdm_reference', array('reference' => $std->citation)) . '|') . '">';
        $typeReference .= $shortCitation . '</span>';
        if (!empty($std->citationMicroReference)) {
          $typeReference .= ':' . $std->citationMicroReference;
        }
        $typeReference .= ')';

        // footnotes should be rendered in the parent element so we
        // are relying on the FootnoteListKey set there
        $_fkey2 = FootnoteManager::addNewFootnote(RenderHints::getFootnoteListKey(), $std->citation->titleCache);
        $typeReference .= theme('cdm_footnote_key', array(
          'footnoteKey' => $_fkey2,
          'separator' => $separator,
          'highlightable' => TRUE,
          'separator_off' => TRUE,
         ));
      }

      $derivedUnitFacadeInstance = null;

      $out .= '<li class="specimenTypeDesignation">';
      $out .= '<span class="status">'
        . ((isset($std->typeStatus->representation_L10n)) ? $std->typeStatus->representation_L10n : t('Type'))
        . $typeReference
        . '</span>: ';


      if (isset($std->typeSpecimen)) {
        $derivedUnitFacadeInstance = cdm_ws_get(CDM_WS_DERIVEDUNIT_FACADE, $std->typeSpecimen->uuid);
      }
      if ( isset($derivedUnitFacadeInstance ) ){
        $out .= $derivedUnitFacadeInstance->titleCache; // . ': ' . theme('cdm_specimen', array('specimenTypeDesignation' => $derivedUnitFacadeInstance));
      }

      // Footnotes for collection acronyms.
      // footnotes should be rendered in the parent element so we
      // are relying on the FootnoteListKey set there
      $_fkey = FootnoteManager::addNewFootnote(
          RenderHints::getFootnoteListKey(),
          (isset($derivedUnitFacadeInstance->collection->titleCache) ? $derivedUnitFacadeInstance->collection->titleCache : FALSE)
        );
      $out .= theme('cdm_footnote_key', array('footnoteKey' => $_fkey, 'separator' => $separator));
      $out .= '</li>';

    }
  }

  $out .= '</ul>';

  RenderHints::popFromRenderStack();

  return $out;
}

/**
 * FIXME this definitively has to be in another spot.
 * just didn't know where to put it right now.
 * Compares the status of two SpecimenTypeDesignations
 *
 * @param string $a
 *   A SpecimenTypeDesignations.
 * @param string $b
 *   SpecimenTypeDesignations.
 */
function compare_specimenTypeDesignationStatus($a, $b) {
  /*
  This is the desired sort order as of now: Holotype Isotype Lectotype
  Isolectotype Syntype.
  TODO Basically, what we are trying to do is, we define
  an ordered array of TypeDesignation-states and use the index of this array
  for comparison. This array has to be filled with the cdm- TypeDesignation
  states and the order should be parameterisable inside the dataportal.
  */
  // Make that static for now.
  $typeOrder = array(
    'Holotype',
    'Isotype',
    'Lectotype',
    'Isolectotype',
    'Syntype',
  );

  $aQuantifier = FALSE;
  $bQuantifier = FALSE;
  if (isset($a->typeStatus->label) && isset($b->typeStatus->label)) {
    $aQuantifier = array_search($a->typeStatus->label, $typeOrder);
    $bQuantifier = array_search($b->typeStatus->label, $typeOrder);
  }
  if ($aQuantifier == $bQuantifier) {
    // Sort alphabetically.
    return (isset($a->typeStatus->label) && isset($b->typeStatus->label) && $a->typeStatus->label < $b->typeStatus->label) ? -1 : 1;
  }
  return ($aQuantifier < $bQuantifier) ? -1 : 1;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_homotypicSynonymLine($variables) {
  $taxon = $variables['taxon'];
  $out = '';
  $out .= '<li class="synonym">' . cdm_related_taxon($taxon, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';

  return $out;
}

  /**
   * Renders the string of Homonyms for a given taxon.
   *
   * @param $taxon
   *    A CDM Taxon instance
   * @return String
   *    The string of homomyns
   *
   * @throws \Exception
   */
  function cdm_name_relationships_of($taxon) {
// =========== START OF HOMONYMS ========== //
    RenderHints::pushToRenderStack('homonym');
    // the render stack element homonyms is being used in the default render templates !!!, see CDM_NAME_RENDER_TEMPLATES_DEFAULT

    // Later homonym or treated as later homonym AND bloking names.
    // TODO apply filter ? $name_rels_to_show = variable_get('name_relationships_to_show', NULL);
    $from_name_relations = cdm_ws_get(CDM_WS_PORTAL_TAXON_FROM_NAMERELATIONS,
      $taxon->uuid);
    $to_name_relations = cdm_ws_get(CDM_WS_PORTAL_TAXON_TO_NAMERELATIONS,
      $taxon->uuid);
    $name_relations = array_merge($from_name_relations, $to_name_relations);

    $homonyms_array = array();

    if ($name_relations) {
      foreach ($name_relations as $element) {
        $taxon_html = NULL;
        switch ($element->type->uuid) {
          case UUID_LATER_HOMONYM :
            $elementTaxonBasesUuid = isset ($element->toName->taxonBases [0]->uuid) ? $element->toName->taxonBases [0]->uuid : '';

            //from relation ships -> only shown at fromName-synonym
            if ($taxon->name->uuid == $element->fromName->uuid) {
              $taxon_html = theme('cdm_taxonName', array(
                'taxonName' => $element->toName,
                'nameLink' => url(path_to_name($element->toName->uuid,
                  $taxon->uuid, $elementTaxonBasesUuid))
              ));
            }
            break;
          case UUID_TREATED_AS_LATER_HOMONYM :
            $elementTaxonBasesUuid = isset ($element->toName->taxonBases [0]->uuid) ? $element->toName->taxonBases [0]->uuid : '';

            //from relation ships -> only shown at fromName-synonym
            if ($taxon->name->uuid == $element->fromName->uuid) {
              $taxon_html = render_taxon_or_name($element->toName, url(path_to_name($element->toName->uuid)));
            }
            break;
          case UUID_BLOCKING_NAME_FOR :
            $elementTaxonBasesUuid = isset ($element->fromName->taxonBases [0]->uuid) ? $element->fromName->taxonBases [0]->uuid : '';

            //to relation ships -> only shown at toName-synonym
            if ($taxon->name->uuid == $element->toName->uuid) {
              $taxon_html = theme('cdm_taxonName', array(
                'taxonName' => $element->fromName,
                'nameLink' => url(path_to_name($element->fromName->uuid,
                  $taxon->uuid, $elementTaxonBasesUuid))
              ));
            }
            break;
          default:
            $taxon_html = NULL;
        }
        if (isset($taxon_html) && $taxon_html) {
          if (count($homonyms_array)) {
            $homonyms_array [] = 'nec ' . $taxon_html;
          }
          else {
            $homonyms_array [] = 'non ' . $taxon_html;
          }
        }
      }
    }

    RenderHints::popFromRenderStack();
    return (count($homonyms_array) ?'[' . trim(join(" ", $homonyms_array)) . ']' : '');
  }

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_heterotypicSynonymyGroup($variables) {
  $homotypicalGroup = $variables['homotypicalGroup'];
  RenderHints::pushToRenderStack('heterotypicSynonymyGroup');

  $out = '';
  $out = '<div class="heterotypic-synonymy-group"><ul class="heterotypicSynonymyGroup">';
  $footnoteListKey = (isset($homotypicalGroup[0]) ? $homotypicalGroup[0]->uuid : 'NULL');
  RenderHints::setFootnoteListKey($footnoteListKey);

  $is_first_entry = TRUE;
  $typeDesignations = NULL;
  foreach ($homotypicalGroup as $synonym) {
    if ($is_first_entry) {
      $is_first_entry = FALSE;
      $typeDesignations = cdm_ws_get(CDM_WS_PORTAL_NAME_TYPEDESIGNATIONS, $synonym->name->uuid);
      // Is first list entry.
      $out .= '<li class="firstentry synonym">' . cdm_related_taxon($synonym, UUID_HETEROTYPIC_SYNONYM_OF) . '</li>';
    }
    else {
      $out .= '<li class="synonym">' . cdm_related_taxon($synonym, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';
    }
  }

  if ($typeDesignations) {
    $out .= theme('cdm_typedesignations', array('typeDesignations' => $typeDesignations));
  }
  $out .= '</ul>';

  // ------- footnotes ------- //
  $out .= '<ul class="footnotes">';
  $out .= theme('cdm_annotation_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= theme('cdm_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= '</ul>';

  $out .= '</div>';

  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * Renders the homotypic synonymy group for the accepted taxon in the synonymy.
 *
 * Foonotes of the accepted taxon will also be rendered here in the
 * homotypic synonymy group even if the synonymList or prependedSynonyms are
 * empty. Therefore  the homotypic group and accepted taxon share the  same
 * footnote key.
 *
 * @param $variables
 *   an associative array:
 *   - synonymList: the list of cdm Synonym entities
 *   - accepted_taxon_uuid: the uuid of the accepted taxon
 *   - prependedSynonyms: further synonyms which should be prepended
 *      before the actual list of synonyms
 */
function theme_cdm_homotypicSynonymyGroup($variables) {
  $synonymList = $variables['synonymList'];
  $accepted_taxon_name_uuid = $variables['accepted_taxon_name_uuid'];
  $prependedSynonyms = $variables['prependedSynonyms'];

  RenderHints::pushToRenderStack('homotypicSynonymyGroup');

  $homonym_typeDesignations = NULL;

  // TODO improve typeDesignations retrieval: wouldn't it be suffcient to retrieve all typeDesignations
  // only from the accepted taxon?
  $accepted_typeDesignations = cdm_ws_get(CDM_WS_PORTAL_NAME_TYPEDESIGNATIONS, $accepted_taxon_name_uuid);

  $out = '<div class="homotypic-synonymy-group">';

  if (isset ($accepted_typeDesignations) || is_array($prependedSynonyms) || is_array($synonymList)) {
    $out .= '<ul class="homotypicSynonyms">';
  if (!empty($prependedSynonyms)) {
    foreach ($prependedSynonyms as $taxon) {
      $out .= '<li class="synonym">' . cdm_related_taxon($taxon, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';
    }
  }

  $homonym_typeDesignations = NULL;
  if (isset($synonymList[0])) {
    foreach ($synonymList as $synonym) {
      $out .= '<li class="synonym">' . cdm_related_taxon($synonym, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';
    }
    $homonym_typeDesignations = cdm_ws_get(CDM_WS_PORTAL_NAME_TYPEDESIGNATIONS, $synonymList[0]->name->uuid);
  }

  // type designations
  if ($accepted_typeDesignations) {
    $type_designations = filter_cdm_entity_list($homonym_typeDesignations, $accepted_typeDesignations);
  }
  else {
    $type_designations = $homonym_typeDesignations;
  }

  if ($type_designations) {
    $out .= theme('cdm_typedesignations', array('typeDesignations' => $type_designations));
  }

  }

  $out .= '</ul>';

  // ------- footnotes ------- //

  // all foonotes of the homotypic group and also of the accepted taxon are
  // rendered here, both should have the same footnote key
  $out .= '<ul class="footnotes">';
  $out .= theme('cdm_annotation_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= theme('cdm_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= '</ul>';

  $out .= '</div>';


  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * Provides the name render template to be used within the page elements identified the the $renderPath.
 *
 * The render templates arrays contains one or more name render template to be used within the page elements identified the the
 * renderPath. The renderPath is the key of the subelements whereas the value is the name render template.
 * The following keys are curretly recogized:
 *
 *   - list_of_taxa:
 *   - acceptedFor:
 *   - taxon_page_synonymy
 *   - typedesignations
 *   - taxon_page_title
 *   - polytomousKey
 *   - na: name + authorship
 *   - nar:name + authorship + reference
 *   - #DEFAULT
 *
 * A single render template can be used for multiple render paths. In this case the according key of the render templates
 * array element should be the list of these render paths concatenated by ONLY a comma character without any whitespace.
 *
 * A render template is an associative array. The keys of this array are referring to the keys as defined in the part
 * definitions array.
 * @see get_partDefinition($taxonNameType) for more information
 *
 * The value of the render template element must be set to TRUE in order to let this part being rendered.
 * The namePart, nameAuthorPart and referencePart can also hold an associative array with a single
 * element: array('#uri' => TRUE). The value of the #uri element will be replaced by the according
 * links if the paramters $nameLink or $refenceLink are set.
 *
 * @param string $renderPath
 *   The render path can consist of multiple dot separated elements
 *   @see RenderHints::getRenderPath()
 * @param string $nameLink
 *   The link path ot URL to be used for name parts if a link is forseen in the template
 *   matching the given $renderPath.
 * @param string $referenceLink
 *   The link path ot URL to be used for nomencaltural reference parts if a link is forseen
 *   in the template matching the given $renderPath.
 * @return array
 *   An assciative array, the render template
 */
function get_nameRenderTemplate($renderPath, $nameLink = NULL, $refenceLink = NULL) {

  $template = NULL;

  static $default_render_templates = NULL;
  if (!isset($default_render_templates)) {
    $default_render_templates = unserialize(CDM_NAME_RENDER_TEMPLATES_DEFAULT);
  }
  static $render_templates = NULL;
  if($render_templates == NULL) {
      $render_templates = variable_get(CDM_NAME_RENDER_TEMPLATES, $default_render_templates);
      // needs to be converted to an array
      $render_templates = convert_to_array($render_templates);
  }

  // get the base element of the renderPath
  if (($separatorPos = strpos($renderPath, '.')) > 0) {
    $renderPath_base = substr($renderPath, 0, $separatorPos);
  } else {
    $renderPath_base = $renderPath;
  }

  // 1. try to find a template using the render path base element
  if(array_key_exists($renderPath_base, $render_templates)){
    $template = (array)$render_templates[$renderPath_base];
  }

  // 2. Find best matching default RenderTemplate in theme
  // by stripping the dot separated render path element by element
  // is no matching template is found the DEFAULT will be used.
  while (!is_array($template) && strlen($renderPath) > 0) {

    foreach ($render_templates as $k => $t) {
      if (strpos(',' . $k . ',', $renderPath ) !== FALSE) {
        $template = $t;
        break;
      }
    }

    // shorten by one element
    $renderPath = substr($renderPath, 0, strrpos($renderPath, '.'));
    /*
    if(!is_array($template)){
      echo "<br/>->".$renderPath;
    }
    */
  }

  // 3. Otherwise get default RenderTemplate from theme.
  if (!is_array($template)) {
      $template = $render_templates['#DEFAULT'];
  }

  // --- set the link uris to the according template fields if they exist
  if(isset($template['nameAuthorPart']) && isset($template['nameAuthorPart']['#uri'])) {
    if ($nameLink) {
      $template['nameAuthorPart']['#uri'] = $nameLink;
    }
    else {
      unset($template['nameAuthorPart']['#uri']);
    }
  }

  if ($nameLink && isset($template['namePart']['#uri'])) {
    $template['namePart']['#uri'] = $nameLink;
  }
  else {
    unset($template['namePart']['#uri']);
  }

  if ($refenceLink && isset($template['referencePart']['#uri'])) {
    $template['referencePart']['#uri'] = $refenceLink;
  }
  else {
    unset($template['referencePart']['#uri']);
  }

  return $template;
}

/**
 * The part definitions define the specific parts of which a rendered taxon name plus additional information will consist.
 *
 * A full taxon name plus additional information can consist of the following elements:
 *
 *   - name: the taxon name inclugin rank nbut without author
 *   - authorTeam:  The authors of a reference, also used in taxon names
 *   - authors:  The authors of a reference, also used in taxon names
 *   - reference: the nomenclatural reference,
 *   - microreference:  Volume, page number etc.
 *   - status:  The nomenclatural status of a name
 *   - description: name descriptions like protologues etc ...
 *
 * These elements are combined in the part definitions array to from the specific parts to be rendered.
 * Usually the following parts are formed:
 *
 * The name "Lapsana communis L., Sp. Pl.: 811. 1753" shall be an example here:
 *  - namePart: the name and rank (in example: "Lapsana communis")
 *  - authorshipPart: the author (in example: "L.")
 *  - nameAuthorPart: the combination of name and author part (in example: "Lapsana communis L.").
 *     This is useful for zoological names where the authorshipPart belongs to the name and both should
 *     be combined when a link to the taxon is rendered.
 *  - referencePart: the nomencaltural reference (in example: "Sp. Pl. 1753")
 *  - microreferencePart: usually the page number (in example ": 811.")
 *  - statusPart: the nomenclatorical status
 *  - descriptionPart:
 *
 * Each set of parts is dedicated to render a specific TaxonName type, the type names are used as keys for the
 * specific parts part definitions:
 *
 *  - BotanicalName
 *  - ZoologicalName
 *  - #DEFAULT:  covers ViralNames and general NonViralNames
 *
 * An example:
 * @code
 * array(
 *    'ZoologicalName' => array(
 *        'namePart' => array('name' => TRUE),
 *        'referencePart' => array('authorTeam' => TRUE),
 *        'microreferencePart' => array('microreference' => TRUE),
 *        'statusPart' => array('status' => TRUE),
 *        'descriptionPart' => array('description' => TRUE),
 *    ),
 *    'BotanicalName' => array(
 *        'namePart' => array(
 *            'name' => TRUE,
 *            'authors' => TRUE,
 *        ),
 *        'referencePart' => array(
 *            'reference' => TRUE,
 *            'microreference' => TRUE,
 *        ),
 *        'statusPart' => array('status' => TRUE),
 *        'descriptionPart' => array('description' => TRUE),
 *    ),
 *  );
 * @endcode
 *
 */
function get_partDefinition($taxonNameType) {

  static $default_part_definitions = null;
  if (!isset($default_part_definitions)) {
    $default_part_definitions= unserialize(CDM_PART_DEFINITIONS_DEFAULT);
  }

  static $part_definitions = null;
  if (!isset($part_definitions)) {
     $part_definitions = convert_to_array(variable_get(CDM_PART_DEFINITIONS, $default_part_definitions));
  }

  if (array_key_exists($taxonNameType, $part_definitions)) {
    return $part_definitions[$taxonNameType];
  } else {
    return $part_definitions['#DEFAULT']; // covers ViralNames and general NonViralNames
  }

}

/**
 * Renders the markup for a CDM TaxonName instance.
 *
 * The layout of the name representation is configured by the
 * part_definitions and render_templates (see get_partDefinition() and
 * get_nameRenderTemplate())
 *
 * @param $taxonName
 *    cdm TaxonNameBase instance
 * @param $sec
 *    the sec reference of a taxon having this name (optional)
 * @param $nameLink
 *    URI to the taxon, @see path_to_taxon(), must be processed by url() before passing to this method
 * @param $refenceLink
 *    URI to the reference, @see path_to_reference(), must be processed by url() before passing to this method
 * @param $show_annotations
 *    turns the display of annotations on
 * @param $is_type_designation
 *    To indicate that the supplied taxon name is a name type designation.
 * @param $skiptags
 *    an array of name elements tags like 'name', 'rank' to skip. The name part
 *          'authors' will not ber affected by this filter. This part is managed though the render template
 *          mechanism.
 *
 * @return string
 *  The markup for a taxon name.
 *
 */
function render_taxon_or_name($taxon_name_or_taxon_base, $nameLink = NULL, $refenceLink = NULL,
  $show_annotations = true, $is_type_designation = false, $skiptags = array()) {

  if($taxon_name_or_taxon_base->class == 'Taxon' || $taxon_name_or_taxon_base->class == 'Synonym'){
    $taxonName = $taxon_name_or_taxon_base->name;
    // use the TaxonBase.taggedTitle so we have the secRef
    $taggedTitle = $taxon_name_or_taxon_base->taggedTitle;
  } else {
    // assuming this is a TaxonNameBase
    $taxonName = $taxon_name_or_taxon_base;
    $taggedTitle = $taxon_name_or_taxon_base->taggedName;
  }


  $renderTemplate = get_nameRenderTemplate(RenderHints::getRenderPath(), $nameLink, $refenceLink);
  $partDefinition = get_partDefinition($taxonName->class);

  // Apply definitions to template.
  foreach ($renderTemplate as $part => $uri) {

    if (isset($partDefinition[$part])) {
      $renderTemplate[$part] = $partDefinition[$part];
    }
    if (is_array($uri) && isset($uri['#uri'])) {
      $renderTemplate[$part]['#uri'] = $uri['#uri'];
    }
  }

  $secref_tagged_text = split_secref_from_tagged_title($taggedTitle);
  normalize_tagged_title($taggedTitle);

  $firstEntryIsValidNamePart =
    isset($taggedTitle)
    && is_array($taggedTitle)
    && isset($taggedTitle[0]->text)
    && is_string($taggedTitle[0]->text)
    && $taggedTitle[0]->text != ''
    && isset($taggedTitle[0]->type)
    && $taggedTitle[0]->type == 'name';
  $lastAuthorElementString = FALSE;

  // Got to use second entry as first one, see ToDo comment below ...
  if ($firstEntryIsValidNamePart) {

    $taggedName = $taggedTitle;
    $hasNamePart_with_Authors = isset($renderTemplate['namePart']) && isset($renderTemplate['namePart']['authors']);
    $hasNameAuthorPart_with_Authors = isset($renderTemplate['nameAuthorPart']) && isset($renderTemplate['nameAuthorPart']['authors']);

    if (!(($hasNamePart_with_Authors) || ($hasNameAuthorPart_with_Authors))) {
      // Find author and split off from name.
      // TODO expecting to find the author as the last element.
      /*
      if($taggedName[count($taggedName)- 1]->type == 'authors'){
        $authorTeam = $taggedName[count($taggedName)- 1]->text;
        unset($taggedName[count($taggedName)- 1]);
      }
      */

      // Remove all authors.
      $taggedNameNew = array();
      foreach ($taggedName as $element) {
        if ($element->type != 'authors') {
          $taggedNameNew[] = $element;
        }
        else {
          $lastAuthorElementString = $element->text;
        }
      }
      $taggedName = $taggedNameNew;
    }
    $name = '<span class="' . $taxonName->class . '">' . cdm_taggedtext2html($taggedName, 'span', ' ', $skiptags) . '</span>';
  }
  else {
    $name = '<span class="' . $taxonName->class . '_titleCache">' . $taxonName->titleCache . '</span>';
  }

  // Fill name into $renderTemplate.
  array_setr('name', $name, $renderTemplate);

  // Fill with authorTeam.
  /*
  if($authorTeam){
    $authorTeamHtml = ' <span class="authorTeam">'.$authorTeam.'</span>';
    array_setr('authorTeam', $authorTeamHtml, $renderTemplate);
  }
  */

  // Fill with reference.
  if (isset($renderTemplate['referencePart']) && !$is_type_designation) {

    // default separator
    $separator = '';

    // [Eckhard]:"Komma nach dem Taxonnamen ist grunsätzlich falsch,
    // Komma nach dem Autornamen ist überall dort falsch, wo ein "in" folgt."
    if (isset($renderTemplate['referencePart']['reference']) && isset($taxonName->nomenclaturalReference)) {
      $microreference = NULL;
      if (isset($renderTemplate['referencePart']['microreference'])&& isset($taxonName->nomenclaturalMicroReference)) {
        $microreference = $taxonName->nomenclaturalMicroReference;
      }
      $citation = cdm_ws_getNomenclaturalReference($taxonName->nomenclaturalReference->uuid, $microreference);

      // Find preceding element of the reference.
      $precedingKey = get_preceding_contentElementKey('reference', $renderTemplate);
      if (str_beginsWith($citation, ", in")) {
        $citation = substr($citation, 2);
        $separator = ' ';
      }
      elseif (!str_beginsWith($citation, "in") && $precedingKey == 'authors') {
        $separator = ', ';
      } else {
        $separator = ' ';
      }


      $referenceArray['#separator'] = $separator;
      $referenceArray['#html'] = '<span class="reference">' . $citation . '</span>';
      array_setr('reference', $referenceArray, $renderTemplate);
    }

    // If authors have been removed from the name part the last named authorteam
    // should be added to the reference citation, otherwise, keep the separator
    // out of the reference.
    if (isset($renderTemplate['referencePart']['authors']) && $lastAuthorElementString) {
      // If the nomenclaturalReference citation is not included in the
      // reference part but diplay of the microreference
      // is wanted, append the microreference to the authorTeam.
      $citation = '';
      if (!isset($renderTemplate['referencePart']['reference']) && isset($renderTemplate['referencePart']['microreference'])) {
        $separator = ": ";
        $citation = $taxonName->nomenclaturalMicroReference;
      }
      $referenceArray['#html'] = ' <span class="reference">' . $lastAuthorElementString . $separator . $citation . '</span>';
      array_setr('authors', $referenceArray, $renderTemplate);
    }
  }

  $is_reference_year = false;
  if (isset($renderTemplate['referenceYearPart']['reference.year'])) {
    if(isset($taxonName->nomenclaturalReference->datePublished)){
      $referenceArray['#html'] = ' <span class="reference">' . timePeriodToString($taxonName->nomenclaturalReference->datePublished) . '</span>';
      array_setr('reference.year', $referenceArray, $renderTemplate);
      $is_reference_year = true;
    }
  }

  if (isset($renderTemplate['secReferencePart'])){
    if(isset($secref_tagged_text[1])){
      array_setr('secReference',
        $is_reference_year ? '.': ''
          . ' <span class="sec_reference">'
          . $secref_tagged_text[0]->text . $secref_tagged_text[1]->text
          . '</span>', $renderTemplate);
    }
  }

  // Fill with status.
  $statusHtml = '';
  if (isset($taxonName->status) && is_array($taxonName->status)) {
    if (array_setr('status', TRUE, $renderTemplate)) {
      if (isset($taxonName->status[0])) {
        foreach ($taxonName->status as $status) {
          $statusHtml .= ', ' . $status->type->representation_L10n_abbreviatedLabel;
        }
      }
      array_setr('status', '<span class="nomenclatural_status">' . $statusHtml . '</span>', $renderTemplate);
    }
  }

  // Fill with protologues etc...
  $descriptionHtml = '';
  if (array_setr('description', TRUE, $renderTemplate)) {
    $descriptions = cdm_ws_get(CDM_WS_PORTAL_NAME_DESCRIPTIONS, $taxonName->uuid);
    foreach ($descriptions as $description) {
      if (!empty($description)) {
        foreach ($description->elements as $description_element) {
          $second_citation = '';
          if (isset($description_element->multilanguageText_L10n) && $description_element->multilanguageText_L10n->text) {
            $second_citation = '[& ' . $description_element->multilanguageText_L10n->text . '].';
          }
          $descriptionHtml .= $second_citation;
          $descriptionHtml .= theme("cdm_media", array(
              'descriptionElement' => $description_element,
              'mimeTypePreference' => array(
                  'application/pdf',
                  'image/png',
                  'image/jpeg',
                  'image/gif',
                  'text/html',
                )
              )
            );

        }
      }
    }
    array_setr('description', $descriptionHtml, $renderTemplate);
  }

  // Render.
  $out = '<span data-cdm-ref="/name/' . $taxonName->uuid . '">';

  foreach ($renderTemplate as $partName => $part) {
    $separator = '';
    $partHtml = '';
    $uri = FALSE;
    if (!is_array($part)) {
      continue;
    }
    if (isset($part['#uri']) && is_string($part['#uri'])) {
      $uri = $part['#uri'];
      unset($part['#uri']);
    }
    foreach ($part as $key => $content) {
      $html = '';
      if (is_array($content)) {
        $html = $content['#html'];
        if(isset($content['#separator'])) {
          $separator = $content['#separator'];
        }
      }
      elseif (is_string($content)) {
        $html = $content;
      }
      $partHtml .= '<span class="' . $key . '">' . $html . '</span>';
    }
    if ($uri) {
      // cannot use l() here since the #uri aleady should have been processed through uri() at this point
      $out .= $separator . '<a href="' . $uri . '" class="' . $partName . '">' . $partHtml . '</a>';

    }
    else {
      $out .= $separator . $partHtml;
    }
  }
  $out .= '</span>';
  if ($show_annotations) {
    // $out .= theme('cdm_annotations_as_footnotekeys', $taxonName);
  }
  return $out;
}

/**
 * Recursively searches the array for the $key and sets the given value.
 *
 * @param mixed $key
 *   Key to search for.
 * @param mixed $value
 *   Value to set.'
 * @param array $array
 *   Array to search in.
 *
 * @return bool
 *   True if the key has been found.
 */
function &array_setr($key, $value, array &$array) {
  $res = NULL;
  foreach ($array as $k => &$v) {
    if ($key == $k) {
      $v = $value;
      return $array;
    }
    elseif (is_array($v)) {
      $innerArray = array_setr($key, $value, $v);
      if ($innerArray) {
        return $array;
      }
    }
  }
  return $res;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function &get_preceding_contentElement($contentElementKey, array &$renderTemplate) {
  $res = NULL;
  $precedingElement = NULL;
  foreach ($renderTemplate as &$part) {
    foreach ($part as $key => &$element) {
      if ($key == $contentElementKey) {
        return $precedingElement;
      }
      $precedingElement = $element;
    }
  }
  return $res;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function &get_preceding_contentElementKey($contentElementKey, array &$renderTemplate) {
  $res = NULL;
  $precedingKey = NULL;
  foreach ($renderTemplate as &$part) {
    if (is_array($part)) {
      foreach ($part as $key => &$element) {
        if ($key == $contentElementKey) {
          return $precedingKey;
        }
        if (!str_beginsWith($key, '#')) {
          $precedingKey = $key;
        }
      }
    }
  }
  return $res;
}
