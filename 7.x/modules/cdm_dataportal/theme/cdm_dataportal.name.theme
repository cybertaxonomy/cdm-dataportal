<?php
/**
 * @file
 * Name theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */

/**
 * Return HTML for the lectotype citation with the correct layout.
 *
 * This function prints the lectotype citation with the correct layout.
 * Lectotypes are renderized in the synonymy tab of a taxon if they exist.
 *
 * @param mixed $typeDesignation
 *   Object containing the lectotype citation to print.
 *
 * @return string
 *   Valid html string.
 */
function type_designation_citation_layout($typeDesignation, $footnote_separator = ',') {
  $res = '';
  $citation = $typeDesignation->citation;
  $pages = $typeDesignation->citationMicroReference;
  if(isset($typeDesignation->typeStatus->uuid) && isset($typeDesignation->typeStatus->representation_L10n)) {
    if ( $typeDesignation->typeStatus->uuid == UUID_NTD_ORIGINAL_DESIGNATION || $typeDesignation->typeStatus->uuid == UUID_NTD_MONOTYPY) {
      $res = ' (' . $typeDesignation->typeStatus->representation_L10n . ')';
      return $res;
    }
  }

  if ($citation) {
    // $type = $typeDesignation_citation->type;
    $year = isset($citation->datePublished->start) ? substr($citation->datePublished->start, 0, 4) : '';
    $author = isset($citation->authorship->titleCache) ? $citation->authorship->titleCache : '';
    $res .= ' (designated by ';
    $res .= $author;
    $res .= ($year ? ' ' . $year : '');
    $res .= ($pages ? ': ' . $pages : '');
    // $res .= ')';

    // footnotes should be rendered in the parent element so we
    // are relying on the FootnoteListKey set there
    $fkey_typeDesignation = FootnoteManager::addNewFootnote(RenderHints::getFootnoteListKey(), $typeDesignation->citation->titleCache);
    $res .= theme('cdm_footnote_key', array(
      'footnoteKey' => $fkey_typeDesignation,
      'separator' => $footnote_separator,
      'highlightable' => TRUE,
      'separator_off' => TRUE,
    )) . ')';
  }
  return $res;
}


/**
 * Renders and array of CDM TypeDesignations
 *
 * @param array $variables
 *   - typeDesignations: an array of cdm TypeDesignation entities to render
 */
function theme_cdm_typedesignations($variables) {
  $typeDesignations = $variables['typeDesignations'];

  // need to add element to render path since type designations
  // need other name render template
  RenderHints::pushToRenderStack('typedesignations');

  $out = '<ul class="typeDesignations">';
  $typeDesignation_footnotes = FALSE;
  $is_lectotype = FALSE;
  $specimenTypeDesignations = array();
  $separator = ',';
  foreach ($typeDesignations as $typeDesignation) {
    if ($typeDesignation->class == 'SpecimenTypeDesignation') {
      // SpecimenTypeDesignations should be ordered. Collect theme here only.
      $specimenTypeDesignations[] = $typeDesignation;
    }
    // It is a lectotype?
    else {
      if (isset($typeDesignation->typeStatus->uuid) && $typeDesignation->typeStatus->uuid == UUID_NTD_LECTOTYPE) {
        $is_lectotype = TRUE;
      }
      // It's a NameTypeDesignation.
      if ($typeDesignation->notDesignated) {
        $out .= '<li class="nameTypeDesignation"><span class="status">' . ($is_lectotype ? 'Lectotype' : 'Type') . '</span>: ' . t('not designated') . '</li>';
      }
      elseif ($typeDesignation->typeName) {
        $link_to_name_page = url(path_to_name($typeDesignation->typeName->uuid));
        $out .= '<li class="nameTypeDesignation"><span class="status">' . ($is_lectotype ? 'Lectotype' : 'Type') . '</span>';

        if ($typeDesignation->citation) {
          $out .= type_designation_citation_layout($typeDesignation, $separator);

        }
        $referenceUri = '';
        if (isset($typeDesignation->typeName->nomenclaturalReference)) {
          $referenceUri = url(path_to_reference($typeDesignation->typeName->nomenclaturalReference->uuid));
        }
        $out .= ': ' . render_taxon_or_name($typeDesignation->typeName, $link_to_name_page, $referenceUri, TRUE, TRUE);
      }
    }
  }

  if (!empty($specimenTypeDesignations)) {
    // Sorting might be different for dataportals so this has to be
    // parameterized.
    usort($specimenTypeDesignations, "compare_specimenTypeDesignationStatus");
    foreach ($specimenTypeDesignations as $std) {
      $typeReference = '';
      if (!empty($std->citation)) {
        $author_team = cdm_ws_get(CDM_WS_REFERENCE_AUTHORTEAM, $std->citation->uuid);
        $shortCitation = $author_team->titleCache;

        $shortCitation .= (strlen($shortCitation) > 0 ? ' ' : '') . partialToYear($std->citation->datePublished->start);
        $missingShortCitation = FALSE;
        if (strlen($shortCitation) == 0) {
          $shortCitation = theme('cdm_reference', array('reference' => $std->citation));
          $missingShortCitation = TRUE;
        }

        $typeReference .= '&nbsp;(' . t('designated by');
        $typeReference .= '&nbsp;<span class="typeReference ' . ($missingShortCitation ? '' : 'cluetip') . ' no-print" title="' . htmlspecialchars('|' . theme('cdm_reference', array('reference' => $std->citation)) . '|') . '">';
        $typeReference .= $shortCitation . '</span>';
        if (!empty($std->citationMicroReference)) {
          $typeReference .= ':' . $std->citationMicroReference;
        }
        $typeReference .= ')';

        // footnotes should be rendered in the parent element so we
        // are relying on the FootnoteListKey set there
        $_fkey2 = FootnoteManager::addNewFootnote(RenderHints::getFootnoteListKey(), $std->citation->titleCache);
        $typeReference .= theme('cdm_footnote_key', array(
          'footnoteKey' => $_fkey2,
          'separator' => $separator,
          'highlightable' => TRUE,
          'separator_off' => TRUE,
         ));
      }

      $derivedUnitFacadeInstance = null;

      $out .= '<li class="specimenTypeDesignation">';
      $out .= '<span class="status">'
        . ((isset($std->typeStatus->representation_L10n)) ? $std->typeStatus->representation_L10n : t('Type'))
        . $typeReference
        . '</span>: ';


      if (isset($std->typeSpecimen)) {
        $derivedUnitFacadeInstance = cdm_ws_get(CDM_WS_DERIVEDUNIT_FACADE, $std->typeSpecimen->uuid);
      }
      if ( isset($derivedUnitFacadeInstance ) ){
        $out .= $derivedUnitFacadeInstance->titleCache; // . ': ' . theme('cdm_specimen', array('specimenTypeDesignation' => $derivedUnitFacadeInstance));
      }

      // Footnotes for collection acronyms.
      // footnotes should be rendered in the parent element so we
      // are relying on the FootnoteListKey set there
      $_fkey = FootnoteManager::addNewFootnote(
          RenderHints::getFootnoteListKey(),
          (isset($derivedUnitFacadeInstance->collection->titleCache) ? $derivedUnitFacadeInstance->collection->titleCache : FALSE)
        );
      $out .= theme('cdm_footnote_key', array('footnoteKey' => $_fkey, 'separator' => $separator));
      $out .= '</li>';

    }
  }

  $out .= '</ul>';

  RenderHints::popFromRenderStack();

  return $out;
}

/**
 * FIXME this definitively has to be in another spot.
 * just didn't know where to put it right now.
 * Compares the status of two SpecimenTypeDesignations
 *
 * @param string $a
 *   A SpecimenTypeDesignations.
 * @param string $b
 *   SpecimenTypeDesignations.
 */
function compare_specimenTypeDesignationStatus($a, $b) {
  /*
  This is the desired sort order as of now: Holotype Isotype Lectotype
  Isolectotype Syntype.
  TODO Basically, what we are trying to do is, we define
  an ordered array of TypeDesignation-states and use the index of this array
  for comparison. This array has to be filled with the cdm- TypeDesignation
  states and the order should be parameterisable inside the dataportal.
  */
  // Make that static for now.
  $typeOrder = array(
    'Holotype',
    'Isotype',
    'Lectotype',
    'Isolectotype',
    'Syntype',
  );

  $aQuantifier = FALSE;
  $bQuantifier = FALSE;
  if (isset($a->typeStatus->label) && isset($b->typeStatus->label)) {
    $aQuantifier = array_search($a->typeStatus->label, $typeOrder);
    $bQuantifier = array_search($b->typeStatus->label, $typeOrder);
  }
  if ($aQuantifier == $bQuantifier) {
    // Sort alphabetically.
    return (isset($a->typeStatus->label) && isset($b->typeStatus->label) && $a->typeStatus->label < $b->typeStatus->label) ? -1 : 1;
  }
  return ($aQuantifier < $bQuantifier) ? -1 : 1;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_homotypicSynonymLine($variables) {
  $taxon = $variables['taxon'];
  $out = '';
  $out .= '<li class="synonym">' . cdm_related_taxon($taxon, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';

  return $out;
}

/**
 * Renders the string of Homonyms for a given taxon.
 *
 * @param $taxon
 *    A CDM Taxon instance
 * @return String
 *    The string of homomyns
 *
 * @throws \Exception
 */
function cdm_name_relationships_of($taxon) {
// =========== START OF HOMONYMS ========== //
  RenderHints::pushToRenderStack('homonym');
  // the render stack element homonyms is being used in the default render templates !!!, see CDM_NAME_RENDER_TEMPLATES_DEFAULT

  // Later homonym or treated as later homonym AND bloking names.
  // TODO apply filter ? $name_rels_to_show = variable_get('name_relationships_to_show', NULL);
  $from_name_relations = cdm_ws_get(CDM_WS_PORTAL_TAXON_FROM_NAMERELATIONS,
    $taxon->uuid);
  $to_name_relations = cdm_ws_get(CDM_WS_PORTAL_TAXON_TO_NAMERELATIONS,
    $taxon->uuid);
  $name_relations = array_merge($from_name_relations, $to_name_relations);

  $homonyms_array = array();

  if ($name_relations) {
    foreach ($name_relations as $element) {
      $taxon_html = NULL;
      switch ($element->type->uuid) {
        case UUID_LATER_HOMONYM :
          $elementTaxonBasesUuid = isset ($element->toName->taxonBases [0]->uuid) ? $element->toName->taxonBases [0]->uuid : '';

          //from relation ships -> only shown at fromName-synonym
          if ($taxon->name->uuid == $element->fromName->uuid) {
            $taxon_html =render_taxon_or_name($element->toName,
              url(path_to_name($element->toName->uuid, $taxon->uuid, $elementTaxonBasesUuid))
            );
          }
          break;
        case UUID_TREATED_AS_LATER_HOMONYM :
          $elementTaxonBasesUuid = isset ($element->toName->taxonBases [0]->uuid) ? $element->toName->taxonBases [0]->uuid : '';

          //from relation ships -> only shown at fromName-synonym
          if ($taxon->name->uuid == $element->fromName->uuid) {
            $taxon_html = render_taxon_or_name($element->toName, url(path_to_name($element->toName->uuid)));
          }
          break;
        case UUID_BLOCKING_NAME_FOR :
          $elementTaxonBasesUuid = isset ($element->fromName->taxonBases [0]->uuid) ? $element->fromName->taxonBases [0]->uuid : '';

          //to relation ships -> only shown at toName-synonym
          if ($taxon->name->uuid == $element->toName->uuid) {
            $taxon_html = render_taxon_or_name($element->fromName,
              url(path_to_name($element->fromName->uuid, $taxon->uuid, $elementTaxonBasesUuid))
            );
          }
          break;
        default:
          $taxon_html = NULL;
      }
      if (isset($taxon_html) && $taxon_html) {
        if (count($homonyms_array)) {
          $homonyms_array [] = 'nec ' . $taxon_html;
        }
        else {
          $homonyms_array [] = 'non ' . $taxon_html;
        }
      }
    }
  }

  RenderHints::popFromRenderStack();
  return (count($homonyms_array) ?'[' . trim(join(" ", $homonyms_array)) . ']' : '');
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_heterotypicSynonymyGroup($variables) {
  $homotypicalGroup = $variables['homotypicalGroup'];
  RenderHints::pushToRenderStack('heterotypicSynonymyGroup');

  $out = '';
  $out = '<div class="heterotypic-synonymy-group"><ul class="heterotypicSynonymyGroup">';
  $footnoteListKey = (isset($homotypicalGroup[0]) ? $homotypicalGroup[0]->uuid : 'NULL');
  RenderHints::setFootnoteListKey($footnoteListKey);

  $is_first_entry = TRUE;
  $typeDesignations = NULL;
  foreach ($homotypicalGroup as $synonym) {
    if ($is_first_entry) {
      $is_first_entry = FALSE;
      $typeDesignations = cdm_ws_get(CDM_WS_PORTAL_NAME_TYPEDESIGNATIONS, $synonym->name->uuid);
      // Is first list entry.
      $out .= '<li class="firstentry synonym">' . cdm_related_taxon($synonym, UUID_HETEROTYPIC_SYNONYM_OF) . '</li>';
    }
    else {
      $out .= '<li class="synonym">' . cdm_related_taxon($synonym, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';
    }
  }

  if ($typeDesignations) {
    $out .= theme('cdm_typedesignations', array('typeDesignations' => $typeDesignations));
  }
  $out .= '</ul>';

  // ------- footnotes ------- //
  $out .= '<ul class="footnotes">';
  $out .= theme('cdm_annotation_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= theme('cdm_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= '</ul>';

  $out .= '</div>';

  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * Renders the homotypic synonymy group for the accepted taxon in the synonymy.
 *
 * Foonotes of the accepted taxon will also be rendered here in the
 * homotypic synonymy group even if the synonymList or prependedSynonyms are
 * empty. Therefore  the homotypic group and accepted taxon share the  same
 * footnote key.
 *
 * @param $variables
 *   an associative array:
 *   - synonymList: the list of cdm Synonym entities
 *   - accepted_taxon_uuid: the uuid of the accepted taxon
 *   - prependedSynonyms: further synonyms which should be prepended
 *      before the actual list of synonyms
 */
function theme_cdm_homotypicSynonymyGroup($variables) {
  $synonymList = $variables['synonymList'];
  $accepted_taxon_name_uuid = $variables['accepted_taxon_name_uuid'];
  $prependedSynonyms = $variables['prependedSynonyms'];

  RenderHints::pushToRenderStack('homotypicSynonymyGroup');

  $homonym_typeDesignations = NULL;

  // TODO improve typeDesignations retrieval: wouldn't it be suffcient to retrieve all typeDesignations
  // only from the accepted taxon?
  $accepted_typeDesignations = cdm_ws_get(CDM_WS_PORTAL_NAME_TYPEDESIGNATIONS, $accepted_taxon_name_uuid);

  $out = '<div class="homotypic-synonymy-group">';

  if (isset ($accepted_typeDesignations) || is_array($prependedSynonyms) || is_array($synonymList)) {
    $out .= '<ul class="homotypicSynonyms">';
  if (!empty($prependedSynonyms)) {
    foreach ($prependedSynonyms as $taxon) {
      $out .= '<li class="synonym">' . cdm_related_taxon($taxon, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';
    }
  }

  $homonym_typeDesignations = NULL;
  if (isset($synonymList[0])) {
    foreach ($synonymList as $synonym) {
      $out .= '<li class="synonym">' . cdm_related_taxon($synonym, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';
    }
    $homonym_typeDesignations = cdm_ws_get(CDM_WS_PORTAL_NAME_TYPEDESIGNATIONS, $synonymList[0]->name->uuid);
  }

  // type designations
  if ($accepted_typeDesignations) {
    $type_designations = filter_cdm_entity_list($homonym_typeDesignations, $accepted_typeDesignations);
  }
  else {
    $type_designations = $homonym_typeDesignations;
  }

  if ($type_designations) {
    $out .= theme('cdm_typedesignations', array('typeDesignations' => $type_designations));
  }

  }

  $out .= '</ul>';

  // ------- footnotes ------- //

  // all foonotes of the homotypic group and also of the accepted taxon are
  // rendered here, both should have the same footnote key
  $out .= '<ul class="footnotes">';
  $out .= theme('cdm_annotation_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= theme('cdm_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= '</ul>';

  $out .= '</div>';


  RenderHints::popFromRenderStack();
  return $out;
}
