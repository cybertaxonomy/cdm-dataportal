<?php
  /**
   * @file
   * Required or useful functions for using CDM Data Store Webservices.
   *
   * Naming conventions:
   * ----------------------
   * - All webservice access methods are prefixed with cdm_ws.
   *
   * @copyright
   *   (C) 2007-2012 EDIT
   *   European Distributed Institute of Taxonomy
   *   http://www.e-taxonomy.eu
   *
   *   The contents of this module are subject to the Mozilla
   *   Public License Version 1.1.
   * @see http://www.mozilla.org/MPL/MPL-1.1.html
   *
   * @author
   *   - Andreas Kohlbecker <a.kohlbecker@BGBM.org>
   *   - Wouter Addink <w.addink@eti.uva.nl> (migration from Drupal 5 to Drupal7)
   */

  module_load_include('php', 'cdm_api', 'xml2json');
  module_load_include('php', 'cdm_api', 'commons');
  module_load_include('php', 'cdm_api', 'uuids');
  module_load_include('php', 'cdm_api', 'enums');
  module_load_include('php', 'cdm_api', 'webservice_uris');
  module_load_include('php', 'cdm_api', 'cdm_node');

  /**
   * Timeout used to override the default of 30 seconds
   * in @see drupal_http_request()
   *
   * @var CDM_HTTP_REQUEST_TIMEOUT: A float representing the maximum number of seconds the function
   *     call may take
   */
  define('CDM_HTTP_REQUEST_TIMEOUT', 90.0);



/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_ID_ASC', 'BY_ID_ASC');

/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_ID_DESC', 'BY_ID_DESC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_TITLE_CACHE_ASC', 'BY_TITLE_CACHE_ASC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_TITLE_CACHE_DESC', 'BY_TITLE_CACHE_DESC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_NOMENCLATURAL_ORDER_ASC', 'BY_NOMENCLATURAL_ORDER_ASC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_NOMENCLATURAL_ORDER_DESC', 'BY_NOMENCLATURAL_ORDER_DESC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_ORDER_INDEX_ASC', 'BY_ORDER_INDEX_ASC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_ORDER_INDEX_DESC', 'BY_ORDER_INDEX_DESC');


/**
 * Implements hook_menu().
 */
function cdm_api_menu() {
  $items = array();

  // usage: url('cdm_api/proxy/'.urlencode($content_url)."/$theme");
  $items['cdm_api/proxy'] = array(
    'page callback' => 'proxy_content',
    'access arguments' => array(
      'access cdm content',
    ),
    'type' => MENU_CALLBACK,
  );

  $items['cdm_api/setvalue/session'] = array(
    'page callback' => 'setvalue_session',
    'access arguments' => array(
      'access cdm content',
    ),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_block_info().
 */
function cdm_api_block_info() {

  $block['cdm_ws_debug'] = array(
      "info" => t("CDM web service debug"),
      "cache" => DRUPAL_NO_CACHE
  );
  return $block;
}

/**
 * Implements hook_block_view().
 */
function cdm_api_block_view($delta) {
  switch ($delta) {
    case 'cdm_ws_debug':

    $cdm_ws_url = variable_get('cdm_webservice_url', '');

    $field_map = array(
        'ws_uri' => t('URI') . ' <code>(' . $cdm_ws_url .'...)</code>',
        'time' => t('Time'),
        'fetch_seconds' => t('Fetching [s]'),
        'parse_seconds' => t('Parsing [s]'),
        'size_kb' => t('Size [kb]'),
        'status' => t('Status'),
        'data_links' =>  t('Links'),
    );


    if (!isset($_SESSION['cdm']['ws_debug'])) {
      $_SESSION['cdm']['ws_debug'] = array();
    }

    $header = '<thead><tr><th>' . join('</th><th>' , array_values($field_map)) . '</th></thead>';
    $footer = '<tfoot><tr><th>' . join('</th><th>' , array_values($field_map)) . '</th></tfoot>';
    $rows = array();

    foreach ($_SESSION['cdm']['ws_debug'] as $data){

      $data = unserialize($data);

      // stip of webservice base url
      $data['ws_uri'] = str_replace($cdm_ws_url, '', $data['ws_uri']);
      if($data['method'] == 'POST'){
        $data['ws_uri'] = 'POST: ' . $data['ws_uri'] . '?' . $data['post_data'];
      }

      $cells = array();
      foreach ($field_map as $field => $label){
        $cells[] = '<td class="' . $field . '">' .  $data[$field] . '</td>';
      }
      $rows[] = '<tr class="' . $data['status']  . '">' . join('' , $cells). '</tr>';
    }
    // clear session again
    $_SESSION['cdm']['ws_debug'] = array();

    _add_js_ws_debug();

    $block['subject'] = ''; // no subject, title in content for having a defined element id
    // otherwise it would depend on the theme
    $block['content'] =
        '<h4 id="cdm-ws-debug-button">' . t('CDM Debug') . '</h4>'
          // cannot use theme_table() since table footer is not jet supported in D7
        . '<div id="cdm-ws-debug-table-container"><table id="cdm-ws-debug-table">'
        . $header
        . '<tbody>' . join('', $rows) . '</tbody>'
        . $footer
        . '</table></div>';

    return $block;
  }
}

/**
 * Implements hook_cron().
 *
 * Expire outdated cache entries.
 */
function cdm_api_cron() {
  cache_clear_all(NULL, 'cache_cdm_ws');
}

// ===================== Tagged Text functions ================== //

/**
 * Converts an array of TaggedText items into corresponding html tags.
 *
 * Each item is provided with a class attribute which is set to the key of the
 * TaggedText item.
 *
 * @param array $taggedtxt
 *   Array with text items to convert.
 * @param string $tag
 *   Html tag name to convert the items into, default is 'span'.
 * @param string $glue
 *   The string by which the chained text tokens are concatenated together.
 *   Default is a blank character.
 *
 * @return string
 *   A string with HTML.
 */
function cdm_tagged_text_to_markup(array $taggedtxt, $tag = 'span', $glue = ' ', $skiptags = array()) {
  $out = '';
  $i = 0;
  foreach ($taggedtxt as $tt) {
    if (!in_array($tt->type, $skiptags) && strlen($tt->text) > 0) {
      $out .= (strlen($out) > 0 && ++$i < count($taggedtxt) ? $glue : '')
        . '<' . $tag . ' class="' . $tt->type . '">'
        . t('@text', array('@text' => $tt->text))
        . '</' . $tag . '>';
    }
  }
  return $out;
}


/**
 * Finds the text tagged with $tag_type in an array of taggedText instances.
 *
 * Note: This function is currently unused.
 *
 * @param array $taggedtxt
 *   Array with text items.
 * @param string $tag_type
 *   The type of tag for which to find text items in the $taggedtxt array, or NULL
 *   to return all texts.
 *
 * @return array
 *   An array with the texts mapped by $tag_type.
 */
function cdm_tagged_text_values(array $taggedtxt, $tag_type = NULL) {
  $tokens = array();
  if (!empty($taggedtxt)) {
    foreach ($taggedtxt as $tagtxt) {
      if ($tag_type === NULL || $tagtxt->type == $tag_type) {
        $tokens[] = $tagtxt->text;
      }
    }
  }
  return $tokens;
}

/**
 * Preprocess the taggedTitle arrays.
 *
 * Step 1: Turns 'newly' introduces tag types ("hybridSign")
 * into tag type "name"
 *
 * Step 2: Two taggedTexts which have the same type and which have
 * a separator between them are merged together.
 *
 * @param array $taggedTextList
 *    An array of TaggedText objects
 */
function normalize_tagged_text(&$taggedTextList) {

  if (is_array($taggedTextList)) {

    // First pass: rename.
    for ($i = 0; $i < count($taggedTextList); $i++) {

      if ($taggedTextList[$i]->type == "hybridSign") {
        $taggedTextList[$i]->type = "name";
      }
    }

    // Second pass: resolve separators.
    $taggedNameListNew = array();
    for ($i = 0; $i < count($taggedTextList); $i++) {

      // elements of the same type concatenated by a separator should be merged together
      if (isset($taggedTextList[$i + 2]) && $taggedTextList[$i + 1]->type == "separator" && $taggedTextList[$i]->type == $taggedTextList[$i + 2]->type) {
        $taggedName = clone $taggedTextList[$i];
        $taggedName->text = $taggedName->text . $taggedTextList[$i + 1]->text . $taggedTextList[$i + 2]->text;
        $taggedNameListNew[] = $taggedName;
        ++$i;
        ++$i;
        continue;
      }
      // no special handling
      $taggedNameListNew[] = $taggedTextList[$i];

    }
    $taggedTextList = $taggedNameListNew;
  }
}

function split_secref_from_tagged_text(&$tagged_text) {

  $extracted_tt = array();
  if (is_array($tagged_text)) {
    for ($i = 0; $i < count($tagged_text) - 1; $i++) {
      if ($tagged_text[$i + 1]->type == "secReference" && $tagged_text[$i]->type == "separator"){
        $extracted_tt[0] = $tagged_text[$i];
        $extracted_tt[1] = $tagged_text[$i + 1];
        unset($tagged_text[$i]);
        unset($tagged_text[$i + 1]);
        // also get the microfererence which could be in $tagged_text[$i + 3]
        if(isset($tagged_text[$i + 3])  && $tagged_text[$i + 2]->type == "separator" && $tagged_text[$i + 3]->type == "secReference"){
          $extracted_tt[2] = $tagged_text[$i + 2];
          $extracted_tt[3] = $tagged_text[$i + 3];
        }
        break;
      }
    }
  }
  return $extracted_tt;
}


function split_nomstatus_from_tagged_text(&$tagged_text) {

  $extracted_tt = array();
  if (is_array($tagged_text)) {
    for ($i = 0; $i < count($tagged_text) - 1; $i++) {
      if ($tagged_text[$i]->type == "nomStatus"){
        $extracted_tt[] = $tagged_text[$i];
        if(isset($tagged_text[$i + 1]) && $tagged_text[$i + 1]->type == "postSeparator"){
          $extracted_tt[] = $tagged_text[$i + 1];
          unset($tagged_text[$i + 1]);
        }
        if ($tagged_text[$i - 1]->type == "separator"){
          array_unshift($extracted_tt, $tagged_text[$i - 1]);
          unset($tagged_text[$i - 1]);
        }
        unset($tagged_text[$i]);
        break;
      }
    }
  }
  return $extracted_tt;
}

function find_tagged_text_elements($taggedTextList, $type){
  $matching_elements = array();
  if (is_array($taggedTextList)) {
    for ($i = 0; $i < count($taggedTextList) - 1; $i++) {
      if($taggedTextList[$i]->type == $type){
        $matching_elements[] = $taggedTextList[$i];
      }
    }
  }
  return $matching_elements;
}

// ===================== END of Tagged Text functions ================== //

/**
 * Lists the classifications a taxon belongs to
 *
 * @param CDM type Taxon $taxon
 *   the taxon
 *
 * @return array
 *   aray of CDM instances of Type Classification
 */
function get_classifications_for_taxon($taxon) {

  return cdm_ws_get(CDM_WS_TAXON_CLASSIFICATIONS, $taxon->uuid);;
}

/**
 * Returns the chosen FeatureTree for the taxon profile.
 *
 * The FeatureTree profile returned is the one that has been set in the
 * dataportal settings (layout->taxon:profile).
 * When the chosen FeatureTree is not found in the database,
 * the standard feature tree (UUID_DEFAULT_FEATURETREE) will be returned.
 *
 * @return mixed
 *   A cdm FeatureTree object.
 */
function get_profile_feature_tree() {
  static $profile_featureTree;

  if($profile_featureTree == NULL) {
    $profile_featureTree = cdm_ws_get(
      CDM_WS_FEATURETREE,
      variable_get(CDM_PROFILE_FEATURETREE_UUID, UUID_DEFAULT_FEATURETREE)
    );
    if (!$profile_featureTree) {
      $profile_featureTree = cdm_ws_get(CDM_WS_FEATURETREE, UUID_DEFAULT_FEATURETREE);
    }
  }

  return $profile_featureTree;
}

/**
 * Returns the chosen FeatureTree for SpecimenDescriptions.
 *
 * The FeatureTree returned is the one that has been set in the
 * dataportal settings (layout->taxon:specimen).
 * When the chosen FeatureTree is not found in the database,
 * the standard feature tree (UUID_DEFAULT_FEATURETREE) will be returned.
 *
 * @return mixed
 *   A cdm FeatureTree object.
 */
function cdm_get_occurrence_featureTree() {
  static $occurrence_featureTree;

  if($occurrence_featureTree == NULL) {
    $occurrence_featureTree = cdm_ws_get(
      CDM_WS_FEATURETREE,
      variable_get(CDM_OCCURRENCE_FEATURETREE_UUID, UUID_DEFAULT_FEATURETREE)
    );
    if (!$occurrence_featureTree) {
      $occurrence_featureTree = cdm_ws_get(CDM_WS_FEATURETREE, UUID_DEFAULT_FEATURETREE);
    }
  }
  return $occurrence_featureTree;
}

/**
 * Returns the FeatureTree for structured descriptions
 *
 * The FeatureTree returned is the one that has been set in the
 * dataportal settings (layout->taxon:profile).
 * When the chosen FeatureTree is not found in the database,
 * the standard feature tree (UUID_DEFAULT_FEATURETREE) will be returned.
 *
 * @return mixed
 *   A cdm FeatureTree object.
 */
function get_structured_description_featureTree() {
  static $structured_description_featureTree;

  if($structured_description_featureTree == NULL) {
    $structured_description_featureTree = cdm_ws_get(
        CDM_WS_FEATURETREE,
        variable_get(CDM_DATAPORTAL_STRUCTURED_DESCRIPTION_FEATURETREE_UUID, UUID_DEFAULT_FEATURETREE)
    );
    if (!$structured_description_featureTree) {
      $structured_description_featureTree = cdm_ws_get(
          CDM_WS_FEATURETREE,
          UUID_DEFAULT_FEATURETREE
      );
    }
  }
  return $structured_description_featureTree;
}


/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function set_last_taxon_page_tab($taxonPageTab) {
  $_SESSION['cdm']['taxon_page_tab'] = $taxonPageTab;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function get_last_taxon_page_tab() {
  if (isset($_SESSION['cdm']['taxon_page_tab'])) {
    return $_SESSION['cdm']['taxon_page_tab'];
  }
  else {
    return FALSE;
  }
}

/**
 *
 * @param object $media
 * @param array $mimeTypes
 * @param int $width
 * @param int $height
 *
 * @return array
 *   An array with preferred media representations or else an empty array.
 */
function cdm_preferred_media_representations($media, array $mimeTypes, $width = 400, $height = 300) {
  $prefRepr = array();
  if (!isset($media->representations[0])) {
    return $prefRepr;
  }

  while (count($mimeTypes) > 0) {
    // getRepresentationByMimeType
    $mimeType = array_shift($mimeTypes);

    foreach ($media->representations as &$representation) {
      // If the mimetype is not known, try inferring it.
      if (!$representation->mimeType) {
        if (isset($representation->parts[0])) {
          $representation->mimeType = infer_mime_type($representation->parts[0]->uri);
        }
      }

      if ($representation->mimeType == $mimeType) {
        // Preferred mimetype found -> erase all remaining mimetypes
        // to end loop.
        $mimeTypes = array();
        $dwa = 0;
        $dw = 0;
        $valid_parts_cnt = 0;
        // Look for part with the best matching size.
        foreach ($representation->parts as $part) {
          if(empty($part->uri)){
            // skip part if URI is missing
            continue;
          }
          $valid_parts_cnt++;
          if (isset($part->width) && isset($part->height)) {
            $dw = $part->width * $part->height - $height * $width;
          }
          if ($dw < 0) {
            $dw *= -1;
          }
          $dwa += $dw;
        }
        if($valid_parts_cnt > 0){
          $dwa = $dwa / $valid_parts_cnt;
          $prefRepr[$dwa . '_'] = $representation;
        }
      }
    }
  }
  // Sort the array.
  krsort($prefRepr);
  return $prefRepr;
}

/**
 * Infers the mime type of a file using the filename extension.
 *
 * The filename extension is used to infer the mime type.
 *
 * @param string $filepath
 *   The path to the respective file.
 *
 * @return string
 *   The mimetype for the file or FALSE if the according mime type could
 *   not be found.
 */
function infer_mime_type($filepath) {
  static $mimemap = NULL;
  if (!$mimemap) {
    $mimemap = array(
      'jpg' => 'image/jpeg',
      'jpeg' => 'image/jpeg',
      'png' => 'image/png',
      'gif' => 'image/gif',
      'giff' => 'image/gif',
      'tif' => 'image/tif',
      'tiff' => 'image/tif',
      'pdf' => 'application/pdf',
      'html' => 'text/html',
      'htm' => 'text/html',
    );
  }
  $extension = substr($filepath, strrpos($filepath, '.') + 1);
  if (isset($mimemap[$extension])) {
    return $mimemap[$extension];
  }
  else {
    // FIXME remove this hack just return FALSE;
    return 'text/html';
  }
}

/**
 * Converts an ISO 8601 org.joda.time.Partial to a year.
 *
 * The function expects an ISO 8601 time representation of a
 * org.joda.time.Partial of the form yyyy-MM-dd.
 *
 * @param string $partial
 *   ISO 8601 time representation of a org.joda.time.Partial.
 *
 * @return string
 *   Returns the year. In case the year is unknown (= ????), it returns NULL.
 */
function partialToYear($partial) {
  if (is_string($partial)) {
    $year = substr($partial, 0, 4);
    if (preg_match("/[0-9][0-9][0-9][0-9]/", $year)) {
      return $year;
    }
  }
  return '';
}

/**
 * Converts an ISO 8601 org.joda.time.Partial to a month.
 *
 * This function expects an ISO 8601 time representation of a
 * org.joda.time.Partial of the form yyyy-MM-dd.
 * In case the month is unknown (= ???) NULL is returned.
 *
 * @param string $partial
 *   ISO 8601 time representation of a org.joda.time.Partial.
 *
 * @return string
 *   A month.
 */
function partialToMonth($partial) {
  if (is_string($partial)) {
    $month = substr($partial, 5, 2);
    if (preg_match("/[0-9][0-9]/", $month)) {
      return $month;
    }
  }
  return '';
}

/**
 * Converts an ISO 8601 org.joda.time.Partial to a day.
 *
 * This function expects an ISO 8601 time representation of a
 * org.joda.time.Partial of the form yyyy-MM-dd and returns the day as string.
 * In case the day is unknown (= ???) NULL is returned.
 *
 * @param string $partial
 *   ISO 8601 time representation of a org.joda.time.Partial.
 *
 * @return string
 *   A day.
 */
function partialToDay($partial) {
  if (is_string($partial)) {
    $day = substr($partial, 8, 2);
    if (preg_match("/[0-9][0-9]/", $day)) {
      return $day;
    }
  }
  return '';
}

/**
 * Converts an ISO 8601 org.joda.time.Partial to YYYY-MM-DD.
 *
 * This function expects an ISO 8601 time representations of a
 * org.joda.time.Partial of the form yyyy-MM-dd and returns
 * four digit year, month and day with dashes:
 * YYYY-MM-DD eg: "2012-06-30", "1956-00-00"
 *
 * The partial may contain question marks eg: "1973-??-??",
 * these are turned in to '00' or are stripped depending of the $stripZeros
 * parameter.
 *
 * @param string $partial
 *   org.joda.time.Partial.
 * @param bool $stripZeros
 *   If set to TRUE the zero (00) month and days will be hidden:
 *   eg 1956-00-00 becomes 1956. The default is TRUE.
 * @param string @format
 * 	 Can ve used to specify the format of the date string, currently the following format strings are supported
 *    - "YYYY": Year only
 *    - "YYYY-MM-DD": this is the default
 *
 * @return string
 *   YYYY-MM-DD formatted year, month, day.
 */
function partialToDate($partial, $stripZeros = TRUE, $format= "YYYY-MM-DD") {

  $y = NULL; $m = NULL; $d = NULL;

  if(strpos($format, 'YY') !== FALSE){
    $y = partialToYear($partial);
  }
  if(strpos($format, 'MM') !== FALSE){
    $m = partialToMonth($partial);
  }
  if(strpos($format, 'DD') !== FALSE){
    $d = partialToDay($partial);
  }

  $y = $y ? $y : '00';
  $m = $m ? $m : '00';
  $d = $d ? $d : '00';

  $date = '';

  if ($y == '00' && $stripZeros) {
    return '';
  }
  else {
    $date = $y;
  }

  if ($m == '00' && $stripZeros) {
    return $date;
  }
  else {
    $date .= "-" . $m;
  }

  if ($d == '00' && $stripZeros) {
    return $date;
  }
  else {
    $date .= "-" . $d;
  }
  return $date;
}

/**
 * Converts a time period to a string.
 *
 * See also partialToDate($partial, $stripZeros).
 *
 * @param object $period
 *   An JodaTime org.joda.time.Period object.
 * @param bool $stripZeros
 *   If set to True, the zero (00) month and days will be hidden:
 *   eg 1956-00-00 becomes 1956. The default is TRUE.
 * @param string @format
 * 	 Can ve used to specify the format of the date string, currently the following format strings are supported
 *    - "YYYY": Year only
 *    - "YYYY-MM-DD": this is the default
 *
 * @return string
 *   Returns a date in the form of a string.
 */
function timePeriodToString($period, $stripZeros = TRUE, $format = "YYYY-MM-DD") {
  $dateString = '';
  if($period->freeText){
    $dateString = $period->freeText;
  } else {
    if ($period->start) {
      $dateString = partialToDate($period->start, $stripZeros, $format);
    }
    if ($period->end) {
      $dateString .= (strlen($dateString) > 0 ? ' ' . t('to') . ' ' : '') . partialToDate($period->end, $stripZeros, $format);
    }
  }
  return $dateString;
}

/**
 * returns the earliest date available in the $period in a normalized
 * form suitable for sorting, e.g.:
 *
 *  - 1956-00-00
 *  - 0000-00-00
 *  - 1957-03-00
 *
 * that is either the start date is returned if set otherwise the
 * end date
 *
 * @param  $period
 *    An JodaTime org.joda.time.Period object.
 * @return string normalized form of the date
 *   suitable for sorting
 */
function timePeriodAsOrderKey($period) {
  $dateString = '';
  if ($period->start) {
    $dateString = partialToDate($period->start, false);
  }
  if ($period->end) {
    $dateString .= partialToDate($period->end, false);
  }
  return $dateString;
}

/**
 * Composes a absolute CDM web service URI with parameters and querystring.
 *
 * @param string $uri_pattern
 *   String with place holders ($0, $1, ..) that should be replaced by the
 *   according element of the $pathParameters array.
 * @param array $pathParameters
 *   An array of path elements, or a single element.
 * @param string $query
 *   A query string to append to the URL.
 *
 * @return string
 *   A complete URL with parameters to a CDM webservice.
 */
function cdm_compose_url($uri_pattern, $pathParameters = array(), $query = NULL) {
  if (empty($pathParameters)) {
    $pathParameters = array();
  }

  // (1)
  // Substitute all place holders ($0, $1, ..) in the $uri_pattern by the
  // according element of the $pathParameters array.
  static $helperArray = array();
  if (isset($pathParameters) && !is_array($pathParameters)) {
    $helperArray[0] = $pathParameters;
    $pathParameters = $helperArray;
  }

  $i = 0;
  while (strpos($uri_pattern, "$" . $i) !== FALSE) {
    if (count($pathParameters) <= $i) {
        drupal_set_message(
          t('cdm_compose_url(): missing pathParameter @index for !uri_pattern',
            array('@index' => $i, '!uri-pattern' => $uri_pattern )),
          'error');
      break;
    }
    $uri_pattern = str_replace("$" . $i, rawurlencode($pathParameters[$i]), $uri_pattern);
    ++$i;
  }

  // (2)
  // Append all remaining element of the $pathParameters array as path
  // elements.
  if (count($pathParameters) > $i) {
    // Strip trailing slashes.
    if (strrchr($uri_pattern, '/') == strlen($uri_pattern)) {
      $uri_pattern = substr($uri_pattern, 0, strlen($uri_pattern) - 1);
    }
    while (count($pathParameters) > $i) {
      $uri_pattern .= '/' . rawurlencode($pathParameters[$i]);
      ++$i;
    }
  }

  // (3)
  // Append the query string supplied by $query.
  if (isset($query)) {
    $uri_pattern .= (strpos($uri_pattern, '?') !== FALSE ? '&' : '?') . $query;
  }

  $path = $uri_pattern;

  $uri = variable_get('cdm_webservice_url', '') . $path;
  return $uri;
}

/**
 * @todo wouldn't it more elegant and secure to only pass a uuid and additional function parameters
 *     together with a theme name to such a proxy function?
 *     Well this would not be covering all use cases but maybe all which involve AHAH.
 *     Maybe we want to have two different proxy functions, one with theming and one without?
 *
 * @param string $uri
 *     A URI to a CDM Rest service from which to retrieve an object
 * @param string|null $hook
 *     (optional) The hook name to which the retrieved object should be passed.
 *     Hooks can either be a theme_hook() or compose_hook() implementation
 *     'theme' hook functions return a string whereas 'compose' hooks are returning render arrays
 *     suitable for drupal_render()
 *
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function proxy_content($uri, $hook = NULL) {

  $args = func_get_args();
  $do_gzip = function_exists('gzencode');
  $uriEncoded = array_shift($args);
  $uri = urldecode($uriEncoded);
  $hook = array_shift($args);
  $request_method = strtoupper($_SERVER["REQUEST_METHOD"]);

  $post_data = null;

  if ($request_method == "POST" || $request_method == "PUT") {
    // read response body via inputstream module
    $post_data = file_get_contents("php://input");
  }

  // Find and deserialize arrays.
  foreach ($args as &$arg) {
    // FIXME use regex to find serialized arrays.
    //       or should we accept json instead of php serializations?
    if (strpos($arg, "a:") === 0) {
      $arg = unserialize($arg);
    }
  }

  // In all these cases perform a simple get request.
  // TODO reconsider caching logic in this function.

  if (empty($hook)) {
    // simply return the webservice response
    // Print out JSON, the cache cannot be used since it contains objects.
    $http_response = cdm_http_request($uri, $request_method, $post_data);
    if (isset($http_response->headers)) {
      foreach ($http_response->headers as $hname => $hvalue) {
        drupal_add_http_header($hname, $hvalue);
      }
    }
    if (isset($http_response->data)) {
      print $http_response->data;
      flush();
    }
    exit(); // leave drupal here
  } else {
    // $hook has been supplied
    // handle $hook either as compose ot theme hook
    // pass through theme or comose hook
    // compose hooks can be called without data, therefore
    // passing the $uri in this case is not always a requirement

    if($uri && $uri != 'NULL') {
    // do a security check since the $uri will be passed
    // as absolute URI to cdm_ws_get()
      if (!_is_cdm_ws_uri($uri)) {
        drupal_set_message(
          'Invalid call of proxy_content() with callback parameter \'' . $hook . '\' and URI:' . $uri,
          'error'
        );
        return '';
      }

      $obj = cdm_ws_get($uri, NULL, $post_data, $request_method, TRUE);
    } else {
      $obj = NULL;
    }

    $reponse_data = NULL;

    if (function_exists('compose_' . $hook)){
      // call compose hook

      $elements =  call_user_func('compose_' . $hook, $obj);
      // pass the render array to drupal_render()
      $reponse_data = drupal_render($elements);
    } else {
      // call theme hook

      // TODO use theme registry to get the registered hook info and
      //    use these defaults
      switch($hook) {
        case 'cdm_taxontree':
          $variables = array(
            'tree' => $obj,
            'filterIncludes' => isset($args[0]) ? $args[0] : NULL,
            'show_filter_switch' => isset($args[1]) ? $args[1] : FALSE,
            'tree_node_callback' => isset($args[2]) ? $args[2] : FALSE,
            'element_name'=> isset($args[3]) ? $args[3] : FALSE,
            );
          $reponse_data = theme($hook, $variables);
          break;

        case 'cdm_list_of_taxa':
            $variables = array(
              'records' => $obj,
              'freetextSearchResults' => isset($args[0]) ? $args[0] : array(),
              'show_classification' => isset($args[1]) ? $args[1] : FALSE);
            $reponse_data = theme($hook, $variables);
            break;

        case 'cdm_media_caption':
          $variables = array(
          'media' => $obj,
          // $args[0] is set in taxon_image_gallery_default in
          // cdm_dataportal.page.theme.
          'elements' => isset($args[0]) ? $args[0] : array(
          'title',
          'description',
          'artist',
          'location',
          'rights',
          ),
          'fileUri' => isset($args[1]) ? $args[1] : NULL,
          );
          $reponse_data = theme($hook, $variables);
          break;

        default:
          drupal_set_message(t(
          'Theme !theme is not yet supported by the function !function.', array(
          '!theme' => $hook,
          '!function' => __FUNCTION__,
          )), 'error');
          break;
      } // END of theme hook switch
    } // END of tread as theme hook


    if($do_gzip){
      $reponse_data = gzencode($reponse_data, 2, FORCE_GZIP);
      drupal_add_http_header('Content-Encoding', 'gzip');
    }
    drupal_add_http_header('Content-Type', 'text/html; charset=utf-8');
    drupal_add_http_header('Content-Length', strlen($reponse_data));

    print $reponse_data;
  } // END of handle $hook either as compose ot theme hook

}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function setvalue_session() {
  if ($_REQUEST['var'] && strlen($_REQUEST['var']) > 4) {
    $var_keys = substr($_REQUEST['var'], 1, strlen($_REQUEST['var']) - 2);
    $var_keys = explode('][', $var_keys);
  }
  else {
    return;
  }
  $val = isset($_REQUEST['val']) ? $_REQUEST['val'] : NULL;

  // Prevent from malicous tags.
  $val = strip_tags($val);

  $session_var = &$_SESSION;
  //$i = 0;
  foreach ($var_keys as $key) {
    // $hasMoreKeys = ++$i < count($session);
    if (!isset($session_var[$key]) || !is_array($session_var[$key])) {
      $session_var[$key] = array();
    }
    $session_var = &$session_var[$key];
  }
  $session_var = $val;
  if (isset($_REQUEST['destination'])) {
    drupal_goto($_REQUEST['destination']);
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function uri_uriByProxy($uri, $theme = FALSE) {
  // usage: url('cdm_api/proxy/'.urlencode($content_url)."/$theme");)
  return url('cdm_api/proxy/' . urlencode($uri) . (isset($theme) ? "/$theme" : ''));
}

/**
 * Composes the the absolute REST service URI to the annotations pager
 * for the given CDM entity.
 *
 * NOTE: Not all CDM Base types are yet supported.
 *
 * @param $cdmBase
 *   The CDM entity to construct the annotations pager uri for
 */
function cdm_compose_annotations_uri($cdmBase) {
  if (!$cdmBase->uuid) {
    return;
  }

  $ws_base_uri = NULL;
  switch ($cdmBase->class) {
    case 'TaxonBase':
    case 'Taxon':
    case 'Synonym':
      $ws_base_uri = CDM_WS_TAXON;
      break;

    case 'TaxonNameBase':
    case 'NonViralName':
    case 'BacterialName':
    case 'BotanicalName':
    case 'CultivarPlantName':
    case 'ZoologicalName':
    case 'ViralName':
      $ws_base_uri = CDM_WS_NAME;
      break;

    case 'Media':
      $ws_base_uri = CDM_WS_MEDIA;
      break;

    case 'Reference':
      $ws_base_uri = CDM_WS_REFERENCE;
      break;

    case 'Distribution':
    case 'TextData':
    case 'TaxonInteraction':
    case 'QuantitativeData':
    case 'IndividualsAssociation':
    case 'Distribution':
    case 'CommonTaxonName':
    case 'CategoricalData':
      $ws_base_uri = CDM_WS_DESCRIPTIONELEMENT;
      break;

    case 'PolytomousKey':
    case 'MediaKey':
    case 'MultiAccessKey':
      $ws_base_uri = $cdmBase->class;
      $ws_base_uri{0} = strtolower($ws_base_uri{0});
      break;

    default:
      trigger_error(check_plain('Unsupported CDM Class - no annotations available for ' . $cdmBase->class), E_USER_ERROR);
      return;
  }
  return cdm_compose_url($ws_base_uri, array(
    $cdmBase->uuid,
    'annotations',
  ));
}

/**
 * Enter description here...
 *
 * @param string $resourceURI
 * @param int $pageSize
 *   The maximum number of entities returned per page.
 *   The default page size as configured in the cdm server
 *   will be used if set to NULL
 *   to return all entities in a single page).
 * @param int $pageNumber
 *   The number of the page to be returned, the first page has the
 *   pageNumber = 0
 * @param array $query
 *   A array holding the HTTP request query parameters for the request
 * @param string $method
 *   The HTTP method to use, valid values are "GET" or "POST"
 * @param bool $absoluteURI
 *   TRUE when the URL should be treated as absolute URL.
 *
 * @return the a CDM Pager object
 *
 */
function cdm_ws_page($resourceURI, $pageSize, $pageNumber, array $query = array(), $method = 'GET', $absoluteURI = FALSE) {

  $query['pageNumber'] = $pageNumber;
  $query['pageSize'] = $pageSize;

  return cdm_ws_get($resourceURI, NULL, queryString($query), $method, $absoluteURI);
}

/**
 * Fetches all entities from the given REST endpoint using the pager mechanism.
 *
 * @param string $resourceURI
 * @param array $query
 *   A array holding the HTTP request query parameters for the request
 * @param string $method
 *   The HTTP method to use, valid values are "GET" or "POST";
 * @param bool $absoluteURI
 *   TRUE when the URL should be treated as absolute URL.
 *
 * @return array
 *     A list of CDM entitites
 *
 */
function cdm_ws_fetch_all($resourceURI, array $query = array(), $method = 'GET', $absoluteURI = FALSE) {
  $page_index = 0;
  // using a bigger page size to avoid to many multiple requests
  $page_size = 500;
  $entities = array();

  while ($page_index !== FALSE){
    $pager =  cdm_ws_page($resourceURI, $page_size, $page_index, $query,  $method, $absoluteURI);
    if(isset($pager->records) && is_array($pager->records)) {
      $entities = array_merge($entities, $pager->records);
      if(!empty($pager->nextIndex)){
        $page_index = $pager->nextIndex;
      } else {
        $page_index = FALSE;
      }
    } else {
      $page_index = FALSE;
    }
  }
  return $entities;
}

/*
function cdm_ws_taxonomy_compose_resourcePath($path = NULL){
  $viewrank = _cdm_taxonomy_compose_viewrank();
  return CDM_WS_PORTAL_TAXONOMY . '/' . ($viewrank ? $viewrank : '' ) . ($path
  ? '/' . $path : '') ;
}
*/

/**
 * @todo Enter description here...
 *
 * @param string $taxon_uuid
 *  The UUID of a cdm taxon instance
 * @param string $ignore_rank_limit
 *   Whether to ignore the variable 'taxontree_ranklimit' set by admin in the settings
 *
 * @return string
 *   A cdm REST service URL path to a Classification
 */
function cdm_compose_taxonomy_root_level_path($taxon_uuid = FALSE, $ignore_rank_limit = FALSE) {

  $view_uuid = get_current_classification_uuid();
  $rank_uuid = NULL;
  if (!$ignore_rank_limit) {
    $rank_uuid = variable_get(TAXONTREE_RANKLIMIT, TAXONTREE_RANKLIMIT_DEFAULT);
  }

  if (!empty($taxon_uuid)) {
    return cdm_compose_url(CDM_WS_PORTAL_TAXONOMY_CHILDNODES_OF_TAXON, array(
      $view_uuid,
      $taxon_uuid,
    ));
  }
  else {
    if (is_uuid($rank_uuid)) {
      return cdm_compose_url(CDM_WS_PORTAL_TAXONOMY_CHILDNODES_AT_RANK, array(
        $view_uuid,
        $rank_uuid,
      ));
    }
    else {
      return cdm_compose_url(CDM_WS_PORTAL_TAXONOMY_CHILDNODES, array(
        $view_uuid,
      ));
    }
  }
}

/**
 * Retrieves from the cdm web service with the first level of childnodes of a classification.
 *
 * The level is either the real root level ot it is a lover level if a rank limit has been set.
 * (@see  cdm_compose_taxonomy_root_level_path() for more on the rank limit).
 *
 * Operates in two modes depending on whether the parameter
 * $taxon_uuid is set or NULL.
 *
 * A) $taxon_uuid = NULL:
 *  1. retrieve the Classification for the uuid set in the $_SESSION['cdm']['taxonomictree_uuid']
 *  2. otherwise return the default classification as defined by the admin via the settings
 *
 * b) $taxon_uuid is set:
 *   return the classification to whcih the taxon belongs to.
 *
 * @param UUID $taxon_uuid
 *   The UUID of a cdm taxon instance
 */
function cdm_ws_taxonomy_root_level($taxon_uuid = NULL) {

    $response = NULL;

    // 1st try
    $response = cdm_ws_get(cdm_compose_taxonomy_root_level_path($taxon_uuid), NULL, NULL, 'GET', TRUE);

    if ($response == NULL) {
      // 2dn try by ignoring the rank limit
      $response = cdm_ws_get(cdm_compose_taxonomy_root_level_path($taxon_uuid, TRUE), NULL, NULL, 'GET', TRUE);
    }

    if ($response == NULL) {
      // 3rd try, last fallback:
      //    return the default classification
      if (isset($_SESSION['cdm']['taxonomictree_uuid']) && is_uuid($_SESSION['cdm']['taxonomictree_uuid'])) {
        // Delete the session value and try again with the default.
        unset($_SESSION['cdm']['taxonomictree_uuid']);
        drupal_set_message("Could not find a valid classification, falling back to the default classification.", 'warning');
        return cdm_ws_taxonomy_root_level($taxon_uuid);
      }
      else {
        // Check if taxonomictree_uuid is valid.
        // expecting an array of taxonNodes,
        // empty classifications are ok so no warning in this case!
        $test = cdm_ws_get(cdm_compose_taxonomy_root_level_path(), NULL, NULL, 'GET', TRUE);
        if (!is_array($test)) {
          // The default set by the admin seems to be invalid or is not even set.
          drupal_set_message(_no_classfication_uuid_message(), 'warning');
        }
        if (count($test) == 0) {
          // The default set by the admin seems to be invalid or is not even set.
          drupal_set_message("The chosen classification is empty.", 'status');
        }
      }
    }

  return $response;
}

/**
 * Determines the tree path of the taxon given as uuid to the root of the classification tree.
 * 
 * The root either is the absolute root of the tree or a rank specific root if the TAXONTREE_RANKLIMIT
 * variable is set.
 *
 * @param string $taxon_uuid
 *
 * @return array
 *   An array of CDM TaxonNodeDTO objects
 */
function cdm_ws_taxonomy_pathFromRoot($taxon_uuid) {
  $view_uuid = get_current_classification_uuid();
  $rank_uuid = variable_get(TAXONTREE_RANKLIMIT, TAXONTREE_RANKLIMIT_DEFAULT);

  $response = NULL;
  if (is_uuid($rank_uuid)) {
    $response = cdm_ws_get(CDM_WS_PORTAL_TAXONOMY_PATH_FROM_TO_RANK, array(
      $view_uuid,
      $taxon_uuid,
      $rank_uuid,
    ));
  }
  else {
    $response = cdm_ws_get(CDM_WS_PORTAL_TAXONOMY_PATH_FROM, array(
      $view_uuid,
      $taxon_uuid,
    ));
  }

  if ($response == NULL) {
    // Error handing.
//    if (is_uuid($_SESSION['cdm']['taxonomictree_uuid'])) {
//      // Delete the session value and try again with the default.
//      unset($_SESSION['cdm']['taxonomictree_uuid']);
//      return cdm_ws_taxonomy_pathFromRoot($taxon_uuid);
//    }
//    else {
      // Check if taxonomictree_uuid is valid.
      $test = cdm_ws_get(cdm_compose_taxonomy_root_level_path(), NULL, NULL, 'GET', TRUE);
      if ($test == NULL) {
        // The default set by the admin seems to be invalid or is not even set.
        drupal_set_message(_no_classfication_uuid_message(), 'warning');
      }
//    }
  }

  return $response;
}


// =============================Terms and Vocabularies ========================================= //

/**
 * Returns the localized representation for the given term.
 *
 * @param Object $definedTermBase
 * 	  of cdm type DefinedTermBase
 * @return string
 * 	  the localized representation_L10n of the term,
 *    otherwise the titleCache as fall back,
 *    otherwise the default_representation which defaults to an empty string
 */
function cdm_term_representation($definedTermBase, $default_representation = '') {
  if ( isset($definedTermBase->representation_L10n) ) {
    return $definedTermBase->representation_L10n;
  } elseif ( isset($definedTermBase->titleCache)) {
    return $definedTermBase->titleCache;
  }
  return $default_representation;
}

/**
 * Returns the abbreviated localized representation for the given term.
 *
 * @param Object $definedTermBase
 * 	  of cdm type DefinedTermBase
 * @return string
 * 	  the localized representation_L10n_abbreviatedLabel of the term,
 *    if this representation is not available the function delegates the
 *    call to cdm_term_representation()
 */
function cdm_term_representation_abbreviated($definedTermBase, $default_representation = '') {
  if ( isset($definedTermBase->representation_L10n_abbreviatedLabel) ) {
    return $definedTermBase->representation_L10n_abbreviatedLabel;
  } else {
    cdm_term_representation($definedTermBase, $default_representation);
  }
}

/**
 * Transforms the list of the given term base instances to a alphabetical ordered options array.
 *
 * The options array is suitable for drupal form API elements that allow multiple choices.
 * @see http://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7#options
 *
 * @param array $terms
 *   a list of CDM DefinedTermBase instances
 *
 * @param $term_label_callback
 *   A callback function to override the term representations
 *
 * @return array
 *   the terms in an array as options for a form element that allows multiple choices.
 */
function cdm_terms_as_options($terms, $term_label_callback = NULL){
  $options = array();
  if(isset($terms) && is_array($terms)) {
    foreach ($terms as $term) {
      if ($term_label_callback && function_exists($term_label_callback)) {
        $options[$term->uuid] = call_user_func($term_label_callback, $term);
      } else {
        //TODO use cdm_term_representation() here?
        $options[$term->uuid] = t('@term', array('@term' => $term->representation_L10n));
      }
    }
  }

  return $options;
}

/**
 * Creates and array of options for drupal select form elements.
 *
 * @param $vocabulary_uuid
 *   The UUID of the CDM Term Vocabulary
 * @param $term_label_callback
 *   An optional call back function which can be used to modify the term label
 * @param bool $default_option
 *   An additional element do be placed at the beginning og the list. This element will be the default option.
 *   In order to put an empty element the beginning of the options pass an " " as argument.
 * @param array $include_filter
 *   An associative array consisting of a field name an regular expression. All term matching
 *   these filter are included. The value of the field is converted to a String by var_export()
 *   so a boolean 'true' can be matched by '/true/'
 * @param string $order_by
 *   One of the order by constants defined in this file
 * @return mixed
 */
function cdm_vocabulary_as_option($vocabulary_uuid, $term_label_callback = NULL, $default_option = FALSE,
                                  array $include_filter = null, $order_by = CDM_ORDER_BY_ORDER_INDEX_ASC) {

  static $vocabularyOptions = array();

  if (!isset($vocabularyOptions[$vocabulary_uuid])) {
    $terms = cdm_ws_fetch_all('termVocabulary/' . $vocabulary_uuid . '/terms',
      array(
        'orderBy' => $order_by
      )
    );

    // apply the include filter
    if($include_filter != null){
      $included_terms = array();

      foreach ($terms as $term){
        $include = true;
        foreach ($include_filter as $field=>$regex){
          $include =  preg_match($regex, var_export($term->$field, true)) === 1;
          if(!$include){
            break;
          }
        }
        if($include){
          $included_terms[] = $term;
        }
      }

      $terms = $included_terms;
    }

    // make options list
    $vocabularyOptions[$vocabulary_uuid] = cdm_terms_as_options($terms, $term_label_callback);
  }

  $options = $vocabularyOptions[$vocabulary_uuid];
  if($default_option !== FALSE){
    array_unshift ($options, "");
  }
  return $options;
}

/**
 * @param $term_type one of
 *  - Unknown
 *  - Language
 *  - NamedArea
 *  - Rank
 *  - Feature
 *  - AnnotationType
 *  - MarkerType
 *  - ExtensionType
 *  - DerivationEventType
 *  - PresenceAbsenceTerm
 *  - NomenclaturalStatusType
 *  - NameRelationshipType
 *  - HybridRelationshipType
 *  - SynonymRelationshipType
 *  - TaxonRelationshipType
 *  - NameTypeDesignationStatus
 *  - SpecimenTypeDesignationStatus
 *  - InstitutionType
 *  - NamedAreaType
 *  - NamedAreaLevel
 *  - RightsType
 *  - MeasurementUnit
 *  - StatisticalMeasure
 *  - MaterialOrMethod
 *  - Material
 *  - Method
 *  - Modifier
 *  - Scope
 *  - Stage
 *  - KindOfUnit
 *  - Sex
 *  - ReferenceSystem
 *  - State
 *  - NaturalLanguageTerm
 *  - TextFormat
 *  - DeterminationModifier
 *  - DnaMarker
 *
 * @param  $order_by
 *  Optionally sort option (default: CDM_ORDER_BY_TITLE_CACHE_ASC)
 *  possible values:
 *    - CDM_ORDER_BY_ID_ASC
 *    - CDM_ORDER_BY_ID_DESC
 *    - CDM_ORDER_BY_TITLE_CACHE_ASC
 *    - CDM_ORDER_BY_TITLE_CACHE_DESC
 *    - CDM_ORDER_BY_ORDER_INDEX_ASC (can only be used with OrderedTerms!!)
 *    - CDM_ORDER_BY_ORDER_INDEX_DESC (can only be used with OrderedTerms!!)
 */
function cdm_terms_by_type_as_option($term_type, $order_by = CDM_ORDER_BY_TITLE_CACHE_ASC, $term_label_callback = NULL){
  $terms = cdm_ws_fetch_all(
    CDM_WS_TERM,
    array(
      'class' => $term_type,
      'orderBy' => $order_by
    )
  );
  return cdm_terms_as_options($terms, $term_label_callback);
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_rankVocabulary_as_option() {
  $options = cdm_vocabulary_as_option(UUID_RANK, NULL, false);
  return $options;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function _cdm_relationship_type_term_label_callback($term) {
  if (isset($term->representation_L10n_abbreviatedLabel)) {
    return $term->representation_L10n_abbreviatedLabel . ' : '
    . t('@term', array('@term' => $term->representation_L10n));
  }
else {
    return t('@term', array('@term' => $term->representation_L10n));
  }
}

// ========================================================================================== //
/**
 * @todo Improve documentation of this function.
 *
 * eu.etaxonomy.cdm.model.description.
 * CategoricalData
 * CommonTaxonName
 * Distribution
 * IndividualsAssociation
 * QuantitativeData
 * TaxonInteraction
 * TextData
 */
function cdm_descriptionElementTypes_as_option($prependEmptyElement = FALSE) {
  static $types = array(
    "CategoricalData",
    "CommonTaxonName",
    "Distribution",
    "IndividualsAssociation",
    "QuantitativeData",
    "TaxonInteraction",
    "TextData",
  );

  static $options = NULL;
  if ($options == NULL) {
    $options = array();
    if ($prependEmptyElement) {
      $options[' '] = '';
    }
    foreach ($types as $type) {
      // No internatianalization here since these are purely technical terms.
      $options["eu.etaxonomy.cdm.model.description." . $type] = $type;
    }
  }
  return $options;
}


/**
 * Fetches all TaxonDescription descriptions elements which are associated to the
 * Taxon specified by the $taxon_uuid and merges the elements into the given
 * feature tree.
 * @param $feature_tree
 *     The CDM FeatureTree to be used as template
 * @param $taxon_uuid
 *     The UUID of the taxon
 * @param $excludes
 *     UUIDs of features to be excluded
 * @return$feature_tree
 *     The CDM FeatureTree which was given as parameter merged tree whereas the
 *     CDM FeatureNodes are extended by an additional field 'descriptionElements'
 *     witch will hold the according $descriptionElements.
 */
function cdm_ws_descriptions_by_featuretree($feature_tree, $taxon_uuid, $exclude_uuids = array()) {

  if (!$feature_tree) {
    drupal_set_message(check_plain(t("No 'FeatureTree' has been set so far.
      In order to see the species profiles of your taxa, please select a
      'FeatureTree' in the !settings"), array('!settings' => l(t('CDM Dataportal Settings'), 'admin/config/cdm_dataportal/layout'))), 'warning');
    return FALSE;
  }

  $description_elements = cdm_ws_fetch_all(CDM_WS_DESCRIPTIONELEMENT_BY_TAXON,
      array(
      'taxon' => $taxon_uuid,
      'features' => cdm_featureTree_elements_toString($feature_tree->root, ',', 'uuid', $exclude_uuids)
      ),
      'POST'
  );

  // Combine all descriptions into one feature tree.
  $merged_nodes = _mergeFeatureTreeDescriptions($feature_tree->root->childNodes, $description_elements);
  $feature_tree->root->childNodes = $merged_nodes;

  return $feature_tree;
}

/**
 * Returns a filtered a list of annotations for the cdm entity given as parameter $cdmBase.
 * If the annotations are not yet already loded with the cdm entity the cdm REST service will
 * be requested for the annotations.
 *
 * @param string $cdmBase
 *   An annotatable cdm entity.
 * @param array $includeTypes
 *   If an array of annotation type uuids is supplied by this parameter the
 *   list of annotations is resticted to those which belong to this type.
 *
 * @return array
 *   An array of Annotation objects or an empty array.
 */
function cdm_ws_getAnnotationsFor(&$cdmBase, $includeTypes = FALSE) {

  if(!isset($cdmBase->annotations)){
    $annotationUrl = cdm_compose_annotations_uri($cdmBase);
    $cdmBase->annotations = cdm_ws_fetch_all($annotationUrl, array(), 'GET', TRUE);
  }

  $annotations = array();
  foreach ($cdmBase->annotations as $annotation) {
    if ($includeTypes) {
      if (
        ( isset($annotation->annotationType->uuid) && in_array($annotation->annotationType->uuid, $includeTypes, TRUE) )
        || ($annotation->annotationType === NULL && in_array('NULL_VALUE', $includeTypes, TRUE))
      ) {
        $annotations[] = $annotation;
      }
    }
    else {
      $annotations[] = $annotation;
    }
  }
  return $annotations;

}

/**
 * Loads the annotations from the REST service an adds them as field to the given $annotatable_entity.
 *
 * @param object $annotatable_entity
 *   The CDM AnnotatableEntity to load annotations for
 */
function cdm_load_annotations(&$annotatable_entity) {
  if (isset($annotatable_entity) && !isset($annotatable_entity->annotations)) {
    $annotations = cdm_ws_getAnnotationsFor($annotatable_entity);
    if (is_array($annotations)) {
      $annotatable_entity->annotations = $annotations;
    }
  }
}

/**
 * Get a NomenclaturalReference string.
 *
 * Returns the NomenclaturalReference string with correctly placed
 * microreference (= reference detail) e.g.
 * in Phytotaxa 43: 1-48. 2012.
 *
 * @param string $referenceUuid
 *   UUID of the reference.
 * @param string $microreference
 *   Reference detail.
 *
 * @return string
 *   a NomenclaturalReference.
 */
function cdm_ws_getNomenclaturalReference($referenceUuid, $microreference) {

  // TODO the below statement avoids error boxes due to #4644 remove it once this ticket is solved
  if(is_array($microreference) || is_object($microreference)) {
    return '';
  }

  $obj = cdm_ws_get(CDM_WS_NOMENCLATURAL_REFERENCE_CITATION, array(
    $referenceUuid,
  ), "microReference=" . urlencode($microreference));

  if ($obj) {
    return $obj->String;
  }
  else {
    return NULL;
  }
}

/**
 * finds and returns the FeatureNode denoted by the given $feature_uuid
 *
 * @param $feature_tree_nodes
 *    The nodes contained in CDM FeatureTree entitiy: $feature->root->childNodes
 * @param $feature_uuid
 *    The UUID of the Feature
 * @return returns the FeatureNode or null
 */
function &cdm_feature_tree_find_node($feature_tree_nodes, $feature_uuid){

  // 1. scan this level
  foreach ($feature_tree_nodes as $node){
    if($node->feature->uuid == $feature_uuid){
      return $node;
    }
  }

  // 2. descend into childen
  foreach ($feature_tree_nodes as $node){
    if(is_array($node->childNodes)){
      $node = cdm_feature_tree_find_node($node->childNodes, $feature_uuid);
      if($node) {
        return $node;
      }
    }
  }
  $null_var = null; // kludgy workaround to avoid "PHP Notice: Only variable references should be returned by reference"
  return $null_var;
}

/**
 * Merges the given featureNodes structure with the descriptionElements.
 *
 * This method is used in preparation for rendering the descriptionElements.
 * The descriptionElements which belong to a specific feature node are appended
 * to a the feature node by creating a new field:
 *  - descriptionElements: the CDM DescriptionElements which belong to this feature
 * The descriptionElements will be cleared in advance in order to allow reusing the
 * same feature tree without the risk of mixing sets of description elements.
 *
 * which originally is not existing in the cdm.
 *
 *
 *
 * @param array $featureNodes
 *    An array of cdm FeatureNodes which may be hierarchical since feature nodes
 *    may have children.
 * @param array $descriptionElements
 *    An flat array of cdm DescriptionElements
 * @return array
 *    The $featureNodes structure enriched with the according $descriptionElements
 */
function _mergeFeatureTreeDescriptions($featureNodes, $descriptionElements) {

  foreach ($featureNodes as &$node) {
    // since the $featureNodes array is reused for each description
    // it is necessary to clear the custom node fields in advance
    if(isset($node->descriptionElements)){
      unset($node->descriptionElements);
    }

    // Append corresponding elements to an additional node field:
    // $node->descriptionElements.
    foreach ($descriptionElements as $element) {
      if ($element->feature->uuid == $node->feature->uuid) {
        if (!isset($node->descriptionElements)) {
          $node->descriptionElements = array();
        }
        $node->descriptionElements[] = $element;
      }
    }

    // Recurse into node children.
    if (isset($node->childNodes[0])) {
      $mergedChildNodes = _mergeFeatureTreeDescriptions($node->childNodes, $descriptionElements);
      $node->childNodes = $mergedChildNodes;
    }

    if(!isset($node->descriptionElements) && !isset($node->childNodes[0])){
      unset($node);
    }

  }

  return $featureNodes;
}

/**
 * Sends a GET or POST request to a CDM RESTService and returns a de-serialized object.
 *
 * The response from the HTTP GET request is returned as object.
 * The response objects coming from the webservice configured in the
 * 'cdm_webservice_url' variable are being cached in a level 1 (L1) and / or
 *  in a level 2 (L2) cache.
 *
 * Since the L1 cache is implemented as static variable of the cdm_ws_get()
 * function, this cache persists only per each single page execution.
 * Any object coming from the webservice is stored into it by default.
 * In contrast to this default caching mechanism the L2 cache only is used if
 * the 'cdm_webservice_cache' variable is set to TRUE,
 * which can be set using the modules administrative settings section.
 * Objects stored in this L2 cache are serialized and stored
 * using the drupal cache in the '{prefix}cache_cdm_ws' cache table. So the
 * objects that are stored in the database will persist as
 * long as the drupal cache is not being cleared and are available across
 * multiple script executions.
 *
 * @param string $uri
 *   URL to the webservice.
 * @param array $pathParameters
 *   An array of path parameters.
 * @param string $query
 *   A query string to be appended to the URL.
 * @param string $method
 *   The HTTP method to use, valid values are "GET" or "POST";
 * @param bool $absoluteURI
 *   TRUE when the URL should be treated as absolute URL.
 *
 * @return object| array
 *   The de-serialized webservice response object.
 */
function cdm_ws_get($uri, $pathParameters = array(), $query = NULL, $method = "GET", $absoluteURI = FALSE) {

  static $cacheL1 = array();

  $data = NULL;
  // store query string in $data and clear the query, $data will be set as HTTP request body
  if($method == 'POST'){
    $data = $query;
    $query = NULL;
  }

  // Transform the given uri path or pattern into a proper webservice uri.
  if (!$absoluteURI) {
    $uri = cdm_compose_url($uri, $pathParameters, $query);
  }

  // read request parameter 'cacheL2_refresh'
  // which allows refreshing the level 2 cache
  $do_cacheL2_refresh = isset($_REQUEST['cacheL2_refresh']) && $_REQUEST['cacheL2_refresh'] == 1;

  $is_cdm_ws_uri = _is_cdm_ws_uri($uri);
  $use_cacheL2 = variable_get('cdm_webservice_cache', 1);

  if($method == 'GET'){
    $cache_key = $uri;
  } else {
    // sha1 creates longer hashes and thus will cause fewer collisions than md5.
    // crc32 is faster but creates much shorter hashes
    $cache_key = $uri . '[' . $method . ':' . sha1($data) .']';
  }

  if (array_key_exists($cache_key, $cacheL1)) {
    $cacheL1_obj = $cacheL1[$uri];
  }

  $set_cacheL1 = FALSE;
  if ($is_cdm_ws_uri && !isset($cacheL1_obj)) {
    $set_cacheL1 = TRUE;
  }

  // Only cache cdm webservice URIs.
  $set_cacheL2 = $use_cacheL2 && $is_cdm_ws_uri && $set_cacheL1;
  $cacheL2_entry = FALSE;

  if ($use_cacheL2 && !$do_cacheL2_refresh) {
    // Try to get object from cacheL2.
    $cacheL2_entry = cache_get($cache_key, 'cache_cdm_ws');
  }

  if (isset($cacheL1_obj)) {
    //
    // The object has been found in the L1 cache.
    //
    $obj = $cacheL1_obj;
    if (cdm_debug_block_visible()) {
      cdm_ws_debug_add($uri, $method, $data, 0, 0, NULL, 'cacheL1');
    }
  }
  elseif ($cacheL2_entry) {
    //
    // The object has been found in the L2 cache.
    //
    $duration_parse_start = microtime(TRUE);
    $obj = unserialize($cacheL2_entry->data);
    $duration_parse = microtime(TRUE) - $duration_parse_start;

    if (cdm_debug_block_visible()) {
      cdm_ws_debug_add($uri, $method, $data, 0, $duration_parse, NULL, 'cacheL2');
    }
  }
  else {
    //
    // Get the object from the webservice and cache it.
    //
    $duration_fetch_start = microtime(TRUE);
    // Request data from webservice JSON or XML.
    $response = cdm_http_request($uri, $method, $data);
    $response_body = NULL;
    if (isset($response->data)) {
      $response_body = $response->data;
    }
    $duration_fetch = microtime(TRUE) - $duration_fetch_start;
    $duration_parse_start = microtime(TRUE);

    // Parse data and create object.
    $obj = cdm_load_obj($response_body);

    $duration_parse = microtime(TRUE) - $duration_parse_start;

    if (cdm_debug_block_visible()) {
      if ($obj || $response_body == "[]") {
        $status = 'valid';
      }
      else {
        $status = 'invalid';
      }
      cdm_ws_debug_add($uri, $method, $data, $duration_fetch, $duration_parse, strlen($response_body), $status);
    }
    if ($set_cacheL2) {
      // Store the object in cache L2.
      // Comment @WA perhaps better if Drupal serializedatas here? Then the
      // flag serialized is set properly in the cache table.
      cache_set($cache_key, serialize($obj), 'cache_cdm_ws', CACHE_TEMPORARY);
    }
  }
  if ($obj) {
    // Store the object in cache L1.
    if ($set_cacheL1) {
      $cacheL1[$cache_key] = $obj;
    }
  }
  return $obj;
}

/**
 * Processes and stores the given information in $_SESSION['cdm']['ws_debug'] as table row.
 *
 * The cdm_ws_debug block will display the debug information.
 *
 * @param $uri
 *    The CDM REST URI to which the request has been send
 * @param string $method
 *    The HTTP request method, either 'GET' or 'POST'
 * @param string $post_data
 *    The datastring send with a post request
 * @param $duration_fetch
 *    The time in seconds it took to fetch the data from the web service
 * @param $duration_parse
 *    Time in seconds which was needed to parse the json response
 * @param $datasize
 *    Size of the data received from the server
 * @param $status
 *    A status string, possible values are: 'valid', 'invalid', 'cacheL1', 'cacheL2'
 * @return bool
 *    TRUE if adding the debug information was successful
 */
function cdm_ws_debug_add($uri, $method, $post_data, $duration_fetch, $duration_parse, $datasize, $status) {

  static $initial_time = NULL;
  if(!$initial_time) {
    $initial_time = microtime(TRUE);
  }
  $time = microtime(TRUE) - $initial_time;

  // Decompose uri into path and query element.
  $uri_parts = explode("?", $uri);
  $query = array();
  if (count($uri_parts) == 2) {
    $path = $uri_parts[0];
  }
  else {
    $path = $uri;
  }

  if(strpos($uri, '?') > 0){
    $json_uri = str_replace('?', '.json?', $uri);
    $xml_uri = str_replace('?', '.xml?', $uri);
  } else {
    $json_uri = $uri . '.json';
    $xml_uri = $json_uri . '.xml';
  }

  // data links to make data accecsible as json and xml
  $data_links = '';
  if (_is_cdm_ws_uri($path)) {

    // see ./js/http-method-link.js

    if($method == 'GET'){
      $data_links .= '<a href="' . $xml_uri . '" target="data">xml</a>-';
      $data_links .= '<a href="' . url('cdm_api/proxy/' . urlencode($xml_uri)) . '" target="data">proxied</a>';
      $data_links .= '<br/>';
      $data_links .= '<a href="' . $json_uri . '" target="data">json</a>-';
      $data_links .= '<a href="' . url('cdm_api/proxy/' . urlencode($json_uri)) . '" target="data">proxied</a>';
    } else {
      $js_link_activation = 'class="http-' . $method . '-link" data-cdm-http-post="' . $post_data . '" type="application/x-www-form-urlencoded"';
      $data_links .= '<a ' . $js_link_activation . ' href="' . url('cdm_api/proxy/' . urlencode($xml_uri)) . '" target="data">xml-proxied</a>';
      $data_links .= '<br/>';
      $data_links .= '<a ' . $js_link_activation . ' href="' . url('cdm_api/proxy/' . urlencode($json_uri)) . '" target="data">json-proxied</a>';
    }
  }
  else {
    $data_links .= '<a href="' . $uri . '" target="data">open</a>';
  }

  //
  $data = array(
      'ws_uri' => $uri,
      'method' => $method,
      'post_data' => $post_data,
      'time' => sprintf('%3.3f', $time),
      'fetch_seconds' => sprintf('%3.3f', $duration_fetch),
      'parse_seconds' => sprintf('%3.3f', $duration_parse),
      'size_kb' => sprintf('%3.1f', ($datasize / 1024)) ,
      'status' => $status,
      'data_links' => $data_links
  );
  if (!isset($_SESSION['cdm']['ws_debug'])) {
    $_SESSION['cdm']['ws_debug'] = array();
  }
  $_SESSION['cdm']['ws_debug'][] = serialize($data);

  // Mark this page as being uncacheable.
  // taken over from drupal_get_messages() but it is unsure if we really need this here
  drupal_page_is_cacheable(FALSE);

  // Messages not set when DB connection fails.
  return isset($_SESSION['cdm']['ws_debug']) ? $_SESSION['cdm']['ws_debug'] : NULL;
}

/**
 * helper function to dtermine if the cdm_debug_block should be displayed or not
 * the visibility depends on whether
 *  - the block is enabled
 *  - the visibility restrictions in the block settings are satisfied
 */
function cdm_debug_block_visible() {
  static $is_visible = null;

  if($is_visible === null){
      $block = block_load('cdm_api', 'cdm_ws_debug');
      $is_visible = isset($block->status) && $block->status == 1;
      if($is_visible){
        $blocks = array($block);
        // Checks the page, user role, and user-specific visibilty settings.
        block_block_list_alter($blocks);
        $is_visible = count($blocks) > 0;
      }
  }
  return $is_visible;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_load_obj($response_body) {
  $obj = json_decode($response_body);

  if (!(is_object($obj) || is_array($obj))) {
    ob_start();
    $obj_dump = ob_get_contents();
    ob_clean();
    return FALSE;
  }

  return $obj;
}

/**
 * Do a http request to a CDM RESTful web service.
 *
 * @param string $uri
 *   The webservice url.
 * @param string $method
 *   The HTTP method to use, valid values are "GET" or "POST"; defaults to
 *   "GET" even if NULL, FALSE or any invalid value is supplied.
 * @param $data: A string containing the request body, formatted as
 *     'param=value&param=value&...'. Defaults to NULL.
 *
 * @return object
 *   The object as returned by drupal_http_request():
 *   An object that can have one or more of the following components:
 *   - request: A string containing the request body that was sent.
 *   - code: An integer containing the response status code, or the error code
 *     if an error occurred.
 *   - protocol: The response protocol (e.g. HTTP/1.1 or HTTP/1.0).
 *   - status_message: The status message from the response, if a response was
 *     received.
 *   - redirect_code: If redirected, an integer containing the initial response
 *     status code.
 *   - redirect_url: If redirected, a string containing the URL of the redirect
 *     target.
 *   - error: If an error occurred, the error message. Otherwise not set.
 *   - headers: An array containing the response headers as name/value pairs.
 *     HTTP header names are case-insensitive (RFC 2616, section 4.2), so for
 *     easy access the array keys are returned in lower case.
 *   - data: A string containing the response body that was received.
 */
function cdm_http_request($uri, $method = "GET", $data = NULL) {
  static $acceptLanguage = NULL;
  $header = array();
  
  if(!$acceptLanguage && module_exists('i18n')){
    $acceptLanguage = i18n_language_content()->language;
  }

  if (!$acceptLanguage) {
    if (function_exists('apache_request_headers')) {
      $headers = apache_request_headers();
      if (isset($headers['Accept-Language'])) {
        $acceptLanguage = $headers['Accept-Language'];
      }
    }
  }

  if ($method != "GET" && $method != "POST") {
    drupal_set_message('cdm_api.module#cdm_http_request() : unsupported HTTP request method ', 'error');
  }

  if (_is_cdm_ws_uri($uri)) {
    $header['Accept'] = 'application/json';
    $header['Accept-Language'] = $acceptLanguage;
    $header['Accept-Charset'] = 'UTF-8';
  }

  if($method == "POST") {
    // content type is application/x-www-form-urlencoded, so the request body uses the same format as the query string
    $header['Content-Type'] = 'application/x-www-form-urlencoded';
  }


  cdm_dd($uri);
  return drupal_http_request($uri, array(
      'headers' => $header,
      'method' => $method,
      'data' => $data,
      'timeout' => CDM_HTTP_REQUEST_TIMEOUT
      )
   );
}

/**
 * Concatenates recursively the fields of all features contained in the given
 * CDM FeatureTree root node.
 *
 * @param $rootNode
 *     A CDM FeatureTree node
 * @param
 *     The character to be used as glue for concatenation, default is ', '
 * @param $field_name
 *     The field name of the CDM Features
 * @param $excludes
 *     Allows defining a set of values to be excluded. This refers to the values
 *     in the field denoted by the $field_name parameter
 *
 */
function cdm_featureTree_elements_toString($root_node, $separator = ', ', $field_name = 'representation_L10n', $excludes = array()) {
  $out = '';

  $pre_child_separator = $separator;
  $post_child_separator = '';

  foreach ($root_node->childNodes as $feature_node) {
    $out .= ($out ? $separator : '');
    if(!in_array($feature_node->feature->$field_name, $excludes)) {
      $out .= $feature_node->feature->$field_name;
      if (is_array($feature_node->childNodes) && count($feature_node->childNodes) > 0) {
        $childlabels = cdm_featureTree_elements_toString($feature_node, $separator, $field_name);
        if (strlen($childlabels)) {
            $out .=  $pre_child_separator . $childlabels . $post_child_separator;
        }
      }
    }
  }
  return $out;
}

/**
 * Create a one-dimensional form options array.
 *
 * Creates an array of all features in the feature tree of feature nodes,
 * the node labels are indented by $node_char and $childIndent depending on the
 * hierachy level.
 *
 * @param - $rootNode
 * @param - $node_char
 * @param - $childIndentStr
 * @param - $childIndent
 *   ONLY USED INTERNALLY!
 *
 * @return array
 *   A one dimensional Drupal form options array.
 */
function _featureTree_nodes_as_feature_options($rootNode, $node_char = "&#9500;&#9472; ", $childIndentStr = '&nbsp;', $childIndent = '') {
  $options = array();
  foreach ($rootNode->childNodes as $featureNode) {
    $indent_prefix = '';
    if ($childIndent) {
      $indent_prefix = $childIndent . $node_char . " ";
    }
    $options[$featureNode->feature->uuid] = $indent_prefix . $featureNode->feature->representation_L10n;
    if (isset($featureNode->childNodes) && is_array($featureNode->childNodes)) {
      // Foreach ($featureNode->childNodes as $childNode){
      $childList = _featureTree_nodes_as_feature_options($featureNode, $node_char, $childIndentStr, $childIndent . $childIndentStr);
      $options = array_merge_recursive($options, $childList);
      // }
    }
  }
  return $options;
}

/**
 * Returns an array with all available FeatureTrees and the representations of the selected
 * FeatureTree as a detail view.
 *
 * @param boolean $add_default_feature_free
 * @return array
 *  associative array with following keys:
 *  -options: Returns an array with all available Feature Trees
 *  -treeRepresentations: Returns representations of the selected Feature Tree as a detail view
 *
 */
function cdm_get_featureTrees_as_options($add_default_feature_free = FALSE) {

  $options = array();
  $tree_representations = array();
  $feature_trees = array();

  // Set tree that contains all features.
  if ($add_default_feature_free) {
    $options[UUID_DEFAULT_FEATURETREE] = t('Default Featuretree (contains all features)');
    $feature_trees[] = cdm_ws_get(CDM_WS_FEATURETREE, UUID_DEFAULT_FEATURETREE);
  }

  // Get feature trees from database.
  $persited_trees = cdm_ws_fetch_all(CDM_WS_FEATURETREES);
  if (is_array($persited_trees)) {
    $feature_trees = array_merge($feature_trees, $persited_trees);
  }

  foreach ($feature_trees as $featureTree) {

    if(!is_object($featureTree)){
      continue;
    }
    // Do not add the DEFAULT_FEATURETREE again,
    if ($featureTree->uuid != UUID_DEFAULT_FEATURETREE) {
      $options[$featureTree->uuid] = $featureTree->titleCache;
    }

    // Render the hierarchic tree structure
    if (is_array( $featureTree->root->childNodes) && count( $featureTree->root->childNodes) > 0) {

      // Render the hierarchic tree structure.
      $treeDetails = '<div class="featuretree_structure">'
        . theme('FeatureTree_hierarchy', array('FeatureTreeUuid' =>  $featureTree->uuid))
        . '</div>';

      $form = array();
      $form['featureTree-' .  $featureTree->uuid] = array(
        '#type' => 'fieldset',
        '#title' => 'Show details',
        '#attributes' => array('class' => array('collapsible collapsed')),
        // '#collapsible' => TRUE,
        // '#collapsed' => TRUE,
      );
      $form['featureTree-' .  $featureTree->uuid]['details'] = array(
        '#markup' => $treeDetails,
      );

      $tree_representations[$featureTree->uuid] = drupal_render($form);
    }

  } // END loop over feature trees

  // return $options;
  return array('options' => $options, 'treeRepresentations' => $tree_representations);
}

/**
 * Provides the list of available classifications in form of an options array.
 *
 * The options array is suitable for drupal form API elements that allow multiple choices.
 * @see http://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7#options
 *
 * The classifications are ordered alphabetically whereas the classification
 * chosen as default will always appear on top of the array, followed by a
 * blank line below.
 *
 * @param bool $add_none_option
 *   is true an addtional 'none' option will be added, optional parameter, defaults to FALSE
 *
 * @return array
 *   classifications in an array as options for a form element that allows multiple choices.
 */
function cdm_get_taxontrees_as_options($add_none_option = FALSE) {

  $taxonTrees = cdm_ws_fetch_all(CDM_WS_PORTAL_TAXONOMY);

  $default_classification_uuid = variable_get(CDM_TAXONOMICTREE_UUID, FALSE);
  $default_classification_label = '';

  // add all classifications
  $taxonomic_tree_options = array();
  if ($add_none_option) {
    $taxonomic_tree_options['NONE'] = ' '; // one Space character at beginning to force on top;
  }
  if ($taxonTrees) {
    foreach ($taxonTrees as $tree) {
      if (!$default_classification_uuid || $default_classification_uuid != $tree->uuid) {
        $taxonomic_tree_options[$tree->uuid] = $tree->titleCache;
      } else {
        $taxonomic_tree_options[$tree->uuid] = '  '; // two Space characters to force on top but below 'none' option , will be replaced below by titleCache
        $default_classification_label = $tree->titleCache;
      }
    }
  }
  // oder alphabetically the space
  asort($taxonomic_tree_options);

  // now set the labels
  //   for none
  if ($add_none_option) {
    $taxonomic_tree_options['NONE'] =t('--- ALL ---');
  }

  //   for default_classification
  if (is_uuid($default_classification_uuid)) {
    $taxonomic_tree_options[$default_classification_uuid] =
      $default_classification_label ? $default_classification_label : '--- INVALID CHOICE ---'
      . (count($taxonTrees) > 1 ? ' [' . t('DEFAULT CLASSIFICATION') . ']': '');
  }

  return $taxonomic_tree_options;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_api_secref_cache_prefetch(&$secUuids) {
  // Comment @WA: global variables should start with a single underscore
  // followed by the module and another underscore.
  global $_cdm_api_secref_cache;
  if (!is_array($_cdm_api_secref_cache)) {
    $_cdm_api_secref_cache = array();
  }
  $uniqueUuids = array_unique($secUuids);
  $i = 0;
  $param = '';
  while ($i++ < count($uniqueUuids)) {
    $param .= $secUuids[$i] . ',';
    if (strlen($param) + 37 > 2000) {
      _cdm_api_secref_cache_add($param);
      $param = '';
    }
  }
  if ($param) {
    _cdm_api_secref_cache_add($param);
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_api_secref_cache_get($secUuid) {
  global $_cdm_api_secref_cache;
  if (!is_array($_cdm_api_secref_cache)) {
    $_cdm_api_secref_cache = array();
  }
  if (!array_key_exists($secUuid, $_cdm_api_secref_cache)) {
    _cdm_api_secref_cache_add($secUuid);
  }
  return $_cdm_api_secref_cache[$secUuid];
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_api_secref_cache_clear() {
  global $_cdm_api_secref_cache;
  $_cdm_api_secref_cache = array();
}


/**
 * Validates if the given string is a uuid.
 *
 * @param string $str
 *   The string to validate.
 *
 * return bool
 *   TRUE if the string is a UUID.
 */
function is_uuid($str) {
  return is_string($str) && strlen($str) == 36 && strpos($str, '-');
}

/**
 * Checks if the given $object is a valid cdm entity.
 *
 * An object is considered a cdm entity if it has a string field $object->class
 * with at least 3 characters and if it has a valid uuid in $object->uuid.
 * The function is null save.
 *
 * @author a.kohlbecker <a.kohlbecker@bgbm.org>
 *
 * @param mixed $object
 *   The object to validate
 *
 * @return bool
 *   True if the object is a cdm entity.
 */
function is_cdm_entity($object) {
  return isset($object->class) && is_string($object->class) && strlen($object->class) > 2 && is_string($object->uuid) && is_uuid($object->uuid);
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function _cdm_api_secref_cache_add($secUuidsStr) {
  global $_cdm_api_secref_cache;
  $ref = cdm_ws_get(CDM_WS_REFERENCE, $secUuidsStr);
  // Batch fetching not jet reimplemented thus:
  /*
  $assocRefSTOs = array(); if($refSTOs) { foreach($refSTOs as $ref){
  $assocRefSTOs[$ref->uuid] = $ref; } $_cdm_api_secref_cache =
  array_merge($_cdm_api_secref_cache, $assocRefSTOs); }
  */
  $_cdm_api_secref_cache[$ref->uuid] = $ref;
}

/**
 * Checks if the given uri starts with a cdm webservice url.
 *
 * Checks if the uri starts with the cdm webservice url stored in the
 * Drupal variable 'cdm_webservice_url'.
 * The 'cdm_webservice_url' can be set in the admins section of the portal.
 *
 * @param string $uri
 *   The URI to test.
 *
 * @return bool
 *   True if the uri starts with a cdm webservice url.
 */
function _is_cdm_ws_uri($uri) {
  return str_beginsWith($uri, variable_get('cdm_webservice_url', '#EMPTY#'));
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function queryString($elements) {
  $query = '';
  foreach ($elements as $key => $value) {
    if (is_array($value)) {
      foreach ($value as $v) {
        $query .= (strlen($query) > 0 ? '&' : '') . $key . '=' . urlencode($v);
      }
    }
    else {
      $query .= (strlen($query) > 0 ? '&' : '') . $key . '=' . urlencode($value);
    }
  }
  return $query;
}

/**
 * Implementation of the magic method __clone to allow deep cloning of objects
 * and arrays.
 */
function __clone() {
  foreach ($this as $name => $value) {
    if (gettype($value) == 'object' || gettype($value) == 'array') {
      $this->$name = clone($this->$name);
    }
  }
}

/**
 * Compares the given CDM Term instances by the  representationL10n.
 *
 * Can also be used with TermDTOs. To be used in usort()
 *
 * @see http://php.net/manual/en/function.usort.php
 *
 * @param $term1
 *   The first CDM Term instance
 * @param $term2
 *   The second CDM Term instance
 * @return int
 *   The result of the comparison
 */
function compare_terms_by_representationL10n($term1, $term2) {

  if (!isset($term1->representation_L10n)) {
    $term1->representationL10n = '';
  }
  if (!isset($term2->representation_L10n)) {
    $term2->representationL10n = '';
  }

  return strcmp($term1->representation_L10n, $term2->representation_L10n);
}

function compare_terms_by_order_index($term1, $term2) {


  if (!isset($term1->orderIndex)) {
    $a = 0;
  } else {
    $a = $term1->orderIndex;
  }
  if (!isset($term2->orderIndex)) {
    $b = 0;
  } else {
    $b = $term2->orderIndex;
  }

  if ($a == $b) {
    return 0;
  }
  return ($a < $b) ? -1 : 1;

}


/**
 * Make a 'deep copy' of an array.
 *
 * Make a complete deep copy of an array replacing
 * references with deep copies until a certain depth is reached
 * ($maxdepth) whereupon references are copied as-is...
 *
 * @see http://us3.php.net/manual/en/ref.array.php
 *
 * @param array $array
 * @param array $copy passed by reference
 * @param int $maxdepth
 * @param int $depth
 */
function array_deep_copy(&$array, &$copy, $maxdepth = 50, $depth = 0) {
  if ($depth > $maxdepth) {
    $copy = $array;
    return;
  }
  if (!is_array($copy)) {
    $copy = array();
  }
  foreach ($array as $k => &$v) {
    if (is_array($v)) {
      array_deep_copy($v, $copy[$k], $maxdepth, ++$depth);
    }
    else {
      $copy[$k] = $v;
    }
  }
}

/**
 * Adds java script to create and enable a toggler for the cdm webservice debug block content.
 *
 */
function _add_js_ws_debug() {

  $data_tables_js = '/js/DataTables-1.9.4/media/js/jquery.dataTables.min.js';
  $colorbox_js = '/js/colorbox/jquery.colorbox-min.js';
  if (variable_get('cdm_js_devel_mode', FALSE)) {
    // use the developer versions of js libs
    $data_tables_js = '/js/DataTables-1.9.4/media/js/jquery.dataTables.js';
    $colorbox_js = '/js/colorbox/jquery.colorbox.js';
  }
  drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . $data_tables_js,
    array(
      'type' => 'file',
      'weight' => JS_LIBRARY,
      'cache' => TRUE)
    );

  drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . $colorbox_js,
    array(
      'type' => 'file',
      'weight' => JS_LIBRARY,
      'cache' => TRUE)
    );
  drupal_add_css(drupal_get_path('module', 'cdm_dataportal') . '/js/colorbox/colorbox.css');
  drupal_add_css(drupal_get_path('module', 'cdm_dataportal') . '/js/DataTables-1.9.4/media/css/cdm_debug_table.css');

  drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/ws_debug_block.js',
    array(
      'type' => 'file',
      'weight' => JS_LIBRARY,
      'cache' => TRUE)
    );
  drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/http-method-link.js',
    array(
    'type' => 'file',
    'weight' => JS_LIBRARY,
    'cache' => TRUE)
    );

}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function _no_classfication_uuid_message() {
  if (!cdm_ws_get(CDM_WS_PORTAL_TAXONOMY)) {
    return t('This DataPortal is not configured properly or the CDM-Server may be absent.') . ' Please check the ' . l(t('CDM web service URL'), 'admin/config/cdm_dataportal/settings/general') . t(', or contact the maintainer of this DataPortal.');
  }
  return t('This DataPortal is not configured properly.') . l(t('Please choose a valid classification'), 'admin/config/cdm_dataportal/settings/general') . t(', or contact the maintainer of this DataPortal.');
}

/**
 * Implementation of hook flush_caches
 *
 * Add custom cache tables to the list of cache tables that
 * will be cleared by the Clear button on the Performance page or whenever
 * drupal_flush_all_caches is invoked.
 *
 * @author W.Addink <waddink@eti.uva.nl>
 *
 * @return array
 *   An array with custom cache tables to include.
 */
function cdm_api_flush_caches() {
  return array('cache_cdm_ws');
}

/**
 * Logs if the drupal variable 'cdm_debug_mode' ist set true to drupal_debug.txt in the site's temp directory.
 *
 * @param $data
 *   The variable to log to the drupal_debug.txt log file.
 * @param $label
 *   (optional) If set, a label to output before $data in the log file.
 *
 * @return
 *   No return value if successful, FALSE if the log file could not be written
 *   to.
 *
 * @see cdm_dataportal_init() where the log file is reset on each requests
 * @see dd()
 * @see http://drupal.org/node/314112
 *
 */
function cdm_dd($data, $label = NULL) {
  if(module_exists('devel') && variable_get('cdm_debug_mode', FALSE) && file_stream_wrapper_get_class('temporary') ){
    return dd($data, $label);
  }
}

