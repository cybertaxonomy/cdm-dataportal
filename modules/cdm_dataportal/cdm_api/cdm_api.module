<?php
  /**
   * @file
   * Required or useful functions for using CDM Data Store Webservices.
   *
   * Naming conventions:
   * ----------------------
   * - All webservice access methods are prefixed with cdm_ws.
   *
   * @copyright
   *   (C) 2007-2012 EDIT
   *   European Distributed Institute of Taxonomy
   *   http://www.e-taxonomy.eu
   *
   *   The contents of this module are subject to the Mozilla
   *   Public License Version 1.1.
   * @see http://www.mozilla.org/MPL/MPL-1.1.html
   *
   * @author
   *   - Andreas Kohlbecker <a.kohlbecker@BGBM.org>
   *   - Wouter Addink <w.addink@eti.uva.nl> (migration from Drupal 5 to Drupal7)
   */

  module_load_include('php', 'cdm_api', 'xml2json');
  module_load_include('php', 'cdm_api', 'commons');
  module_load_include('php', 'cdm_api', 'uuids');
  module_load_include('php', 'cdm_api', 'enums');
  module_load_include('php', 'cdm_api', 'webservice_uris');
  module_load_include('php', 'cdm_api', 'cdm_node');
  module_load_include('inc', 'cdm_api', 'tagged_text');

  /**
   * Timeout used to override the default of 30 seconds
   * in @see drupal_http_request()
   *
   * @var CDM_HTTP_REQUEST_TIMEOUT: A float representing the maximum number of seconds the function
   *     call may take
   */
  define('CDM_HTTP_REQUEST_TIMEOUT', 90.0);



/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_ID_ASC', 'BY_ID_ASC');

/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_ID_DESC', 'BY_ID_DESC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_TITLE_CACHE_ASC', 'BY_TITLE_CACHE_ASC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_TITLE_CACHE_DESC', 'BY_TITLE_CACHE_DESC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_NOMENCLATURAL_ORDER_ASC', 'BY_NOMENCLATURAL_ORDER_ASC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_NOMENCLATURAL_ORDER_DESC', 'BY_NOMENCLATURAL_ORDER_DESC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_ORDER_INDEX_ASC', 'BY_ORDER_INDEX_ASC');
/**
 * orderBy webservice query parameter value
 */
define('CDM_ORDER_BY_ORDER_INDEX_DESC', 'BY_ORDER_INDEX_DESC');


/**
 * Implements hook_menu().
 */
function cdm_api_menu() {
  $items = array();

  // usage: url('cdm_api/proxy/'.urlencode($content_url)."/$theme");
  $items['cdm_api/proxy'] = array(
    'page callback' => 'proxy_content',
    'access arguments' => array(
      'access cdm content',
    ),
    'type' => MENU_CALLBACK,
  );

  $items['cdm_api/setvalue/session'] = array(
    'page callback' => 'setvalue_session',
    'access arguments' => array(
      'access cdm content',
    ),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * info hook implementation for the CDM web service debug block
 *
 * Implements hook_block_info().
 *
 * @see \cdm_api_block_view()
 */
function cdm_api_block_info() {

  $block['cdm_ws_debug'] = array(
      "info" => t("CDM web service debug"),
      "cache" => DRUPAL_NO_CACHE
  );
  return $block;
}

/**
 * block_view hook implementation for the CDM web service debug block
 *
 * Implements hook_block_view().
 *
 * @see  cdm_api_block_info()
 */
function cdm_api_block_view($delta) {
  switch ($delta) {
    case 'cdm_ws_debug':

    $cdm_ws_url = cdm_webservice_url();

    $field_map = array(
        'ws_uri' => t('URI') . ' <code>(' . $cdm_ws_url .'...)</code>',
        'time' => t('Time'),
        'fetch_seconds' => t('Fetching [s]'),
        'parse_seconds' => t('Parsing [s]'),
        'size_kb' => t('Size [kb]'),
        'status' => t('Status'),
        'data_links' =>  t('Links'),
    );


    if (!isset($_SESSION['cdm']['ws_debug'])) {
      $_SESSION['cdm']['ws_debug'] = array();
    }

    $header = '<thead><tr><th>' . join('</th><th>' , array_values($field_map)) . '</th></thead>';
    $footer = '<tfoot><tr><th>' . join('</th><th>' , array_values($field_map)) . '</th></tfoot>';
    $rows = array();

    foreach ($_SESSION['cdm']['ws_debug'] as $data){

      $data = unserialize($data);

      // stip of webservice base url
      $data['ws_uri'] = str_replace($cdm_ws_url, '', $data['ws_uri']);
      if($data['method'] == 'POST'){
        $data['ws_uri'] = 'POST: ' . $data['ws_uri'] . '?' . $data['post_data'];
      }

      $cells = array();
      foreach ($field_map as $field => $label){
        $cells[] = '<td class="' . $field . '">' .  $data[$field] . '</td>';
      }
      $rows[] = '<tr class="' . $data['status']  . '">' . join('' , $cells). '</tr>';
    }
    // clear session again
    $_SESSION['cdm']['ws_debug'] = array();

    _add_js_ws_debug();

    $block['subject'] = ''; // no subject, title in content for having a defined element id
    // otherwise it would depend on the theme
    $block['content'] = array(
      '#markup' => '<h4 id="cdm-ws-debug-button">' . t('CDM Debug') . '</h4>'
        // cannot use theme_table() since table footer is not jet supported in D7
        . '<div id="cdm-ws-debug-table-container"><table id="cdm-ws-debug-table">'
        . $header
        . '<tbody>' . join('', $rows) . '</tbody>'
        . $footer
        . '</table></div>',
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'cdm_dataportal') . '/cdm_dataportal_ws_debug.css'
        )
      )
    );
    return $block;
  }
}

/**
 * Implements hook_cron().
 *
 * Expire outdated cache entries.
 */
function cdm_api_cron() {
  cache_clear_all(NULL, 'cache_cdm_ws');
}

/**
 * Lists the classifications a taxon belongs to
 *
 * @param CDM type Taxon $taxon
 *   the taxon
 *
 * @return array
 *   aray of CDM instances of Type Classification
 */
function get_classifications_for_taxon($taxon) {

  return cdm_ws_get(CDM_WS_TAXON_CLASSIFICATIONS, $taxon->uuid);
}

/**
 * Returns the chosen FeatureTree to be used as FeatureTree for the taxon profile.
 *
 * The FeatureTree returned is the term tree one that has been set in the
 * dataportal settings (layout->taxon:profile).
 * When the chosen FeatureTree is not found in the database,
 * the standard feature tree (UUID_DEFAULT_FEATURETREE) will be returned.
 *
 * @return object
 *   A cdm TermTree object.
 */
function get_profile_feature_tree() {
  static $profile_featureTree;

  if($profile_featureTree == NULL) {
    $profile_featureTree = cdm_ws_get(
      CDM_WS_TERMTREE,
      variable_get(CDM_PROFILE_FEATURETREE_UUID, UUID_DEFAULT_FEATURETREE)
    );
    if (!$profile_featureTree) {
      $profile_featureTree = cdm_ws_get(CDM_WS_TERMTREE, UUID_DEFAULT_FEATURETREE);
    }
  }

  return $profile_featureTree;
}

/**
 * Returns the chosen TermTree to be used as FeatureTree for SpecimenDescriptions.
 *
 * The TermTree returned is the one that has been set in the
 * dataportal settings (layout->taxon:specimen).
 * When the chosen TermTree is not found in the database,
 * the standard term tree (UUID_DEFAULT_TERMTREE) will be returned.
 *
 * @return object
 *   A cdm TermTree object.
 */
function cdm_get_occurrence_featureTree() {
  static $occurrence_featureTree;

  if($occurrence_featureTree == NULL) {
    $occurrence_featureTree = cdm_ws_get(
      CDM_WS_TERMTREE,
      variable_get(CDM_OCCURRENCE_FEATURETREE_UUID, UUID_DEFAULT_FEATURETREE)
    );
    if (!$occurrence_featureTree) {
      $occurrence_featureTree = cdm_ws_get(CDM_WS_TERMTREE, UUID_DEFAULT_FEATURETREE);
    }
  }
  return $occurrence_featureTree;
}

/**
 * Returns the FeatureTree for structured descriptions
 *
 * The FeatureTree returned is the one that has been set in the
 * dataportal settings (layout->taxon:profile).
 * When the chosen FeatureTree is not found in the database,
 * the standard feature tree (UUID_DEFAULT_FEATURETREE) will be returned.
 *
 * @return mixed
 *   A cdm FeatureTree object.
 */
function get_structured_description_featureTree() {
  static $structured_description_featureTree;

  if($structured_description_featureTree == NULL) {
    $structured_description_featureTree = cdm_ws_get(
        CDM_WS_TERMTREE,
        variable_get(CDM_DATAPORTAL_STRUCTURED_DESCRIPTION_FEATURETREE_UUID, UUID_DEFAULT_FEATURETREE)
    );
    if (!$structured_description_featureTree) {
      $structured_description_featureTree = cdm_ws_get(
          CDM_WS_TERMTREE,
          UUID_DEFAULT_FEATURETREE
      );
    }
  }
  return $structured_description_featureTree;
}


/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function set_last_taxon_page_tab($taxonPageTab) {
  $_SESSION['cdm']['taxon_page_tab'] = $taxonPageTab;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function get_last_taxon_page_tab() {
  if (isset($_SESSION['cdm']['taxon_page_tab'])) {
    return $_SESSION['cdm']['taxon_page_tab'];
  }
  else {
    return FALSE;
  }
}

/**
 * NOTE: The cdm-library provides a very similar server side function. See
 * eu.etaxonomy.cdm.model.media.MediaUtils.filterAndOrderMediaRepresentations()
 *
 * @param object $media
 * @param array $mime_types
 *    an array of mimetypes in their order of preference. e.g:
 *    array('application/pdf', 'image/png', 'image/jpeg', 'image/gif', 'text/html')
 * @param int $width
 *    The width of the optimal image. If null, the method will return the representation with the biggest expansion
 * @param int $height
 *    The height of the optimal image. If null, the method will return the representation with the biggest expansion
 * @param bool $mime_types_filter_excludes
 *    Toggles the mode of the $mime_types filter to exclude when set to TRUE
 * @param bool $strict_size_limit
 *    Width an height parameters are treated as maximum values when this parameter is enabled.
 * @return array
 *   An array with preferred media representations or else an empty array.
 */
function cdm_preferred_media_representations($media, array $mime_types, $width = NULL, $height = NULL, $mime_types_filter_excludes = FALSE, $strict_size_limit = FALSE) {
    
    $matching_representations_by_rank = [];
    if (!isset($media->representations[0])) {
      return $matching_representations_by_rank;
    }

    foreach ($media->representations as &$representation) {
      // If the mimetype is not known, try inferring it.
      if (!$representation->mimeType) {
        if (isset($representation->parts[0])) {
          $representation->mimeType = infer_mime_type($representation->parts[0]->uri);
        }
      }
      $mime_type_match = array_search($representation->mimeType, $mime_types) !== false;
      $match_per_mime_type_filter = $mime_types_filter_excludes ? !$mime_type_match : $mime_type_match;
      if ($match_per_mime_type_filter) {
        $expansion_delta_sum = 0;
        $valid_parts_cnt = 0;
        // Look for part with the best matching size.
        foreach ($representation->parts as $part) {
          if (empty($part->uri)) {
            // skip part if URI is missing
            continue;
          }
          if($strict_size_limit){
            if (isset($part->width) && isset($part->height) && $part->width <= $width && $part->height <= $height) {
              $valid_parts_cnt++;
            }
          } else {
            // calculate expansion delta
            $valid_parts_cnt++;
            $expansion_delta = PHP_INT_MAX; // biggest delta for unknown sizes

            // determine the optimal size
            if (isset($part->width) && isset($part->height)) {
              $expansion = $part->width * $part->height;
              if ($width != null && $height != null) {
                $optimalExpansion = $height * $width;
              } else {
                $optimalExpansion = PHP_INT_MAX;
              }
              // determine the difference
              $expansion_delta = $expansion > $optimalExpansion ? $expansion - $optimalExpansion : $optimalExpansion - $expansion;
            }
            // sum up the expansionDeltas of all parts contained in the representation
            $expansion_delta_sum += $expansion_delta;
          }// end parts
        }
        if($valid_parts_cnt > 0){
          $expansion_delta_sum = $expansion_delta_sum / $valid_parts_cnt;
          $matching_representations_by_rank[$expansion_delta_sum] = $representation;
        }
      }
    }

    // Sort the array so that the smallest key value is the first in the array
    ksort($matching_representations_by_rank);
    return $matching_representations_by_rank;
}

/**
 * Infers the mime type of a file using the filename extension.
 *
 * The filename extension is used to infer the mime type.
 *
 * @param string $filepath
 *   The path to the respective file.
 *
 * @return string
 *   The mimetype for the file or FALSE if the according mime type could
 *   not be found.
 */
function infer_mime_type($filepath) {
  static $mimemap = NULL;
  if (!$mimemap) {
    $mimemap = array(
      'jpg' => 'image/jpeg',
      'jpeg' => 'image/jpeg',
      'png' => 'image/png',
      'gif' => 'image/gif',
      'giff' => 'image/gif',
      'tif' => 'image/tif',
      'tiff' => 'image/tif',
      'pdf' => 'application/pdf',
      'html' => 'text/html',
      'htm' => 'text/html',
    );
  }
  $extension = substr($filepath, strrpos($filepath, '.') + 1);
  if (isset($mimemap[$extension])) {
    return $mimemap[$extension];
  }
  else {
    // FIXME remove this hack just return FALSE;
    return 'text/html';
  }
}

/**
 * Formats a mysql datatime as string
 *
 * @param $datetime
 * @param string $format
 *
 * @return
 *  the formatted string representation of the $datetime
 */
function format_datetime($datetime, $format = 'Y-m-d H:i:s O', $strip_zeros = true){
  return date($format, strtotime($datetime));
}

/**
 * Converts an ISO 8601 org.joda.time.Partial to a year.
 *
 * The function expects an ISO 8601 time representation of a
 * org.joda.time.Partial of the form yyyy-MM-dd.
 *
 * @param string $partial
 *   ISO 8601 time representation of a org.joda.time.Partial.
 *
 * @return string
 *   Returns the year. In case the year is unknown (= ????), it returns NULL.
 */
function partialToYear($partial) {
  if (is_string($partial)) {
    $year = drupal_substr($partial, 0, 4);
    if (preg_match("/[0-9][0-9][0-9][0-9]/", $year)) {
      return $year;
    }
  }
  return '';
}

/**
 * Converts an ISO 8601 org.joda.time.Partial to a month.
 *
 * This function expects an ISO 8601 time representation of a
 * org.joda.time.Partial of the form yyyy-MM-dd.
 * In case the month is unknown (= ???) NULL is returned.
 *
 * @param string $partial
 *   ISO 8601 time representation of a org.joda.time.Partial.
 *
 * @return string
 *   A month.
 */
function partialToMonth($partial) {
  if (is_string($partial)) {
    $month = drupal_substr($partial, 5, 2);
    if (preg_match("/[0-9][0-9]/", $month)) {
      return $month;
    }
  }
  return '';
}

/**
 * Converts an ISO 8601 org.joda.time.Partial to a day.
 *
 * This function expects an ISO 8601 time representation of a
 * org.joda.time.Partial of the form yyyy-MM-dd and returns the day as string.
 * In case the day is unknown (= ???) NULL is returned.
 *
 * @param string $partial
 *   ISO 8601 time representation of a org.joda.time.Partial.
 *
 * @return string
 *   A day.
 */
function partialToDay($partial) {
  if (is_string($partial)) {
    $day = drupal_substr($partial, 8, 2);
    if (preg_match("/[0-9][0-9]/", $day)) {
      return $day;
    }
  }
  return '';
}

/**
 * Converts an ISO 8601 org.joda.time.Partial to YYYY-MM-DD.
 *
 * This function expects an ISO 8601 time representations of a
 * org.joda.time.Partial of the form yyyy-MM-dd and returns
 * four digit year, month and day with dashes:
 * YYYY-MM-DD eg: "2012-06-30", "1956-00-00"
 *
 * The partial may contain question marks eg: "1973-??-??",
 * these are turned in to '00' or are stripped depending of the $stripZeros
 * parameter.
 *
 * @param string $partial
 *   org.joda.time.Partial.
 * @param bool $stripZeros
 *   If set to TRUE the zero (00) month and days will be hidden:
 *   eg 1956-00-00 becomes 1956. The default is TRUE.
 * @param string @format
 * 	 Can ve used to specify the format of the date string, currently the following format strings are supported
 *    - "YYYY": Year only
 *    - "YYYY-MM-DD": this is the default
 *
 * @return string
 *   YYYY-MM-DD formatted year, month, day.
 */
function partialToDate($partial, $stripZeros = TRUE, $format= "YYYY-MM-DD") {

  $y = NULL; $m = NULL; $d = NULL;

  if(strpos($format, 'YY') !== FALSE){
    $y = partialToYear($partial);
  }
  if(strpos($format, 'MM') !== FALSE){
    $m = partialToMonth($partial);
  }
  if(strpos($format, 'DD') !== FALSE){
    $d = partialToDay($partial);
  }

  $y = $y ? $y : '0000';
  $m = $m ? $m : '00';
  $d = $d ? $d : '00';

  $date = '';

  if ($y == '0000' && $stripZeros && $m == '00' && $d == '00') {
    return '';
  }
  else {
    $date = $y;
  }

  if ($m == '00' && $stripZeros && $d == '00') {
    return $date;
  }
  else {
    $date .= "-" . $m;
  }

  if ($d == '00' && $stripZeros) {
    return $date;
  }
  else {
    $date .= "-" . $d;
  }
  return $date;
}

/**
 * Converts a time period to a string.
 *
 * See also partialToDate($partial, $stripZeros).
 *
 * @param object $period
 *   An JodaTime org.joda.time.Period object.
 * @param bool $stripZeros
 *   If set to True, the zero (00) month and days will be hidden:
 *   eg 1956-00-00 becomes 1956. The default is TRUE.
 * @param string @format
 * 	 Can ve used to specify the format of the date string, currently the following format strings are supported
 *    - "YYYY": Year only
 *    - "YYYY-MM-DD": this is the default
 *
 * @return string
 *   Returns a date in the form of a string.
 */
function timePeriodToString($period, $stripZeros = TRUE, $format = "YYYY-MM-DD") {
  $dateString = '';
  if($period->freeText){
    $dateString = $period->freeText;
  } else {
    if ($period->start) {
      $dateString = partialToDate($period->start, $stripZeros, $format);
    }
    if ($period->end) {
      $end_str = partialToDate($period->end, $stripZeros, $format);
      $dateString .= ($dateString && $end_str ? ' ' . t('to') . ' ' : '') . $end_str;
    }
  }
  return $dateString;
}

/**
 * returns the earliest date available in the $period in a normalized
 * form suitable for sorting, e.g.:
 *
 *  - 1956-00-00
 *  - 0000-00-00
 *  - 1957-03-00
 *
 * that is either the start date is returned if set otherwise the
 * end date
 *
 * @param  $period
 *    An JodaTime org.joda.time.Period object.
 * @return string normalized form of the date
 *   suitable for sorting
 */
function timePeriodAsOrderKey($period) {
  $dateString = '';
  if ($period->start) {
    $dateString = partialToDate($period->start, false);
  }
  if ($period->end) {
    $dateString .= partialToDate($period->end, false);
  }
  return $dateString;
}

/**
 * Composes a absolute CDM web service URI with parameters and querystring.
 *
 * @param string $uri_pattern
 *   String with place holders ($0, $1, ..) that should be replaced by the
 *   according element of the $pathParameters array.
 * @param array $pathParameters
 *   An array of path elements, or a single element.
 * @param string $query
 *   A query string to append to the URL.
 *
 * @return string
 *   A complete URL with parameters to a CDM webservice.
 */
function cdm_compose_ws_url($uri_pattern, $pathParameters = array(), $query = NULL) {
  if (empty($pathParameters)) {
    $pathParameters = array();
  }
  $path = cdm_compose_url($uri_pattern, $pathParameters, $query);
  $url = cdm_webservice_url() . $path;
  return $url;
}

/**
 * Wrapper to access the 'cdm_webservice_url' and to ensure that
 * the returned webservice url scheme conforms to the scheme of the
 * page request.
 *
 * @param string $default optional parameter to set the default, by default an empty string is returned
 */
function cdm_webservice_url($default = ''){
  static $conform_ws_url = null;
  if($conform_ws_url === null) {
    $ws_url = variable_get('cdm_webservice_url', $default);
    if($ws_url && $_SERVER['REQUEST_SCHEME'] == 'https' && parse_url($ws_url, PHP_URL_SCHEME) === 'http'){
      $conform_ws_url = preg_replace("/^http\:/", "https:", $ws_url);
      drupal_set_message('The <stong>CDM web service URL</stong> scheme should be set to <strong>HTTPS</strong> the '
        . l('CDM Data Portal settings', 'admin/config/cdm_dataportal/settings'), 'warning');
    } else {
      $conform_ws_url = $ws_url;
    }
  }
  return $conform_ws_url;
}

/**
 * Composes a relative Url with parameters and querystring.
 *
 * @param string $uri_pattern
 *   String with place holders ($0, $1, ..) that should be replaced by the
 *   according element of the $pathParameters array.
 * @param array $pathParameters
 *   An array of path elements, or a single element.
 * @param string $query
 *   A query string to append to the URL.
 *
 * @return string
 *   A relative URL with query parameters.
 */
function cdm_compose_url($uri_pattern, $pathParameters, $query = NULL) {

  // (1)
  // Substitute all place holders ($0, $1, ..) in the $uri_pattern by the
  // according element of the $pathParameters array.
  static $helperArray = [];
  if (isset($pathParameters) && !is_array($pathParameters)) {
    $helperArray[0] = $pathParameters;
    $pathParameters = $helperArray;
  }

  $i = 0;
  while (strpos($uri_pattern, "$" . $i) !== FALSE) {
    if (count($pathParameters) <= $i) {
      drupal_set_message('cdm_compose_url(): missing pathParameter ' . $i .' for ' . $uri_pattern, 'error');
      break;
    }
    $uri_pattern = str_replace("$" . $i, rawurlencode($pathParameters[$i]), $uri_pattern);
    ++$i;
  }

  // (2)
  // Append all remaining element of the $pathParameters array as path
  // elements.
  if (count($pathParameters) > $i) {
    // Strip trailing slashes.
    if (strrchr($uri_pattern, '/') == strlen($uri_pattern)) {
      $uri_pattern = substr($uri_pattern, 0, strlen($uri_pattern) - 1);
    }
    while (count($pathParameters) > $i) {
      $uri_pattern .= '/' . rawurlencode($pathParameters[$i]);
      ++$i;
    }
  }

  // (3)
  // Append the query string supplied by $query.
  $uri_pattern = append_query_parameters($uri_pattern, $query);

  $path = $uri_pattern;
  return $path;
}

/**
 * @param string $uri
 *
 * @param $query_string
 *
 * @return string
 */
function append_query_parameters($uri, $query_string) {

  if (isset($query_string)) {
    $uri .= (strpos($uri, '?') !== FALSE ? '&' : '?') . $query_string;
  }

  return $uri;
}

/**
 * @todo wouldn't it more elegant and secure to only pass a uuid and additional function parameters
 *     together with a theme name to such a proxy function?
 *     Well this would not be covering all use cases but maybe all which involve AHAH.
 *     Maybe we want to have two different proxy functions, one with theming and one without?
 *
 * @param string $uri
 *     A URI to a CDM Rest service from which to retrieve an object
 * @param string|null $hook
 *     (optional) The hook name to which the retrieved object should be passed.
 *     Hooks can either be a theme_hook() or compose_hook() implementation
 *     'theme' hook functions return a string whereas 'compose' hooks are returning render arrays
 *     suitable for drupal_render()
 *
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function proxy_content($uri, $hook = NULL) {

  $args = func_get_args();
  $do_gzip = function_exists('gzencode');
  $uriEncoded = array_shift($args);
  $uri = urldecode($uriEncoded);
  $hook = array_shift($args);
  $request_method = strtoupper($_SERVER["REQUEST_METHOD"]);

  $post_data = null;

  if ($request_method == "POST" || $request_method == "PUT") {
    // read response body via inputstream module
    $post_data = file_get_contents("php://input");
  }

  // Find and deserialize arrays.
  foreach ($args as &$arg) {
    // FIXME use regex to find serialized arrays.
    //       or should we accept json instead of php serializations?
    if (strpos($arg, "a:") === 0) {
      $arg = unserialize($arg);
    }
  }

  // In all these cases perform a simple get request.
  // TODO reconsider caching logic in this function.

  if (empty($hook)) {
    // simply return the webservice response
    // Print out JSON, the cache cannot be used since it contains objects.
    $http_response = cdm_http_request($uri, $request_method, $post_data);
    if (isset($http_response->headers)) {
      foreach ($http_response->headers as $hname => $hvalue) {
        drupal_add_http_header($hname, $hvalue);
      }
    }
    if (isset($http_response->data)) {
      print $http_response->data;
      flush();
    }
    exit(); // leave drupal here
  } else {
    // $hook has been supplied
    // handle $hook either as compose or theme hook
    // pass through theme or compose hook
    // compose hooks can be called without data, therefore
    // passing the $uri in this case is not always a requirement

    if($uri && $uri != 'NULL') {
    // do a security check since the $uri will be passed
    // as absolute URI to cdm_ws_get()
      if (!_is_cdm_ws_uri($uri)) {
        drupal_set_message(
          'Invalid call of proxy_content() with callback parameter \'' . $hook . '\' and URI:' . $uri,
          'error'
        );
        return '';
      }

      $obj = cdm_ws_get($uri, NULL, $post_data, $request_method, TRUE);
    } else {
      $obj = NULL;
    }

    $response_data = NULL;

    if (function_exists('compose_' . $hook)){
      // call compose hook

      $elements =  call_user_func('compose_' . $hook, $obj);
      // pass the render array to drupal_render()
      $response_data = drupal_render($elements);
    } else {
      // call theme hook

      // TODO use theme registry to get the registered hook info and
      //    use these defaults
      switch($hook) {
        case 'cdm_taxontree':
          $variables = array(
            'tree' => $obj,
            'filterIncludes' => isset($args[0]) ? $args[0] : NULL,
            'show_filter_switch' => isset($args[1]) ? $args[1] : FALSE,
            'tree_node_callback' => isset($args[2]) ? $args[2] : FALSE,
            'element_name'=> isset($args[3]) ? $args[3] : FALSE,
            );
          $response_data = theme($hook, $variables);
          break;

        case 'cdm_list_of_taxa':
            $variables = array(
              'records' => $obj,
              'freetextSearchResults' => isset($args[0]) ? $args[0] : array(),
              'show_classification' => isset($args[1]) ? $args[1] : FALSE);
            $response_data = theme($hook, $variables);
            break;

        default:
          drupal_set_message(t(
          'Theme !theme is not yet supported by the function !function.', array(
          '!theme' => $hook,
          '!function' => __FUNCTION__,
          )), 'error');
          break;
      } // END of theme hook switch
    } // END of tread as theme hook


    if($do_gzip){
      $response_data = gzencode($response_data, 2, FORCE_GZIP);
      drupal_add_http_header('Content-Encoding', 'gzip');
    }
    drupal_add_http_header('Content-Type', 'text/html; charset=utf-8');
    drupal_add_http_header('Content-Length', strlen($response_data));

    print $response_data;
  } // END of handle $hook either as compose ot theme hook

}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function setvalue_session() {
  if ($_REQUEST['var'] && strlen($_REQUEST['var']) > 4) {
    $var_keys = substr($_REQUEST['var'], 1, strlen($_REQUEST['var']) - 2);
    $var_keys = explode('][', $var_keys);
  }
  else {
    return;
  }
  $val = isset($_REQUEST['val']) ? $_REQUEST['val'] : NULL;

  // Prevent from malicous tags.
  $val = strip_tags($val);

  $session_var = &$_SESSION;
  //$i = 0;
  foreach ($var_keys as $key) {
    // $hasMoreKeys = ++$i < count($session);
    if (!isset($session_var[$key]) || !is_array($session_var[$key])) {
      $session_var[$key] = array();
    }
    $session_var = &$session_var[$key];
  }
  $session_var = $val;
  if (isset($_REQUEST['destination'])) {
    drupal_goto($_REQUEST['destination']);
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function uri_uriByProxy($uri, $theme = FALSE) {
  // usage: url('cdm_api/proxy/'.urlencode($content_url)."/$theme");)
  return url('cdm_api/proxy/' . urlencode($uri) . (isset($theme) ? "/$theme" : ''));
}

/**
 * Composes the the absolute REST service URI to the annotations pager
 * for the given CDM entity.
 *
 * NOTE: Not all CDM Base types are yet supported.
 *
 * @param $cdm_entity
 *   The CDM entity to construct the annotations pager uri for
 */
function cdm_compose_annotations_uri($cdm_entity) {

  $cdm_entity_type = $cdm_entity->class;

  if($cdm_entity_type == 'DerivedUnitFacade'){
    // TODO with the below code we may miss annotations.
    //  Better implement a derivedUnitFacade/{uuid}/annotations service and use that instead
    if(isset($cdm_entity->fieldUnitEntityReference)){
      $cdm_entity_type = $cdm_entity->fieldUnitEntityReference->type;
      $cdm_entity_uuid = $cdm_entity->fieldUnitEntityReference->uuid;
    } elseif(isset($cdm_entity->baseUnitEntityReference)){
      $cdm_entity_type = $cdm_entity->baseUnitEntityReference->type;
      $cdm_entity_uuid = $cdm_entity->baseUnitEntityReference->uuid;
    }
  } elseif ($cdm_entity_type == 'TypedEntityReference'){
    $cdm_entity_type = $cdm_entity->type;
    $cdm_entity_uuid = $cdm_entity->uuid;
  } else {
    if (isset($cdm_entity->uuid)) {
      $cdm_entity_uuid = $cdm_entity->uuid;
    }
  }

  if(!isset($cdm_entity_uuid) || !isset($cdm_entity_type) || !$cdm_entity_type ){
    // silently give up
    return;
  }

  $ws_base_uri = cdm_ws_base_uri($cdm_entity_type);

  if($ws_base_uri === null){
      trigger_error(check_plain('Unsupported CDM Class - no annotations available for ' . $cdm_entity_type), E_USER_ERROR);
  }
  return cdm_compose_ws_url($ws_base_uri, array(
    $cdm_entity_uuid,
    'annotations',
  ));
}

/**
 * Provides the base URI of the cdm REST service responsible for the passed simple name
 * of a CDM java class. For example 'TaxonName' is the simple name of 'eu.etaxonomy.cdm.model.name.TaxonName'
 *
 * @param $cdm_type_simple
 *    simple name of a CDM java class
 * @return null|string
 */
function cdm_ws_base_uri($cdm_type_simple)
{
  switch ($cdm_type_simple) {
    case 'TaxonNode':
    case 'TaxonNodeDto':
      $ws_base_uri = CDM_WS_TAXONNODE;
      break;

    case 'TaxonBase':
    case 'Taxon':
    case 'Synonym':
      $ws_base_uri = CDM_WS_TAXON;
      break;

    case 'TaxonName':
      $ws_base_uri = CDM_WS_NAME;
      break;

    case 'Media':
      $ws_base_uri = CDM_WS_MEDIA;
      break;

    case 'Reference':
      $ws_base_uri = CDM_WS_REFERENCE;
      break;

    case 'Registration':
      $ws_base_uri = CDM_WS_REGISTRATION;
      break;

    case 'FieldUnit':
    case 'DerivedUnit':
    case 'DnaSample':
    case 'MediaSpecimen':
    case 'DerivedUnitDTO':
    case 'FieldUnitDTO':
    case 'DNASampleDTO':
      $ws_base_uri = CDM_WS_OCCURRENCE;
      break;

    case 'Amplification':
    case 'DerivationEvent':
    case 'DeterminationEvent':
    case 'GatheringEvent':
    case 'MaterialOrMethodEvent':
    case 'SingleRead':
      $ws_base_uri = CDM_WS_EVENTBASE;
      break;

    case 'Distribution':
    case 'TextData':
    case 'TaxonInteraction':
    case 'QuantitativeData':
    case 'IndividualsAssociation':
    case 'CommonTaxonName':
    case 'CategoricalData':
      $ws_base_uri = CDM_WS_DESCRIPTIONELEMENT;
      break;

    case 'Person':
    case 'Team':
    case 'AgentBase':
      $ws_base_uri = CDM_WS_AGENT;
      break;

    case 'PolytomousKey':
    case 'MediaKey':
    case 'MultiAccessKey':
      $ws_base_uri = $cdm_type_simple;
      $ws_base_uri[0] = strtolower($ws_base_uri[0]);
      break;

    case 'TextualTypeDesignation':
    case 'SpecimenTypeDesignation':
    case 'NameTypeDesignation':
    case 'TypeDesignationDTO':
      $ws_base_uri = CDM_WS_TYPEDESIGNATION;
      break;
    default:
      $ws_base_uri = null;
      drupal_set_message(
        t('cdm_ws_base_uri()  - cdm type name "@cdm_type_simple" unsupported',
          array('@cdm_type_simple' => $cdm_type_simple )),
        'error');
  }
  return $ws_base_uri;
}

function cdm_type_has_tagged_text($cdm_type_name){
  return array_search($cdm_type_name, ['TaxonName', 'Taxon', 'Synonym']) !== false;
}

/**
 * Enter description here...
 *
 * @param string $resource_uri
 * @param int $page_size
 *   The maximum number of entities returned per page.
 *   The default page size as configured in the cdm server
 *   will be used if set to NULL
 *   to return all entities in a single page).
 * @param int $page_index
 *   The number of the page to be returned, the first page has the
 *   page_index = 0
 * @param array $query
 *   A array holding the HTTP request query parameters for the request
 * @param string $method
 *   The HTTP method to use, valid values are "GET" or "POST"
 * @param bool $absolute_uri
 *   TRUE when the URL should be treated as absolute URL.
 *
 * @return object
 *   A CDM Pager object
 *
 */
function cdm_ws_page($resource_uri, $page_size, $page_index, array $query = array(), $method = 'GET', $absolute_uri = FALSE) {

  $query['pageIndex'] = $page_index;
  $query['pageSize'] = $page_size;

  $pager = cdm_ws_get($resource_uri, NULL, queryString($query), $method, $absolute_uri);
  if(is_array($pager)){
    trigger_error("Expecting web service to return pager objects but received an array:<br/>" . $resource_uri . '?' . queryString($query) . '<br/>Wrapping response in pager to recover from error.', E_USER_WARNING);
    $records = $pager;
    $pager = new stdClass();
    $pager->records = $records;
    $pager->count = count($records);
    $pager->pageSize = $pager->count;
    $pager->nextIndex = null;
  }
  return $pager;
}


/**
 * Sends a http GET request to the generic page method which allows for filtering entities by Restrictions.
 *
 * @param $cdm_entity_type
 * @param $class_restriction
 *   Optional param to narrow down polymorph types to a specific type.
 * @param array $restrictions
 *   An array of Restriction objects
 * @param array $init_strategy
 *   The init strategy to initialize the entity beans while being loaded from the
 *   persistent storage by the cdm
 * @param int $page_size
 *   The maximum number of entities returned per page.
 *   The default page size as configured in the cdm server
 *   will be used if set to NULL
 *   to return all entities in a single page).
 * @param int $page_index
 *   The number of the page to be returned, the first page has the
 *   pageNumber = 0
 *
 * @return object
 *   A CDM Pager object
 */
function cdm_ws_page_by_restriction($cdm_entity_type, $class_restriction, array $restrictions, array $init_strategy, $page_size, $page_index) {

  $restrictions_json = array(); // json_encode($restrictions);
  foreach ($restrictions as $restr){
    $restrictions_json[] = json_encode($restr);
  }
  $filter_parameters = [
    'restriction' => $restrictions_json,
    'initStrategy' => $init_strategy
  ];
  if($class_restriction){
    $filter_parameters['class'] = $class_restriction;
  }

  return cdm_ws_page(
      'portal/' . cdm_ws_base_uri($cdm_entity_type),
      $page_size,
      $page_index,
    $filter_parameters,
    "GET"
    );
}

/**
 * Fetches all entities returned by the the generic page method for the Restrictions applied as filter.
 *
 * @param $cdm_entity_type
 * @param $class_restriction
 *   Optional param to narrow down polymorph types to a specific type.
 * @param array $restrictions
 *   An array of Restriction objects
 * @param array $init_strategy
 *   The init strategy to initialize the entity beans while being loaded from the
 *   persistent storage by the cdm
 *
 * @return array
 *   A array of CDM entities
 */
function cdm_ws_fetch_all_by_restriction($cdm_entity_type, $class_restriction, array $restrictions, array $init_strategy){
  $page_index = 0;
  // using a bigger page size to avoid to many multiple requests
  $page_size = 500;
  $entities = array();

  while ($page_index !== FALSE && $page_index < 1){
    $pager =  cdm_ws_page_by_restriction($cdm_entity_type, $class_restriction, $restrictions, $init_strategy, $page_size, $page_index);
    if(isset($pager->records) && is_array($pager->records)) {
      $entities = array_merge($entities, $pager->records);
      if(!empty($pager->nextIndex)){
        $page_index = $pager->nextIndex;
      } else {
        $page_index = FALSE;
      }
    } else {
      $page_index = FALSE;
    }
  }
  return $entities;
}


  /**
 * Fetches all entities from the given REST endpoint using the pager mechanism.
 *
 * @param string $resourceURI
 * @param array $query
 *   A array holding the HTTP request query parameters for the request
 * @param string $method
 *   The HTTP method to use, valid values are "GET" or "POST";
 * @param bool $absoluteURI
 *   TRUE when the URL should be treated as absolute URL.
 *
 * @return array
 *     A list of CDM entitites
 *
 */
function cdm_ws_fetch_all($resourceURI, array $query = array(), $method = 'GET', $absoluteURI = FALSE) {
  $page_index = 0;
  // using a bigger page size to avoid too many multiple requests
  $page_size = 500;
  $entities = [];

  while (true){
    $pager =  cdm_ws_page($resourceURI, $page_size, $page_index, $query,  $method, $absoluteURI);
    if(isset($pager->records) && is_array($pager->records)) {
      $entities = array_merge($entities, $pager->records);
      if(is_numeric($pager->nextIndex) && $page_index < $pager->nextIndex){
        $page_index = $pager->nextIndex;
      } else {
        break;
      }
    } else {
      break;
    }
  }
  return $entities;
}

/*
function cdm_ws_taxonomy_compose_resourcePath($path = NULL){
  $viewrank = _cdm_taxonomy_compose_viewrank();
  return CDM_WS_PORTAL_TAXONOMY . '/' . ($viewrank ? $viewrank : '' ) . ($path
  ? '/' . $path : '') ;
}
*/

/**
 * @todo Enter description here...
 *
 * @param string $taxon_uuid
 *  The UUID of a cdm taxon instance
 * @param string $ignore_rank_limit
 *   Whether to ignore the variable 'taxontree_ranklimit' set by admin in the settings
 *
 * @return string
 *   A cdm REST service URL path to a Classification
 */
function cdm_compose_taxonomy_root_level_path($taxon_uuid = FALSE, $ignore_rank_limit = FALSE) {

  $view_uuid = get_current_classification_uuid();
  $rank_uuid = NULL;
  if (!$ignore_rank_limit) {
    $rank_uuid = variable_get(TAXONTREE_RANKLIMIT, TAXONTREE_RANKLIMIT_DEFAULT);
  }

  if (!empty($taxon_uuid)) {
    return cdm_compose_ws_url(CDM_WS_PORTAL_TAXONOMY_CHILDNODES_OF_TAXON, array(
      $view_uuid,
      $taxon_uuid,
    ));
  }
  else {
    if (is_uuid($rank_uuid)) {
      return cdm_compose_ws_url(CDM_WS_PORTAL_TAXONOMY_CHILDNODES_AT_RANK, array(
        $view_uuid,
        $rank_uuid,
      ));
    }
    else {
      return cdm_compose_ws_url(CDM_WS_PORTAL_TAXONOMY_CHILDNODES, array(
        $view_uuid,
      ));
    }
  }
}

/**
 * Retrieves from the cdm web service with the first level of childnodes of a classification.
 *
 * The level is either the real root level ot it is a lover level if a rank limit has been set.
 * (@see  cdm_compose_taxonomy_root_level_path() for more on the rank limit).
 *
 * Operates in two modes depending on whether the parameter
 * $taxon_uuid is set or NULL.
 *
 * A) $taxon_uuid = NULL:
 *  1. retrieve the Classification for the uuid set in the $_SESSION['cdm']['taxonomictree_uuid']
 *  2. otherwise return the default classification as defined by the admin via the settings
 *
 * b) $taxon_uuid is set:
 *   return the classification to whcih the taxon belongs to.
 *
 * @param UUID $taxon_uuid
 *   The UUID of a cdm taxon instance
 */
function cdm_ws_taxonomy_root_level($taxon_uuid = NULL) {

    $response = NULL;

    // 1st try
    $response = cdm_ws_get(cdm_compose_taxonomy_root_level_path($taxon_uuid), NULL, NULL, 'GET', TRUE);

    if ($response == NULL) {
      // 2dn try by ignoring the rank limit
      $response = cdm_ws_get(cdm_compose_taxonomy_root_level_path($taxon_uuid, TRUE), NULL, NULL, 'GET', TRUE);
    }

    if ($response == NULL) {
      // 3rd try, last fallback:
      //    return the default classification
      if (isset($_SESSION['cdm']['taxonomictree_uuid']) && is_uuid($_SESSION['cdm']['taxonomictree_uuid'])) {
        // Delete the session value and try again with the default.
        unset($_SESSION['cdm']['taxonomictree_uuid']);
        drupal_set_message("Could not find a valid classification, falling back to the default classification.", 'warning');
        return cdm_ws_taxonomy_root_level($taxon_uuid);
      }
      else {
        // Check if taxonomictree_uuid is valid.
        // expecting an array of taxonNodes,
        // empty classifications are ok so no warning in this case!
        $test = cdm_ws_get(cdm_compose_taxonomy_root_level_path(), NULL, NULL, 'GET', TRUE);
        if (!is_array($test)) {
          // The default set by the admin seems to be invalid or is not even set.
          drupal_set_message(_no_classfication_uuid_message(), 'warning');
        } else if (count($test) == 0) {
          // The default set by the admin seems to be invalid or is not even set.
          drupal_set_message("The chosen classification is empty.", 'status');
        }
      }
    }

  return $response;
}

/**
 * Determines the tree path of the taxon given as uuid to the root of the classification tree.
 * 
 * The root either is the absolute root of the tree or a rank specific root if the TAXONTREE_RANKLIMIT
 * variable is set.
 *
 * @param string $taxon_uuid
 *
 * @return array
 *   An array of CDM TaxonNodeDTO objects
 */
function cdm_ws_taxonomy_pathFromRoot($taxon_uuid) {
  $view_uuid = get_current_classification_uuid();
  $rank_uuid = variable_get(TAXONTREE_RANKLIMIT, TAXONTREE_RANKLIMIT_DEFAULT);

  $response = NULL;
  if (is_uuid($rank_uuid)) {
    $response = cdm_ws_get(CDM_WS_PORTAL_TAXONOMY_PATH_FROM_TO_RANK, array(
      $view_uuid,
      $taxon_uuid,
      $rank_uuid,
    ));
  }
  else {
    $response = cdm_ws_get(CDM_WS_PORTAL_TAXONOMY_PATH_FROM, array(
      $view_uuid,
      $taxon_uuid,
    ));
  }

  if ($response == NULL) {
    // Error handing.
//    if (is_uuid($_SESSION['cdm']['taxonomictree_uuid'])) {
//      // Delete the session value and try again with the default.
//      unset($_SESSION['cdm']['taxonomictree_uuid']);
//      return cdm_ws_taxonomy_pathFromRoot($taxon_uuid);
//    }
//    else {
      // Check if taxonomictree_uuid is valid.
      $test = cdm_ws_get(cdm_compose_taxonomy_root_level_path(), NULL, NULL, 'GET', TRUE);
      if ($test == NULL) {
        // The default set by the admin seems to be invalid or is not even set.
        drupal_set_message(_no_classfication_uuid_message(), 'warning');
      }
//    }
  }

  return $response;
}


// =============================Terms and Vocabularies ========================================= //

/**
 * Returns the localized representation for the given term.
 *
 * @param Object $definedTermBase
 * 	  of cdm type DefinedTermBase
 * @return string
 * 	  the localized representation_L10n of the term,
 *    otherwise the titleCache as fall back,
 *    otherwise the default_representation which defaults to an empty string
 */
function cdm_term_representation($definedTermBase, $default_representation = '') {
  if ( isset($definedTermBase->representation_L10n) ) {
    return $definedTermBase->representation_L10n;
  } elseif ( isset($definedTermBase->titleCache)) {
    return $definedTermBase->titleCache;
  }
  return $default_representation;
}

/**
 * Returns the abbreviated localized representation for the given term.
 *
 * @param Object $definedTermBase
 * 	  of cdm type DefinedTermBase
 * @return string
 * 	  the localized representation_L10n_abbreviatedLabel of the term,
 *    if this representation is not available the function delegates the
 *    call to cdm_term_representation()
 */
function cdm_term_representation_abbreviated($definedTermBase, $default_representation = '') {
  if ( isset($definedTermBase->representation_L10n_abbreviatedLabel) ) {
    return $definedTermBase->representation_L10n_abbreviatedLabel;
  } else {
    cdm_term_representation($definedTermBase, $default_representation);
  }
}

/**
 * Transforms the list of the given term base instances to a alphabetical ordered options array.
 *
 * The options array is suitable for drupal form API elements that allow multiple choices.
 * @see http://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7#options
 *
 * @param array $terms
 *   a list of CDM DefinedTermBase instances
 *
 * @param $term_label_callback
 *   A callback function to override the term representations
 *
 * @param bool $empty_option
 *   An additional element do be placed at the beginning og the list. This element will be the default option.
 *
 * @return array
 *   the terms in an array (key: uuid => value: label) as options for a form element that allows multiple choices.

 */
function cdm_terms_as_options($terms, $term_label_callback = NULL, $empty_option = FALSE){
  $options = array();
  if(isset($terms) && is_array($terms)) {
    foreach ($terms as $term) {
      if ($term_label_callback && function_exists($term_label_callback)) {
        $options[$term->uuid] = call_user_func($term_label_callback, $term);
      } else {
        //TODO use cdm_term_representation() here?
        $options[$term->uuid] = t('@term', array('@term' => $term->representation_L10n));
      }
    }
  }

  if($empty_option !== FALSE){
    array_unshift ($options, "");
  }

  return $options;
}

/**
 * Creates and array of options for drupal select form elements.
 *
 * @param $vocabulary_uuid
 *   The UUID of the CDM Term Vocabulary
 * @param $term_label_callback
 *   An optional call back function which can be used to modify the term label
 * @param bool $empty_option
 *   An additional element do be placed at the beginning og the list. This element will be the default option.
 * @param array $include_filter
 *   An associative array consisting of a field name an regular expression. All term matching
 *   these filter are included. The value of the field is converted to a String by var_export()
 *   so a boolean 'true' can be matched by '/true/'
 * @param string $order_by
 *   One of the order by constants defined in this file
 * @return array
 *   the terms in an array (key: uuid => value: label) as options for a form element that allows multiple choices.
 */
function cdm_vocabulary_as_option($vocabulary_uuid, $term_label_callback = NULL, $empty_option = FALSE,
                                  array $include_filter = null, $order_by = CDM_ORDER_BY_ORDER_INDEX_ASC) {

  static $vocabularyOptions = array();

  if (!isset($vocabularyOptions[$vocabulary_uuid])) {
    $terms = cdm_ws_fetch_all('termVocabulary/' . $vocabulary_uuid . '/terms',
      array(
        'orderBy' => $order_by
      )
    );

    // apply the include filter
    if($include_filter != null){
      $included_terms = array();

      foreach ($terms as $term){
        $include = true;
        foreach ($include_filter as $field=>$regex){
          $include =  preg_match($regex, var_export($term->$field, true)) === 1;
          if(!$include){
            break;
          }
        }
        if($include){
          $included_terms[] = $term;
        }
      }

      $terms = $included_terms;
    }

    // make options list
    $vocabularyOptions[$vocabulary_uuid] = cdm_terms_as_options($terms, $term_label_callback, $empty_option);
  }

  $options = $vocabularyOptions[$vocabulary_uuid];

  return $options;
}

/**
 * Creates and array of defaults for drupal select form elements.
 *
 * @param $vocabulary_uuid
 *   The UUID of the CDM Term Vocabulary
 * @param $term_label_callback
 *   An optional call back function which can be used to modify the term label
 * @param bool $empty_option
 *   An additional element do be placed at the beginning og the list. This element will be the default option.
 * @param array $include_filter
 *   An associative array consisting of a field name an regular expression. All term matching
 *   these filter are included. The value of the field is converted to a String by var_export()
 *   so a boolean 'true' can be matched by '/true/'
 * @param string $order_by
 *   One of the order by constants defined in this file
 * @return array
 *   the terms in an array (key: uuid => value: uuid) as defaults for a form element that allows multiple choices.
 */
function cdm_vocabulary_as_defaults($vocabulary_uuid, array $include_filter = null) {

  $options = cdm_vocabulary_as_option($vocabulary_uuid, null, null, $include_filter);
  $defaults = array();
  foreach ($options as $uuid => $value){
    $defaults[$uuid] = $uuid;
  }

  return $defaults;
}

/**
 * @param $term_type string one of
 *  - Unknown
 *  - Language
 *  - NamedArea
 *  - Rank
 *  - Feature
 *  - AnnotationType
 *  - MarkerType
 *  - ExtensionType
 *  - DerivationEventType
 *  - PresenceAbsenceTerm
 *  - NomenclaturalStatusType
 *  - NameRelationshipType
 *  - HybridRelationshipType
 *  - SynonymRelationshipType
 *  - TaxonRelationshipType
 *  - NameTypeDesignationStatus
 *  - SpecimenTypeDesignationStatus
 *  - InstitutionType
 *  - NamedAreaType
 *  - NamedAreaLevel
 *  - RightsType
 *  - MeasurementUnit
 *  - StatisticalMeasure
 *  - MaterialOrMethod
 *  - Material
 *  - Method
 *  - Modifier
 *  - Scope
 *  - Stage
 *  - KindOfUnit
 *  - Sex
 *  - ReferenceSystem
 *  - State
 *  - NaturalLanguageTerm
 *  - TextFormat
 *  - DeterminationModifier
 *  - DnaMarker
 *
 * @param  $order_by
 *  Optionally sort option (default: CDM_ORDER_BY_TITLE_CACHE_ASC)
 *  possible values:
 *    - CDM_ORDER_BY_ID_ASC
 *    - CDM_ORDER_BY_ID_DESC
 *    - CDM_ORDER_BY_TITLE_CACHE_ASC
 *    - CDM_ORDER_BY_TITLE_CACHE_DESC
 *    - CDM_ORDER_BY_ORDER_INDEX_ASC (can only be used with OrderedTerms!!)
 *    - CDM_ORDER_BY_ORDER_INDEX_DESC (can only be used with OrderedTerms!!)
 * @param bool $empty_option
 *   An additional element do be placed at the beginning og the list. This element will be the default option.
 * @return array
 *    the terms in an array (key: uuid => value: label) as options for a form element that allows multiple choices.
 */
function cdm_terms_by_type_as_option($term_type, $order_by = CDM_ORDER_BY_TITLE_CACHE_ASC, $term_label_callback = NULL, $empty_option = FALSE){
  $terms = cdm_ws_fetch_all(
    CDM_WS_TERM,
    array(
      'class' => $term_type,
      'orderBy' => $order_by
    )
  );
  return cdm_terms_as_options($terms, $term_label_callback, $empty_option);
}

/**
 * @param array $none_option
 *    Will add a filter option to search for NULL values
 * @param $with_empty_option
 *    Will add an empty option to the beginning. Choosing this option will disable the filtering.
 * @return array
 *   An array of options with uuids as key and the localized term representation as value
 */
function cdm_type_designation_status_filter_terms_as_options($none_option_label, $with_empty_option = false){
  $filter_terms = cdm_ws_get(CDM_WS_TYPE_DESIGNATION_STATUS_FILTER_TERMS);

  $options = [];

  if(isset($filter_terms) && is_array($filter_terms)) {
    foreach ($filter_terms as $filter_term) {
      $options[join(',', $filter_term->uuids)] = $filter_term->label;
    }
  }

  if(is_string($none_option_label)){
    $options = array_merge(array('NULL' => $none_option_label), $options);
  }

  if($with_empty_option !== FALSE){
    array_unshift ($options, "");
  }

  return $options;
}



/**
 * Callback function which provides the localized representation of a cdm term.
 *
 * The representation is build by concatenating the abbreviated label with the label
 * and thus is especially useful for relationship terms
 * The localized representation provided by the cdm can be overwritten by
 * providing a drupal translation.
 *
 */
function _cdm_relationship_type_term_label_callback($term) {
  if (isset($term->representation_L10n_abbreviatedLabel)) {
    return $term->representation_L10n_abbreviatedLabel . ' : '
    . t('@term', array('@term' => $term->representation_L10n));
  }
else {
    return t('@term', array('@term' => $term->representation_L10n));
  }
}

/**
 * Callback function which provides the localized inverse representation of a cdm term.
 *
 * The representation is build by concatenating the abbreviated label with the label
 * and thus is especially useful for relationship terms
 * The localized representation provided by the cdm can be overwritten by
 * providing a drupal translation.
 *
 */
function _cdm_relationship_type_term_inverse_label_callback($term) {
  if (isset($term->inverseRepresentation_L10n_abbreviatedLabel)) {
    return $term->inverseRepresentation_L10n_abbreviatedLabel . ' : '
      . t('@term', array('@term' => $term->inverseRepresentation_L10n));
  }
  else {
    return t('@term', array('@term' => $term->inverseRepresentation_L10n));
  }
}

/**
 * Returns the localized abbreviated label of the relationship term.
 *
 * In case the abbreviated label is not set the normal representation is returned.
 *
 * @param $term
 * @param bool $is_inverse_relation
 * @return string
 *   The abbreviated label
 */
function cdm_relationship_type_term_abbreviated_label($term, $is_inverse_relation = false){

  if($is_inverse_relation) {
    if (isset($term->inverseRepresentation_L10n_abbreviatedLabel) && $term->inverseRepresentation_L10n_abbreviatedLabel) {
      $abbr_label = $term->inverseResentation_L10n_abbreviatedLabel;
    } else {
      $abbr_label = $term->inverseRepresentation_L10n;
    }
  } else {
    if (isset($term->representation_L10n_abbreviatedLabel) && $term->representation_L10n_abbreviatedLabel) {
      $abbr_label = $term->representation_L10n_abbreviatedLabel;
    } else {
      $abbr_label = $term->representation_L10n;
    }
  }
  return $abbr_label;
}

/**
 * Returns the symbol of the relationship term.
 *
 * In case the symbol is not set the function falls back to use the abbreviated label or
 * the normal representation..
 *
 * @param $term
 * @param bool $is_inverse_relation
 * @return string
 *   The abbreviated label
 */
function cdm_relationship_type_term_symbol($term, $is_inverse_relation = false){

  if($is_inverse_relation) {
    if (isset($term->inverseSymbol) && $term->inverseSymbol) {
      $symbol = $term->inverseSymbol;
    } else if (isset($term->inverseRepresentation_L10n_abbreviatedLabel) && $term->inverseRepresentation_L10n_abbreviatedLabel) {
      $symbol = $term->inverseResentation_L10n_abbreviatedLabel;
    } else {
      $symbol = $term->inverseRepresentation_L10n;
    }
  } else {
    if (isset($term->symbol) && $term->symbol) {
      $symbol = $term->symbol;
    } else if (isset($term->representation_L10n_abbreviatedLabel) && $term->representation_L10n_abbreviatedLabel) {
      $symbol = $term->representation_L10n_abbreviatedLabel;
    } else {
      $symbol = $term->representation_L10n;
    }
  }
  return $symbol;
}

// ========================================================================================== //
/**
 * @todo Improve documentation of this function.
 *
 * eu.etaxonomy.cdm.model.description.
 * CategoricalData
 * CommonTaxonName
 * Distribution
 * IndividualsAssociation
 * QuantitativeData
 * TaxonInteraction
 * TextData
 */
function cdm_descriptionElementTypes_as_option($prependEmptyElement = FALSE) {
  static $types = array(
    "CategoricalData",
    "CommonTaxonName",
    "Distribution",
    "IndividualsAssociation",
    "QuantitativeData",
    "TaxonInteraction",
    "TextData",
  );

  static $options = NULL;
  if ($options == NULL) {
    $options = array();
    if ($prependEmptyElement) {
      $options[' '] = '';
    }
    foreach ($types as $type) {
      // No internatianalization here since these are purely technical terms.
      $options["eu.etaxonomy.cdm.model.description." . $type] = $type;
    }
  }
  return $options;
}


/**
 * Fetches all TaxonDescription descriptions elements which are associated to the
 * Taxon specified by the $taxon_uuid and merges the elements into the given
 * feature tree.
 * @param $feature_tree
 *     The CDM FeatureTree to be used as template
 * @param $taxon_uuid
 *     The UUID of the taxon
 * @param $excludes
 *     UUIDs of features to be excluded
 * @return object
 *     The CDM FeatureTree which was given as parameter merged tree whereas the
 *     CDM FeatureNodes are extended by an additional field 'descriptionElements'
 *     witch will hold the according $descriptionElements.
 */
function cdm_ws_descriptions_by_featuretree($feature_tree, $taxon_uuid, $exclude_uuids = array()) {

  if (!$feature_tree) {
    drupal_set_message(check_plain(t("No 'FeatureTree' has been set so far.
      In order to see the species profiles of your taxa, please select a
      'FeatureTree' in the !settings"), array('!settings' => l(t('CDM Dataportal Settings'), 'admin/config/cdm_dataportal/layout'))), 'warning');
    return FALSE;
  }

  $description_elements = cdm_ws_fetch_all(CDM_WS_DESCRIPTIONELEMENT_BY_TAXON,
      array(
      'taxon' => $taxon_uuid,
      'features' => cdm_featureTree_elements_toString($feature_tree->root, ',', 'uuid', $exclude_uuids)
      ),
      'POST'
  );

  // Combine all descriptions into one feature tree.
  $merged_nodes = _mergeFeatureTreeDescriptions($feature_tree->root->childNodes, $description_elements);
  $feature_tree->root->childNodes = $merged_nodes;

  return $feature_tree;
}

/**
 * Returns a filtered a list of annotations for the cdm entity given as parameter $cdm_entity.
 * If the annotations are not yet already loded with the cdm entity the cdm REST service will
 * be requested for the annotations.
 *
 * @param string $cdm_entity_or_dto
 *   An annotatable cdm entity, or corresponding DTO, DTOs containig AnnotationDTOs
 *     in an array field named 'annotations' is supported by this method.
 * @param array $include_types
 *   If an array of annotation type uuids is supplied by this parameter the
 *   list of annotations is resticted to those which belong to this type.
 *
 * @return array
 *   An array of Annotation objects or an empty array.
 */
function cdm_ws_fetch_annotations(&$cdm_entity_or_dto, $include_types = FALSE) {

  if(!isset($cdm_entity_or_dto->annotations)){
    $annotation_url = cdm_compose_annotations_uri($cdm_entity_or_dto);
    $cdm_entity_or_dto->annotations = cdm_ws_fetch_all($annotation_url, array(), 'GET', TRUE);
  }

  $annotations_or_dtos = array();
  foreach ($cdm_entity_or_dto->annotations as $annotation_or_dto) {
    if ($include_types) {
      $is_dto = is_cdm_dto($annotation_or_dto);
      if (($is_dto ? annotation_dto_has_type($annotation_or_dto, $include_types) : annotation_has_type($annotation_or_dto, $include_types))) {
        $annotations_or_dtos[] = $annotation_or_dto;
      }
    }
    else {
      $annotations_or_dtos[] = $annotation_or_dto;
    }
  }
  return $annotations_or_dtos;
}

/**
 * @param $annotation
 * @param array $include_types
 *
 * @return bool
 */
function annotation_has_type($annotation, array $include_types) {
  return (isset($annotation->annotationType->uuid) && in_array($annotation->annotationType->uuid, $include_types, TRUE))
    || ($annotation->annotationType === NULL && in_array('NULL_VALUE', $include_types, TRUE));
}

/**
 * @param $annotation_dto
 * @param array $include_types
 *
 * @return bool
 */
function annotation_dto_has_type($annotation_dto, array $include_types) {
  return (isset($annotation_dto->annotationTypeUuid) && in_array($annotation_dto->annotationTypeUuid, $include_types, TRUE))
    || ($annotation_dto->annotationTypeUuid === NULL && in_array('NULL_VALUE', $include_types, TRUE));
}

/**
 * Tests if the passed object is a DTO exposed by the cdm webservices.
 * All these DTOs contain a field `class` with the Java class simple name
 * as value. As all DTO classes are suffixed with "DTO" this method can test
 * for this class name suffix.
 *
 * @param $cdm_dto
 *  The potential cdm dto to test
 *
 * @return bool
 *  True in case the $cdm_dto is a DTO
 */
function is_cdm_dto(&$cdm_dto) {
  return isset_not_empty($cdm_dto->type) && isset_not_empty($cdm_dto->class) && str_endsWith($cdm_dto->class , 'DTO');
}

/**
 * Provides the list of visible annotations for the $cdm_entity.
 *
 * @param $cdm_entity_or_dto
 *     The annotatable CDM entity or corresponding DTO, DTOs containig AnnotationDTOs
 *     in an array field named 'annotations' is supported by this method
 *
 * @return array of the annotations entities or DTOs which are visible according
 *     to the settings as stored in ANNOTATION_TYPES_VISIBLE
 */
function cdm_fetch_visible_annotations($cdm_entity_or_dto){

  static $annotations_types_filter = null;
  if(!$annotations_types_filter) {
    $annotations_types_filter = unserialize(EXTENSION_TYPES_VISIBLE_DEFAULT);
  }
  return cdm_ws_fetch_annotations($cdm_entity_or_dto, variable_get(ANNOTATION_TYPES_VISIBLE, $annotations_types_filter));
}

function cdm_load_tagged_full_title($taxon_name){
  if(isset($taxon_name) && !isset($taxon_name->taggedFullTitle)){
    $tagged_full_title = cdm_ws_get(CDM_WS_NAME, array($taxon_name->uuid, 'taggedFullTitle'));
    if(is_array($tagged_full_title)){
      $taxon_name->taggedFullTitle = $tagged_full_title;

    }
  }
}

/**
 * Extends the $cdm_entity object by the field if it is not already existing.
 *
 * This function can only be used for fields with 1 to many relations.
  *
 * @param $cdm_base_type
 * @param $field_name
 * @param $cdm_entity
 */
function cdm_lazyload_array_field($cdm_base_type, $field_name, &$cdm_entity)
{
  if (!isset($cdm_entity->$field_name)) {
    $items = cdm_ws_fetch_all('portal/' . $cdm_base_type . '/' . $cdm_entity->uuid . '/' . $field_name);
    $cdm_entity->$field_name = $items;
  }
}


/**
 * Get a NomenclaturalReference string.
 *
 * Returns the NomenclaturalReference string with correctly placed
 * microreference (= reference detail) e.g.
 * in Phytotaxa 43: 1-48. 2012.
 *
 * @param string $referenceUuid
 *   UUID of the reference.
 * @param string $microreference
 *   Reference detail.
 *
 * @return string
 *   a NomenclaturalReference.
 */
function cdm_ws_getNomenclaturalReference($referenceUuid, $microreference) {

  // TODO the below statement avoids error boxes due to #4644 remove it once this ticket is solved
  if(is_array($microreference) || is_object($microreference)) {
    return '';
  }

  $obj = cdm_ws_get(CDM_WS_NOMENCLATURAL_REFERENCE_CITATION, array(
    $referenceUuid,
  ), "microReference=" . urlencode($microreference));

  if ($obj) {
    return $obj->String;
  }
  else {
    return NULL;
  }
}

/**
 * finds and returns the FeatureNode denoted by the given $feature_uuid
 *
 * @param $feature_tree_nodes
 *    The nodes contained in CDM FeatureTree entitiy: $feature->root->childNodes
 * @param $feature_uuid
 *    The UUID of the Feature
 * @return object
 *    the FeatureNode or null
 */
function &cdm_feature_tree_find_node($feature_tree_nodes, $feature_uuid){

  // 1. scan this level
  foreach ($feature_tree_nodes as $node){
    if($node->term->uuid == $feature_uuid){
      return $node;
    }
  }

  // 2. descend into childen
  foreach ($feature_tree_nodes as $node){
    if(is_array($node->childNodes)){
      $node = cdm_feature_tree_find_node($node->childNodes, $feature_uuid);
      if($node) {
        return $node;
      }
    }
  }
  $null_var = null; // kludgy workaround to avoid "PHP Notice: Only variable references should be returned by reference"
  return $null_var;
}

/**
 * Merges the given featureNodes structure with the descriptionElements.
 *
 * This method is used in preparation for rendering the descriptionElements.
 * The descriptionElements which belong to a specific feature node are appended
 * to a the feature node by creating a new field:
 *  - descriptionElements: the CDM DescriptionElements which belong to this feature
 * The descriptionElements will be cleared in advance in order to allow reusing the
 * same feature tree without the risk of mixing sets of description elements.
 *
 * which originally is not existing in the cdm.
 *
 *
 *
 * @param array $featureNodes
 *    An array of cdm FeatureNodes which may be hierarchical since feature nodes
 *    may have children.
 * @param array $descriptionElements
 *    An flat array of cdm DescriptionElements
 * @return array
 *    The $featureNodes structure enriched with the according $descriptionElements
 */
function _mergeFeatureTreeDescriptions($featureNodes, $descriptionElements) {

  foreach ($featureNodes as &$feature_node) {
    // since the $featureNodes array is reused for each description
    // it is necessary to clear the custom node fields in advance
    if(isset($feature_node->descriptionElements)){
      unset($feature_node->descriptionElements);
    }

    // Append corresponding elements to an additional node field:
    // $node->descriptionElements.
    foreach ($descriptionElements as $element) {
      if ($element->feature->uuid == $feature_node->term->uuid) {
        if (!isset($feature_node->descriptionElements)) {
          $feature_node->descriptionElements = array();
        }
        $feature_node->descriptionElements[] = $element;
      }
    }

    // Recurse into node children.
    if (isset($feature_node->childNodes[0])) {
      $mergedChildNodes = _mergeFeatureTreeDescriptions($feature_node->childNodes, $descriptionElements);
      $feature_node->childNodes = $mergedChildNodes;
    }

    if(!isset($feature_node->descriptionElements) && !isset($feature_node->childNodes[0])){
      unset($feature_node);
    }

  }

  return $featureNodes;
}

/**
 * Sends a GET or POST request to a CDM RESTService and returns a de-serialized object.
 *
 * The response from the HTTP GET request is returned as object.
 * The response objects coming from the webservice configured in the
 * 'cdm_webservice_url' variable are being cached in a level 1 (L1) and / or
 *  in a level 2 (L2) cache.
 *
 * Since the L1 cache is implemented as static variable of the cdm_ws_get()
 * function, this cache persists only per each single page execution.
 * Any object coming from the webservice is stored into it by default.
 * In contrast to this default caching mechanism the L2 cache only is used if
 * the 'cdm_webservice_cache' variable is set to TRUE,
 * which can be set using the modules administrative settings section.
 * Objects stored in this L2 cache are serialized and stored
 * using the drupal cache in the '{prefix}cache_cdm_ws' cache table. So the
 * objects that are stored in the database will persist as
 * long as the drupal cache is not being cleared and are available across
 * multiple script executions.
 *
 * @param string $uri
 *   URL to the webservice.
 * @param array $pathParameters
 *   An array of path parameters.
 * @param string $query_string
 *   A query_string string to be appended to the URL.
 * @param string $method
 *   The HTTP method to use, valid values are "GET" or "POST";
 * @param bool $absoluteURI
 *   TRUE when the URL should be treated as absolute URL.
 *
 * @return object| array
 *   The de-serialized webservice response object.
 */
function cdm_ws_get($uri, $pathParameters = array(), $query_string = NULL, $method = "GET", $absoluteURI = FALSE) {

  static $cacheL1 = array();

  $data = NULL;
  // store query_string string in $data and clear the query_string, $data will be set as HTTP request body
  if($method == 'POST'){
    $data = $query_string;
    $query_string = NULL;
  }

  // Transform the given uri path or pattern into a proper webservice uri.
  if (!$absoluteURI) {
    $uri = cdm_compose_ws_url($uri, $pathParameters, $query_string);
  } else {
    if($query_string){
      $uri = append_query_parameters($uri, $query_string);
    }
  }
  cdm_ws_apply_classification_subtree_filter($uri);

  // read request parameter 'cacheL2_refresh'
  // which allows refreshing the level 2 cache
  $do_cacheL2_refresh = isset($_REQUEST['cacheL2_refresh']) && $_REQUEST['cacheL2_refresh'] == 1;

  $is_cdm_ws_uri = _is_cdm_ws_uri($uri);
  $use_cacheL2 = variable_get('cdm_webservice_cache', 1);

  if($method == 'GET'){
    $cache_key = $uri;
  } else {
    // sha1 creates longer hashes and thus will cause fewer collisions than md5.
    // crc32 is faster but creates much shorter hashes
    $cache_key = $uri . '[' . $method . ':' . sha1($data) .']';
  }

  if (array_key_exists($cache_key, $cacheL1)) {
    $cacheL1_obj = $cacheL1[$uri];
  }

  $set_cacheL1 = FALSE;
  if ($is_cdm_ws_uri && !isset($cacheL1_obj)) {
    $set_cacheL1 = TRUE;
  }

  // Only cache cdm webservice URIs.
  $set_cacheL2 = $use_cacheL2 && $is_cdm_ws_uri && $set_cacheL1;
  $cacheL2_entry = FALSE;

  if ($use_cacheL2 && !$do_cacheL2_refresh) {
    // Try to get object from cacheL2.
    $cacheL2_entry = cache_get($cache_key, 'cache_cdm_ws');
  }

  if (isset($cacheL1_obj)) {
    //
    // The object has been found in the L1 cache.
    //
    $obj = $cacheL1_obj;
    if (cdm_debug_block_visible()) {
      cdm_ws_debug_add($uri, $method, $data, 0, 0, NULL, 'cacheL1');
    }
  }
  elseif ($cacheL2_entry) {
    //
    // The object has been found in the L2 cache.
    //
    $duration_parse_start = microtime(TRUE);
    $obj = unserialize($cacheL2_entry->data);
    $duration_parse = microtime(TRUE) - $duration_parse_start;

    if (cdm_debug_block_visible()) {
      cdm_ws_debug_add($uri, $method, $data, 0, $duration_parse, NULL, 'cacheL2');
    }
  }
  else {
    //
    // Get the object from the webservice and cache it.
    //
    $duration_fetch_start = microtime(TRUE);
    // Request data from webservice JSON or XML.
    $response = cdm_http_request($uri, $method, $data);
    $response_body = NULL;
    if (isset($response->data)) {
      $response_body = $response->data;
    }
    $duration_fetch = microtime(TRUE) - $duration_fetch_start;
    $duration_parse_start = microtime(TRUE);

    // Parse data and create object.
    $obj = cdm_load_obj($response_body);

    if(isset($obj->servlet) && isset($obj->status) && is_numeric($obj->status)){
      // this is json error message returned by jetty #8914
      // wee need to replace it by null to avoid breaking existing assumptions in the code here
      // this is also related to #2711
      $obj = null;
    }

    $duration_parse = microtime(TRUE) - $duration_parse_start;

    if (cdm_debug_block_visible()) {
      if ($obj || $response_body == "[]") {
        $status = 'valid';
      }
      else {
        $status = 'invalid';
      }
      cdm_ws_debug_add($uri, $method, $data, $duration_fetch, $duration_parse, strlen($response_body), $status);
    }
    if ($set_cacheL2) {
      // Store the object in cache L2.
      // Comment @WA perhaps better if Drupal serializedatas here? Then the
      // flag serialized is set properly in the cache table.
      cache_set($cache_key, serialize($obj), 'cache_cdm_ws', CACHE_TEMPORARY);
    }
  }
  if ($obj) {
    // Store the object in cache L1.
    if ($set_cacheL1) {
      $cacheL1[$cache_key] = $obj;
    }
  }
  return $obj;
}

function cdm_ws_apply_classification_subtree_filter(&$uri){

  $classification_subtree_filter_patterns = &drupal_static('classification_subtree_filter_patterns', array(
    "#/classification/[0-9a-f\-]{36}/childNodes#",
    /* covered by above pattern:
    "#/classification/[0-9a-f\-]{36}/childNodesAt/[0-9a-f\-]{36}#",
    '#/classification/[0-9a-f\-]{36}/childNodesOf/[0-9a-f\-]{36}#',
    */
    "#/portal/classification/[0-9a-f\-]{36}/childNodes#",
    /* covered by above pattern:
    "#/portal/classification/[0-9a-f\-]{36}/childNodesAt/[0-9a-f\-]{36}#",
    '#/portal/classification/[0-9a-f\-]{36}/childNodesOf/[0-9a-f\-]{36}#',
    */
    '#/portal/classification/[0-9a-f\-]{36}/pathFrom/[0-9a-f\-]{36}#',
    "#/portal/taxon/search#",
    "#/portal/taxon/find#",
    /* covered by above pattern:
    "#/portal/taxon/findByDescriptionElementFullText#",
    "#/portal/taxon/findByFullText#",
    "#/portal/taxon/findByEverythingFullText#",
    "#/portal/taxon/findByIdentifier#",
    "#/portal/taxon/findByMarker#",
    "#/portal/taxon/findByMarker#",
    "#/portal/taxon/findByMarker#",
    */
    "#/portal/taxon/[0-9a-f\-]{36}#"
    /* covered by above pattern:
    "#/portal/taxon/[0-9a-f\-]{36}/taxonNodes#",
    */
  ));

  $sub_tree_filter_uuid_value = variable_get(CDM_SUB_TREE_FILTER_UUID, FALSE);
  if(is_uuid($sub_tree_filter_uuid_value)){
    foreach($classification_subtree_filter_patterns as $preg_pattern){
      if(preg_match($preg_pattern, $uri)){
        // no need to take care for uri fragments with ws uris!
        if(strpos( $uri, '?')){
          $uri .= '&subtree=' . $sub_tree_filter_uuid_value;
        } else {
          $uri .= '?subtree='. $sub_tree_filter_uuid_value;
        }
        break;
      }
    }
  }

}
/**
 * Processes and stores the given information in $_SESSION['cdm']['ws_debug'] as table row.
 *
 * The cdm_ws_debug block will display the debug information.
 *
 * @param $uri
 *    The CDM REST URI to which the request has been send
 * @param string $method
 *    The HTTP request method, either 'GET' or 'POST'
 * @param string $post_data
 *    The datastring send with a post request
 * @param $duration_fetch
 *    The time in seconds it took to fetch the data from the web service
 * @param $duration_parse
 *    Time in seconds which was needed to parse the json response
 * @param $datasize
 *    Size of the data received from the server
 * @param $status
 *    A status string, possible values are: 'valid', 'invalid', 'cacheL1', 'cacheL2'
 * @return bool
 *    TRUE if adding the debug information was successful
 */
function cdm_ws_debug_add($uri, $method, $post_data, $duration_fetch, $duration_parse, $datasize, $status) {

  static $initial_time = NULL;
  if(!$initial_time) {
    $initial_time = microtime(TRUE);
  }
  $time = microtime(TRUE) - $initial_time;

  // Decompose uri into path and query element.
  $uri_parts = explode("?", $uri);
  $query = array();
  if (count($uri_parts) == 2) {
    $path = $uri_parts[0];
  }
  else {
    $path = $uri;
  }

  if(strpos($uri, '?') > 0){
    $json_uri = str_replace('?', '.json?', $uri);
    $xml_uri = str_replace('?', '.xml?', $uri);
  } else {
    $json_uri = $uri . '.json';
    $xml_uri = $json_uri . '.xml';
  }

  // data links to make data accessible as json and xml
  $data_links = '';
  if (_is_cdm_ws_uri($path)) {

    // see ./js/http-method-link.js

    if($method == 'GET'){
      $data_links .= '<a href="' . $xml_uri . '" target="data">xml</a>-';
      $data_links .= '<a href="' . url('cdm_api/proxy/' . urlencode($xml_uri)) . '" target="data">proxied</a>';
      $data_links .= '<br/>';
      $data_links .= '<a href="' . $json_uri . '" target="data">json</a>-';
      $data_links .= '<a href="' . url('cdm_api/proxy/' . urlencode($json_uri)) . '" target="data">proxied</a>';
    } else {
      $js_link_activation = 'class="http-' . $method . '-link" data-cdm-http-post="' . $post_data . '" type="application/x-www-form-urlencoded"';
      $data_links .= '<a ' . $js_link_activation . ' href="' . url('cdm_api/proxy/' . urlencode($xml_uri)) . '" target="data">xml-proxied</a>';
      $data_links .= '<br/>';
      $data_links .= '<a ' . $js_link_activation . ' href="' . url('cdm_api/proxy/' . urlencode($json_uri)) . '" target="data">json-proxied</a>';
    }
  }
  else {
    $data_links .= '<a href="' . $uri . '" target="data">open</a>';
  }

  //
  $data = array(
      'ws_uri' => $uri,
      'method' => $method,
      'post_data' => $post_data,
      'time' => sprintf('%3.3f', $time),
      'fetch_seconds' => sprintf('%3.3f', $duration_fetch),
      'parse_seconds' => sprintf('%3.3f', $duration_parse),
      'size_kb' => sprintf('%3.1f', ($datasize / 1024)) ,
      'status' => $status,
      'data_links' => $data_links
  );
  if (!isset($_SESSION['cdm']['ws_debug'])) {
    $_SESSION['cdm']['ws_debug'] = array();
  }
  $_SESSION['cdm']['ws_debug'][] = serialize($data);

  // Mark this page as being uncacheable.
  // taken over from drupal_get_messages() but it is unsure if we really need this here
  drupal_page_is_cacheable(FALSE);

  // Messages not set when DB connection fails.
  return isset($_SESSION['cdm']['ws_debug']) ? $_SESSION['cdm']['ws_debug'] : NULL;
}

/**
 * helper function to dtermine if the cdm_debug_block should be displayed or not
 * the visibility depends on whether
 *  - the block is enabled
 *  - the visibility restrictions in the block settings are satisfied
 */
function cdm_debug_block_visible() {
  static $is_visible = null;

  if($is_visible === null){
      $block = block_load('cdm_api', 'cdm_ws_debug');
      $is_visible = isset($block->status) && $block->status == 1;
      if($is_visible){
        $blocks = array($block);
        // Checks the page, user role, and user-specific visibilty settings.
        block_block_list_alter($blocks);
        $is_visible = count($blocks) > 0;
      }
  }
  return $is_visible;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_load_obj($response_body) {
  $obj = json_decode($response_body);

  if (!(is_object($obj) || is_array($obj))) {
    ob_start();
    $obj_dump = ob_get_contents();
    ob_clean();
    return FALSE;
  }

  return $obj;
}

/**
 * Do a http request to a CDM RESTful web service.
 *
 * @param string $uri
 *   The webservice url.
 * @param string $method
 *   The HTTP method to use, valid values are "GET" or "POST"; defaults to
 *   "GET" even if NULL, FALSE or any invalid value is supplied.
 * @param $data: A string containing the request body, formatted as
 *     'param=value&param=value&...'. Defaults to NULL.
 *
 * @return object
 *   The object as returned by drupal_http_request():
 *   An object that can have one or more of the following components:
 *   - request: A string containing the request body that was sent.
 *   - code: An integer containing the response status code, or the error code
 *     if an error occurred.
 *   - protocol: The response protocol (e.g. HTTP/1.1 or HTTP/1.0).
 *   - status_message: The status message from the response, if a response was
 *     received.
 *   - redirect_code: If redirected, an integer containing the initial response
 *     status code.
 *   - redirect_url: If redirected, a string containing the URL of the redirect
 *     target.
 *   - error: If an error occurred, the error message. Otherwise not set.
 *   - headers: An array containing the response headers as name/value pairs.
 *     HTTP header names are case-insensitive (RFC 2616, section 4.2), so for
 *     easy access the array keys are returned in lower case.
 *   - data: A string containing the response body that was received.
 */
function cdm_http_request($uri, $method = "GET", $data = NULL) {
  static $acceptLanguage = NULL;
  $header = array();
  
  if(!$acceptLanguage && module_exists('i18n')){
    $acceptLanguage = i18n_language_content()->language;
  }

  if (!$acceptLanguage) {
    if (function_exists('apache_request_headers')) {
      $headers = apache_request_headers();
      if (isset($headers['Accept-Language'])) {
        $acceptLanguage = $headers['Accept-Language'];
      }
    }
  }

  if ($method != "GET" && $method != "POST") {
    drupal_set_message('cdm_api.module#cdm_http_request() : unsupported HTTP request method ', 'error');
  }

  if (_is_cdm_ws_uri($uri)) {
    $header['Accept'] = 'application/json';
    $header['Accept-Language'] = $acceptLanguage;
    $header['Accept-Charset'] = 'UTF-8';
  }

  if($method == "POST") {
    // content type is application/x-www-form-urlencoded, so the request body uses the same format as the query string
    $header['Content-Type'] = 'application/x-www-form-urlencoded';
  }

  $context_resource = null;
  if(!variable_get('cdm_webservice_url_ssl_verify', 1)){
    $context_resource = stream_context_create(array('ssl' => array('verify_peer' => FALSE, 'verify_peer_name' => FALSE)));
  }
  cdm_dd($uri);
  return drupal_http_request($uri, array(
      'headers' => $header,
      'method' => $method,
      'data' => $data,
      'timeout' => CDM_HTTP_REQUEST_TIMEOUT,
      'context' => $context_resource
      )
   );
}

/**
 * Concatenates recursively the fields of all features contained in the given
 * CDM FeatureTree root node.
 *
 * @param $rootNode
 *     A CDM FeatureTree node
 * @param
 *     The character to be used as glue for concatenation, default is ', '
 * @param $field_name
 *     The field name of the CDM Features
 * @param $excludes
 *     Allows defining a set of values to be excluded. This refers to the values
 *     in the field denoted by the $field_name parameter
 *
 */
function cdm_featureTree_elements_toString($root_node, $separator = ', ', $field_name = 'representation_L10n', $excludes = array()) {
  $out = '';

  $pre_child_separator = $separator;
  $post_child_separator = '';

  foreach ($root_node->childNodes as $feature_node) {
    $out .= ($out ? $separator : '');
    if(!in_array($feature_node->term->$field_name, $excludes)) {
      $out .= $feature_node->term->$field_name;
      if (is_array($feature_node->childNodes) && count($feature_node->childNodes) > 0) {
        $childlabels = cdm_featureTree_elements_toString($feature_node, $separator, $field_name);
        if (strlen($childlabels)) {
            $out .=  $pre_child_separator . $childlabels . $post_child_separator;
        }
      }
    }
  }
  return $out;
}

/**
 * Create a one-dimensional form options array.
 *
 * Creates an array of all features in the feature tree of feature nodes,
 * the node labels are indented by $node_char and $childIndent depending on the
 * hierachy level.
 *
 * @param - $rootNode
 * @param - $node_char
 * @param - $childIndentStr
 * @param - $childIndent
 *   ONLY USED INTERNALLY!
 *
 * @return array
 *   A one dimensional Drupal form options array.
 */
function _featureTree_nodes_as_feature_options($rootNode, $node_char = "&#9500;&#9472; ", $childIndentStr = '&nbsp;', $childIndent = '') {
  $options = array();
  foreach ($rootNode->childNodes as $featureNode) {
    $indent_prefix = '';
    if ($childIndent) {
      $indent_prefix = $childIndent . $node_char . " ";
    }
    $options[$featureNode->term->uuid] = $indent_prefix . $featureNode->term->representation_L10n;
    if (isset($featureNode->childNodes) && is_array($featureNode->childNodes)) {
      // Foreach ($featureNode->childNodes as $childNode){
      $childList = _featureTree_nodes_as_feature_options($featureNode, $node_char, $childIndentStr, $childIndent . $childIndentStr);
      $options = array_merge_recursive($options, $childList);
      // }
    }
  }
  return $options;
}

/**
 * Returns an array with all available FeatureTrees and the representations of the selected
 * FeatureTree as a detail view.
 *
 * @param boolean $add_default_feature_free
 * @param boolean $show_weight
 *     Show the weight which will be applied to the according feature block
 * @return array
 *  associative array with following keys:
 *  -options: Returns an array with all available Feature Trees
 *  -treeRepresentations: Returns representations of the selected Feature Tree as a detail view
 *
 */
function cdm_get_featureTrees_as_options($add_default_feature_free = FALSE, $show_weight = FALSE) {

  $options = array();
  $tree_representations = array();
  $feature_trees = array();

  // Set tree that contains all features.
  if ($add_default_feature_free) {
    $options[UUID_DEFAULT_FEATURETREE] = t('Default Featuretree (contains all features)');
    $feature_trees[] = cdm_ws_get(CDM_WS_TERMTREE, UUID_DEFAULT_FEATURETREE);
  }

  // Get feature trees from database.
  $persited_trees = cdm_ws_fetch_all(CDM_WS_TERMTREES, array("termType" => "Feature"));
  if (is_array($persited_trees)) {
    $feature_trees = array_merge($feature_trees, $persited_trees);
  }

  foreach ($feature_trees as $featureTree) {

    if(!is_object($featureTree)){
      continue;
    }
    // Do not add the DEFAULT_FEATURETREE again,
    if ($featureTree->uuid != UUID_DEFAULT_FEATURETREE) {
      $options[$featureTree->uuid] = $featureTree->representation_L10n;
    }

    // Render the hierarchic tree structure
    if (is_array( $featureTree->root->childNodes) && count( $featureTree->root->childNodes) > 0) {

      // Render the hierarchic tree structure.
      $treeDetails = '<div class="featuretree_structure">'
        . render_feature_tree_hierarchy($featureTree->uuid, $show_weight)
        . '</div>';

      $form = array();
      $form['featureTree-' .  $featureTree->uuid] = array(
        '#type' => 'fieldset',
        '#title' => 'Show details',
        '#attributes' => array('class' => array('collapsible collapsed')),
        // '#collapsible' => TRUE,
        // '#collapsed' => TRUE,
      );
      $form['featureTree-' .  $featureTree->uuid]['details'] = array(
        '#markup' => $treeDetails,
      );

      $tree_representations[$featureTree->uuid] = drupal_render($form);
    }

  } // END loop over feature trees

  // return $options;
  return array('options' => $options, 'treeRepresentations' => $tree_representations);
}

/**
 * Provides the list of available classifications in form of an options array.
 *
 * The options array is suitable for drupal form API elements that allow multiple choices.
 * @see http://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7#options
 *
 * The classifications are ordered alphabetically whereas the classification
 * chosen as default will always appear on top of the array, followed by a
 * blank line below.
 *
 * @param bool $add_none_option
 *   is true an additional 'none' option will be added if and only if there are
 *   more than one options. Defaults to FALSE
 *
 * @param $include_uuids
 *   The taxon tree uuids to be included, other taxon trees will be filtered out.
 *   You may want to use here:
 *   variable_get(CDM_TAXONTREE_INCLUDES, [])
 *
 *
 * @return array
 *   classifications in an array as options for a form element that allows multiple choices.
 */
function cdm_get_taxontrees_as_options($add_none_option = FALSE, $include_uuids = []) {

  $taxonTrees = cdm_ws_fetch_all(CDM_WS_PORTAL_TAXONOMY);

  $default_classification_uuid = variable_get(CDM_TAXONOMICTREE_UUID, FALSE);
  $default_classification_label = '';

  // add all classifications
  $taxonomic_tree_options = array();
  if ($add_none_option) {
    $taxonomic_tree_options['NONE'] = ' '; // one Space character at beginning to force on top;
  }
  if ($taxonTrees) {
    foreach ($taxonTrees as $tree) {
      if(is_array($include_uuids) && count($include_uuids) > 0 && array_search($tree->uuid, $include_uuids) === FALSE){
        continue;
      }
      if (!$default_classification_uuid || $default_classification_uuid != $tree->uuid) {
        $taxonomic_tree_options[$tree->uuid] = $tree->titleCache;
      } else {
        $taxonomic_tree_options[$tree->uuid] = '  '; // two Space characters to force on top but below 'none' option , will be replaced below by titleCache
        $default_classification_label = $tree->titleCache;
      }
    }
  }
  // oder alphabetically the space
  asort($taxonomic_tree_options);

  // now set the labels for none
  if ($add_none_option && count($taxonomic_tree_options) > 2) {
    $taxonomic_tree_options['NONE'] =t('--- ALL ---');
  } else {
    unset($taxonomic_tree_options['NONE']);
  }

  //   for default_classification
  if (is_uuid($default_classification_uuid)) {
    $taxonomic_tree_options[$default_classification_uuid] =
      $default_classification_label ? $default_classification_label : '--- INVALID CHOICE ---'
      . (count($taxonTrees) > 1 ? ' [' . t('DEFAULT CLASSIFICATION') . ']': '');
  }

  return $taxonomic_tree_options;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_api_secref_cache_prefetch(&$secUuids) {
  // Comment @WA: global variables should start with a single underscore
  // followed by the module and another underscore.
  global $_cdm_api_secref_cache;
  if (!is_array($_cdm_api_secref_cache)) {
    $_cdm_api_secref_cache = array();
  }
  $uniqueUuids = array_unique($secUuids);
  $i = 0;
  $param = '';
  while ($i++ < count($uniqueUuids)) {
    $param .= $secUuids[$i] . ',';
    if (strlen($param) + 37 > 2000) {
      _cdm_api_secref_cache_add($param);
      $param = '';
    }
  }
  if ($param) {
    _cdm_api_secref_cache_add($param);
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_api_secref_cache_get($secUuid) {
  global $_cdm_api_secref_cache;
  if (!is_array($_cdm_api_secref_cache)) {
    $_cdm_api_secref_cache = array();
  }
  if (!array_key_exists($secUuid, $_cdm_api_secref_cache)) {
    _cdm_api_secref_cache_add($secUuid);
  }
  return $_cdm_api_secref_cache[$secUuid];
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_api_secref_cache_clear() {
  global $_cdm_api_secref_cache;
  $_cdm_api_secref_cache = array();
}


/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function _cdm_api_secref_cache_add($secUuidsStr) {
  global $_cdm_api_secref_cache;
  $ref = cdm_ws_get(CDM_WS_REFERENCE, $secUuidsStr);
  // Batch fetching not jet reimplemented thus:
  /*
  $assocRefSTOs = array(); if($refSTOs) { foreach($refSTOs as $ref){
  $assocRefSTOs[$ref->uuid] = $ref; } $_cdm_api_secref_cache =
  array_merge($_cdm_api_secref_cache, $assocRefSTOs); }
  */
  $_cdm_api_secref_cache[$ref->uuid] = $ref;
}

/**
 * Checks if the given uri starts with a cdm webservice url.
 *
 * Checks if the uri starts with the cdm webservice url stored in the
 * Drupal variable 'cdm_webservice_url'.
 * The 'cdm_webservice_url' can be set in the admins section of the portal.
 *
 * @param string $uri
 *   The URI to test.
 *
 * @return bool
 *   True if the uri starts with a cdm webservice url.
 */
function _is_cdm_ws_uri($uri) {
  return str_beginsWith($uri, cdm_webservice_url('#EMPTY#'));
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function queryString($elements) {
  $query = '';
  foreach ($elements as $key => $value) {
    if (is_array($value)) {
      foreach ($value as $v) {
        $query .= (strlen($query) > 0 ? '&' : '') . $key . '=' . urlencode($v);
      }
    }
    else {
      $query .= (strlen($query) > 0 ? '&' : '') . $key . '=' . urlencode($value);
    }
  }
  return $query;
}

/**
 * Compares the given CDM Term instances by the  representationL10n.
 *
 * Can also be used with TermDTOs. To be used in usort()
 *
 * @see http://php.net/manual/en/function.usort.php
 *
 * @param $term1
 *   The first CDM Term instance
 * @param $term2
 *   The second CDM Term instance
 * @return int
 *   The result of the comparison
 */
function compare_terms_by_representationL10n($term1, $term2) {

  if (!isset($term1->representation_L10n)) {
    $term1->representationL10n = '';
  }
  if (!isset($term2->representation_L10n)) {
    $term2->representationL10n = '';
  }

  return strcmp($term1->representation_L10n, $term2->representation_L10n);
}

function compare_terms_by_order_index($term1, $term2) {


  if (!isset($term1->orderIndex)) {
    $a = 0;
  } else {
    $a = $term1->orderIndex;
  }
  if (!isset($term2->orderIndex)) {
    $b = 0;
  } else {
    $b = $term2->orderIndex;
  }

  if ($a == $b) {
    return 0;
  }
  return ($a < $b) ? -1 : 1;

}


/**
 * Make a 'deep copy' of an array.
 *
 * Make a complete deep copy of an array replacing
 * references with deep copies until a certain depth is reached
 * ($maxdepth) whereupon references are copied as-is...
 *
 * @see http://us3.php.net/manual/en/ref.array.php
 *
 * @param array $array
 * @param array $copy passed by reference
 * @param int $maxdepth
 * @param int $depth
 */
function array_deep_copy(&$array, &$copy, $maxdepth = 50, $depth = 0) {
  if ($depth > $maxdepth) {
    $copy = $array;
    return;
  }
  if (!is_array($copy)) {
    $copy = array();
  }
  foreach ($array as $k => &$v) {
    if (is_array($v)) {
      array_deep_copy($v, $copy[$k], $maxdepth, ++$depth);
    }
    else {
      $copy[$k] = $v;
    }
  }
}

/**
 * Concatenated the uuids of the passed cdm entity with `,` as glue.
 * The returned string is suitable for cdm webservices consuming UUIDList as
 * parameter
 *
 * @param array $cdm_entities
 *
 * @return string
 */
function cdm_uuid_list_parameter_value(array $cdm_entities){
  $uuids = [];
  foreach ($cdm_entities as $entity){
    if(isset($entity) && is_uuid($entity->uuid) ){
      $uuids[] = $entity->uuid;
    }
  }
  return  join(',', $uuids);
}

/**
 * Adds java script to create and enable a toggler for the cdm webservice debug block content.
 *
 */
function _add_js_ws_debug() {

  $data_tables_js = '/js/DataTables-1.9.4/media/js/jquery.dataTables.min.js';
  $colorbox_js = '/js/colorbox/jquery.colorbox-min.js';
  if (variable_get('cdm_js_devel_mode', FALSE)) {
    // use the developer versions of js libs
    $data_tables_js = '/js/DataTables-1.9.4/media/js/jquery.dataTables.js';
    $colorbox_js = '/js/colorbox/jquery.colorbox.js';
  }
  drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . $data_tables_js,
    array(
      'type' => 'file',
      'weight' => JS_LIBRARY,
      'cache' => TRUE)
    );

  drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . $colorbox_js,
    array(
      'type' => 'file',
      'weight' => JS_LIBRARY,
      'cache' => TRUE)
    );
  drupal_add_css(drupal_get_path('module', 'cdm_dataportal') . '/js/colorbox/colorbox.css');
  drupal_add_css(drupal_get_path('module', 'cdm_dataportal') . '/js/DataTables-1.9.4/media/css/cdm_debug_table.css');

  drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/ws_debug_block.js',
    array(
      'type' => 'file',
      'weight' => JS_LIBRARY,
      'cache' => TRUE)
    );
  drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/http-method-link.js',
    array(
    'type' => 'file',
    'weight' => JS_LIBRARY,
    'cache' => TRUE)
    );

}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function _no_classfication_uuid_message() {
  if (!cdm_ws_get(CDM_WS_PORTAL_TAXONOMY)) {
    return t('This DataPortal is not configured properly or the CDM-Server may be absent.') . ' Please check the ' . l(t('CDM web service URL'), 'admin/config/cdm_dataportal/settings/general') . t(', or contact the maintainer of this DataPortal.');
  }
  return t('This DataPortal is not configured properly.') . l(t('Please choose a valid classification'), 'admin/config/cdm_dataportal/settings/general') . t(', or contact the maintainer of this DataPortal.');
}

/**
 * Implementation of hook flush_caches
 *
 * Add custom cache tables to the list of cache tables that
 * will be cleared by the Clear button on the Performance page or whenever
 * drupal_flush_all_caches is invoked.
 *
 * @author W.Addink <waddink@eti.uva.nl>
 *
 * @return array
 *   An array with custom cache tables to include.
 */
function cdm_api_flush_caches() {
  return array('cache_cdm_ws');
}

/**
 * Logs if the drupal variable 'cdm_debug_mode' ist set true to drupal_debug.txt in the site's temp directory.
 *
 * @param $data
 *   The variable to log to the drupal_debug.txt log file.
 * @param $label
 *   (optional) If set, a label to output before $data in the log file.
 *
 * @return
 *   No return value if successful, FALSE if the log file could not be written
 *   to.
 *
 * @see cdm_dataportal_init() where the log file is reset on each requests
 * @see dd()
 * @see http://drupal.org/node/314112
 *
 */
function cdm_dd($data, $label = NULL) {
  if(module_exists('devel') && variable_get('cdm_debug_mode', FALSE) && file_stream_wrapper_get_class('temporary') ){
    return dd($data, $label);
  }
}

