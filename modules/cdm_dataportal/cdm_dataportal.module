<?php
/**
 * @file
 * Module to provide a CDM Dataportal.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 *
 * @author
 *   - Andreas Kohlbecker <a.kohlbecker@BGBM.org>
 *   - Wouter Addink <w.addink@eti.uva.nl> (migration from Drupal 5 to Drupal7)
 */

  module_load_include('php', 'cdm_dataportal', 'node_types');
  module_load_include('php', 'cdm_dataportal', 'settings');
  module_load_include('php', 'cdm_dataportal', 'help');
  module_load_include('php', 'cdm_dataportal', 'cdm_dataportal.search');

  module_load_include('inc', 'cdm_dataportal', 'includes/common');
  module_load_include('inc', 'cdm_dataportal', 'includes/name');
  module_load_include('inc', 'cdm_dataportal', 'includes/taxon');
  module_load_include('inc', 'cdm_dataportal', 'includes/references');
  module_load_include('inc', 'cdm_dataportal', 'includes/pages');
  module_load_include('inc', 'cdm_dataportal', 'includes/media');
  module_load_include('inc', 'cdm_dataportal', 'includes/maps');
  module_load_include('inc', 'cdm_dataportal', 'includes/occurrences');
  module_load_include('inc', 'cdm_dataportal', 'includes/descriptions');
  module_load_include('inc', 'cdm_dataportal', 'includes/pre-drupal8');

  module_load_include('inc', 'cdm_dataportal', 'theme/theme_registry');
  module_load_include('theme', 'cdm_dataportal', 'theme/cdm_dataportal.common');
  module_load_include('theme', 'cdm_dataportal', 'theme/cdm_dataportal.descriptions');
  module_load_include('theme', 'cdm_dataportal', 'theme/cdm_dataportal.media');
  module_load_include('theme', 'cdm_dataportal', 'theme/cdm_dataportal.occurrence');
  module_load_include('theme', 'cdm_dataportal', 'theme/cdm_dataportal.page');
  module_load_include('theme', 'cdm_dataportal', 'theme/cdm_dataportal.taxon');
  module_load_include('theme', 'cdm_dataportal', 'theme/cdm_dataportal.name');
  module_load_include('theme', 'cdm_dataportal', 'theme/cdm_dataportal.references');

  module_load_include('php', 'cdm_dataportal', 'classes/footnotemanager');
  module_load_include('php', 'cdm_dataportal', 'classes/footnote');
  module_load_include('php', 'cdm_dataportal', 'classes/footnotekey');
  module_load_include('php', 'cdm_dataportal', 'classes/renderhints');


  /* ============================ java script functions ============================= */


  /**
  * loads external java script files asynchronously.
  *
  * @param unknown_type $script_url
  */
  function drupal_add_js_async($script_url, $callback){

    drupal_add_js("
          jQuery(document).ready(function() {
            jQuery.ajax({
              url: '" . $script_url . "',
              dataType: 'script',
              cache: true, // otherwise will get fresh copy every page load
              success: function() {
                    " . $callback . "
              }
            });
          });"
    , 'inline');
  }

  /**
   */
  function drupal_add_js_rowToggle($tableId){

      drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/table_modification.js');
      drupal_add_js('jQuery(document).ready(function(){
          addRowToggle("' . $tableId . '");
      });
      ', array('type' => 'inline'));
  }

  /**
   * @param unknown_type $link_element_selector
   * @param unknown_type $progress_element_selector
   */
  function _add_js_cdm_ws_progressbar($link_element_selector, $progress_element_selector){

    $callback = "jQuery('" . $link_element_selector . "').cdm_ws_progress('" . $progress_element_selector . "');";

    drupal_add_js_async(variable_get('cdm_webservice_url', '').'js/cdm_ws_progress.js', $callback);

    //   drupal_add_js("
    //   	  if (Drupal.jsEnabled) {
    //         $(document).ready(function() {
    //       		$('" . $link_element_selector . "').cdm_ws_progress('" . $progress_element_selector . "');
    //         });
    //       }", 'inline');
    }

  /**
   * @todo Please document this function.
   * @see http://drupal.org/node/1354
   */
  function _add_js_treeselector() {
    // drupal_add_js(drupal_get_path('module', 'cdm_dataportal').'/js/treeselector.js');
    drupal_add_js("
        jQuery(document).ready(function() {
           jQuery('#cdm-taxonomictree-selector-form #edit-val').change(function () {
                jQuery('#cdm-taxonomictree-selector-form').submit();
            });

        });
      ",
      array(
        'type' => 'inline',
        'scope' => 'footer'
      )
    );
  }

  function _add_js_resizable_element($selector, $y_axis_only) {

    _add_jquery_ui();
    $options = "";
    if($y_axis_only) {
      $options = "resize: function(event, ui) {
        ui.size.width = ui.originalSize.width;
        },
        handles: \"s\"";

    }
    drupal_add_js("
          jQuery(document).ready(function() {
             jQuery('" . $selector . "').resizable({". $options ."});
          });
        ",
      array(
        'type' => 'inline',
        'scope' => 'footer'
      )
    );
  }

  function _add_js_openlayers() {

    $openlayers = '/js/map/OpenLayers-2.13.1/OpenLayers.js';
    $proj4js = '/js/map/proj4js-1.1.0/proj4js-compressed.js';

    if(variable_get('cdm_js_devel_mode', FALSE)){
      // develooper mode libs
  //     $openlayers = '/js/map/OpenLayers-2.13.1/lib/OpenLayers.js';
      $openlayers = '/js/map/OpenLayers-2.13.1/OpenLayers.debug.js';
      $proj4js = '/js/map/proj4js-1.1.0/proj4js-combined.js';
    }

    drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . $openlayers,
      array(
        'type' => 'file',
        'group' => JS_LIBRARY,
        'weight' => 0,
        'cache' => TRUE,
        'preprocess' => FALSE
      )
    );

    // see https://github.com/proj4js/proj4js
    // http://openlayers.org/dev/examples/using-proj4js.html
    drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . $proj4js,
      array(
        'type' => 'file',
        'group' => JS_LIBRARY,
        'weight' => -1, // before open layers
        'cache' => TRUE,
      )
    );

    // configure the theme
    $openlayers_theme_path = drupal_get_path('module', 'cdm_dataportal') . '/js/map/OpenLayers-2.13.1/theme/default/';
    $openlayers_imp_path = drupal_get_path('module', 'cdm_dataportal') . '/js/map/img/dark/';
    drupal_add_js('OpenLayers.ImgPath="' . base_path() . $openlayers_imp_path . '";', array(
        'type' => 'inline',
        'group' => JS_LIBRARY,
        'weight' => 1, // after openlayers
        'cache' => TRUE,
        'preprocess' => FALSE
      ));

    drupal_add_css($openlayers_theme_path . 'style.tidy.css',
      array(
        'type' => 'file',
        'cache' => TRUE,
        'preprocess' => FALSE
      )
    );

  }

  /**
   * @todo Please document this function.
   * @see http://drupal.org/node/1354
   */
  function _add_js_thickbox() {
    // ---- jQuery thickbox:
    /*
    * bug: compat-1.0.js && thickbox.js line 237 .trigger("unload") -> event is
    * not triggered because of problems with compat-1.0.js' see INSTALL.txt
    */
    // drupal_add_js(drupal_get_path('module',
    // 'cdm_dataportal').'/js/jquery.imagetool.min.js');
    //
    // Add a setting for the path to cdm_dataportal module, used to find the path
    // for the loading animation image in thickbox.
    drupal_add_js(array(
    'cdm_dataportal' => array(
    'cdm_dataportal_path' => base_path() . drupal_get_path('module', 'cdm_dataportal'),
    )
    ),
    'setting'
        );
        drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/thickbox/thickbox.js');
        drupal_add_css(drupal_get_path('module', 'cdm_dataportal') . '/js/thickbox/cdm_thickbox.css');
  }

  /**
   * @todo Please document this function.
   * @see http://drupal.org/node/1354
   */
  function _add_js_lightbox($galleryID) {
    /*
     * Important Notice: The jquery.lightbox-0.5.js has been modified in order to
    * allow using the "alt" attribute for captions instead of the "title"
    * attribute
    */
    $lightbox_base_path =  drupal_get_path('module', 'cdm_dataportal') . '/js/jquery-lightbox-0.5';
    $lightbox_image_path = base_path() . $lightbox_base_path . '/images/';
    drupal_add_js($lightbox_base_path . '/js/jquery.lightbox-0.5.js');
    drupal_add_css($lightbox_base_path . '/css/jquery.lightbox-0.5.css');
    drupal_add_js('jQuery(document).ready(function() {
        jQuery(\'#' . $galleryID . ' a.lightbox\').lightBox({
          fixedNavigation:  true,
          imageLoading:     \'' . $lightbox_image_path . 'lightbox-ico-loading.gif\',
          imageBtnPrev:     \'' . $lightbox_image_path . 'lightbox-btn-prev.gif\',
          imageBtnNext:     \'' . $lightbox_image_path . 'lightbox-btn-next.gif\',
          imageBtnClose:    \'' . $lightbox_image_path . 'lightbox-btn-close.gif\',
          imageBlank:       \'' . $lightbox_image_path . 'lightbox-blank.gif\',
          adjustToWindow: true
        });
      });
      ', array('type' => 'inline'));
  }

  /**
   * @todo Please document this function.
   * @see http://drupal.org/node/1354
   */
  function _add_js_footnotes() {
    _add_js_domEvent();
    drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/footnotes.js');
  }

  /**
   * @todo Please document this function.
   * @see http://drupal.org/node/1354
   */
  function _add_js_ahah() {

    _add_js_domEvent(); // requires domEvent.js
    drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/ahah-content.js');
  }

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function _add_js_taxonomic_children($jquery_selector) {

  global $base_url;


  drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/jquery.cdm.taxonomic_children.js');
  
  drupal_add_js('jQuery(document).ready(function() {
        jQuery(\'' . $jquery_selector . '\').taxonomic_children({
          // hoverClass: "fa-rotate-90",
          // activeClass: "fa-rotate-90",
          classificationUuid: "' . get_current_classification_uuid() . '",
          taxonUuid: "' . get_current_taxon_uuid() . '",
          cdmWebappBaseUri: "' . variable_get('cdm_webservice_url', '') . '",
          proxyBaseUri: "' . $base_url . '",
          
        });
      });
      ', array('type' => 'inline'));
}

  /**
   * Adds the external javascript file for domEvent.js.
   *
   * @see drupal_add_js()
   */
  function _add_js_domEvent() {
    drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/domEvent.js');
  }

  function _add_jquery_ui()
  {
    drupal_add_css(drupal_get_path('module',
        'cdm_dataportal') . '/js/jquery-ui-1.8.24/themes/base/jquery.ui.all.css');
    drupal_add_js(drupal_get_path('module',
        'cdm_dataportal') . '/js/jquery-ui-1.8.24/ui/jquery-ui.js',
      array(
        'type' => 'file',
        'weight' => JS_LIBRARY,
        'cache' => TRUE,
        'preprocess' => FALSE
      )
    );
  }

  /**
   * Provides the markup for an font awesome icon.
   *
   * The icons is created in default size without any extra features.
   *
   * The available icons are listed here http://fontawesome.io/cheatsheet/
   * fontawesome icons have much more features than implemented here in this function,
   * for spinning icons, fixed width icons, rotation, etc please checkout the
   * examples at http://fontawesome.io/examples/
   *
   * @parameter $icon_name
   *  The name of the icon which starts with 'fa-'
   *
   * @return String
   *    the markup for the icon in an <i> tag
   *
   */
  function font_awesome_icon_markup($icon_name = NULL, $attributes = array()){


    //<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">

    $font_awesome_css_uri = base_path() . drupal_get_path('module', 'cdm_dataportal').'/fonts/font-awesome-4.6.3/css/font-awesome.min.css';
    //$font_awesome_css_uri="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css";

    drupal_add_html_head_link(
      array(
        'href' => $font_awesome_css_uri,
        'rel' => 'stylesheet'
      )
    );

    if($icon_name){
      if(!isset($attributes['class'])){
        $attributes['class'] = array();
      }
      $attributes['class'][] = 'fa';
      $attributes['class'][] = $icon_name;

      return '<i ' . drupal_attributes($attributes) . '></i>';
    }

    return '';
  }


  /* ====================== hook implementations ====================== */
  /**
   * Implements hook_permission().
   *
   * Valid permissions for this module.
   *
   * @return array
   *   An array of valid permissions for the cdm_dataportal module.
   */
  function cdm_dataportal_permission() {
    return array(
      'administer cdm_dataportal' => array(
        'title' => t('Administer CDM DataPortal settings'),
        'description' => t("Access the settings pages specific for the cdm_dataportal module"),
      ),
      'access cdm content' => array(
        'title' => t('Access CDM content'),
        'description' => t("Access content (taxa, names, specimens, etc.) served by the CDM web service."),
      ),
    );
  }

/**
 * Implements hook_menu().
 */
function cdm_dataportal_menu() {
  $items = array();

  // @see settings.php.
  cdm_dataportal_menu_admin($items);
  cdm_dataportal_menu_help($items);

  $items['cdm_dataportal/names'] = array(
    'page callback' => 'cdm_dataportal_view_names',
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
  );

  // Optional callback arguments: page.
  $items['cdm_dataportal/taxon'] = array(
    'page callback' => 'cdm_dataportal_taxon_page_view',
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
    // Expected callback arguments: uuid.
  );

  $items['cdm_dataportal/specimen'] = array(
      'page callback' => 'cdm_dataportal_specimen_page_view',
      'access arguments' => array('access cdm content'),
      'type' => MENU_CALLBACK,
      // Expected callback arguments: uuid.
  );

  $items['cdm_dataportal/named_area'] = array(
    'page callback' => 'cdm_dataportal_named_area_page_view',
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
    // Expected callback arguments: uuid.
  );

  $items['cdm_dataportal/name'] = array(
    'page callback' => 'cdm_dataportal_name_page_view',
      /*
    'page arguments' => array(
       'taxon_name_uuid',
       'taxon_to_hide_uuid',
       'synonym_uuid' => NULL
      ),
      */
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
    // Expected callback arguments: uuid.
  );

  $items['cdm_dataportal/reference'] = array(
    'page callback' => 'cdm_dataportal_view_reference',
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
    // Expected callback arguments: uuid.
  );

  $items['cdm_dataportal/reference/list'] = array(
    'page callback' => 'cdm_dataportal_view_reference_list',
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
    // Expected callback arguments: uuid.
  );

  $items['cdm_dataportal/media'] = array(
    'page callback' => 'cdm_dataportal_view_media',
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
    // Expected callback arguments:
    // uuid, mediarepresentation_uuid, part_uuid or part#.
  );

  $items['cdm_dataportal/polytomousKey'] = array(
    'page callback' => 'cdm_dataportal_view_polytomousKey',
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
    // Expected callback arguments: polytomousKey->uuid.
  );

  $items['cdm_dataportal/search'] = array(
    'page callback' => 'cdm_dataportal_view_search_advanced',
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
  );

  $items['cdm_dataportal/search/advanced'] = array(
    'title' => 'Advanced', // will be passed through t()
    'page callback' => 'cdm_dataportal_view_search_advanced',
    'access arguments' => array('access cdm content'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['cdm_dataportal/search/taxon_by_description'] = array(
    'title' => 'By content category', // will be passed through t()
    'page callback' => 'cdm_dataportal_view_search_taxon_by_description',
    'access arguments' => array('access cdm content'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['cdm_dataportal/search/results/taxon'] = array(
    'page callback' => 'cdm_dataportal_view_search_results_taxon',
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
  );
  /*
   $items['cdm/xml2json'] = array(
   'page callback' => 'cdm_view_xml2json',
   'access arguments' => array('access cdm content'),
   'type' => MENU_CALLBACK,
   );
   */

  // if (arg(0)=='user' && ($uid=arg(1)) && is_numeric($uid)) {
  // User configuration of cdm_dataportal.
  $items['user/%/cdm_dataportal'] = array(
    'title' => 'cdm_dataportal',
    'access arguments' => array('access cdm content'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cdm_dataportal_user_form'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );
  // }

  // 'May not cache' in D5.
  $items['cdm_dataportal/name/%'] = array(
    // 'page callback' => 'cdm_dataportal_view_name',
    'page callback' => 'cdm_dataportal_name_page_view',
    'page arguments' => array(2, 3, 4),
    'access arguments' => array('access cdm content'),
    'type' => MENU_CALLBACK,
  );

  // --- Local tasks for Taxon.
  // --- tabbed taxon page
  if (variable_get('cdm_dataportal_taxonpage_tabs', 1)) {
    $items['cdm_dataportal/taxon/%'] = array(
      'title' => '@tabname',
      'title arguments' => array('@tabname' => theme('cdm_taxonpage_tab', array('tabname' => 'General'))),
      'page callback' => 'cdm_dataportal_taxon_page_view',
      'access arguments' => array('access cdm content'),
      'type' => MENU_CALLBACK,
      'weight' => 1,
      'page arguments' => array(2, "description")
      , // Expected callback arguments: taxon_uuid.
    );

    $items['cdm_dataportal/taxon/%/all'] = array(
      'title' => '@tabname',
      'title arguments' => array('@tabname' => theme('cdm_taxonpage_tab', array('tabname' => 'General'))),
      'page callback' => 'cdm_dataportal_taxon_page_view',
      'access arguments' => array('access cdm content'),
      'type' => MENU_CALLBACK,
      'weight' => 2,
      'page arguments' => array(2, "all")
      , // Expected callback arguments: taxon_uuid.
    );

    $items['cdm_dataportal/taxon/%/description'] = array(
      'title' => '@tabname',
      'title arguments' => array('@tabname' => theme('cdm_taxonpage_tab', array('tabname' => 'General'))),
      'page callback' => 'cdm_dataportal_taxon_page_view',
      'access arguments' => array('access cdm content'),
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => 2,
      'page arguments' => array(2, "description")
      , // Expected callback arguments: taxon_uuid.
    );

    $items['cdm_dataportal/taxon/%/synonymy'] = array(
      'title' => '@tabname',
      'title arguments' => array('@tabname' => theme('cdm_taxonpage_tab', array('tabname' => 'Synonymy'))),
      'page callback' => 'cdm_dataportal_taxon_page_view',
      'access arguments' => array('access cdm content'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 4,
      'page arguments' => array(2, "synonymy", 4)
      , // Expected callback arguments: taxon_uuid and ...
    );
    $items['cdm_dataportal/taxon/%/images'] = array( // Images
      'title' => '@tabname',
      'title arguments' => array('@tabname' => theme('cdm_taxonpage_tab', array('tabname' => 'Images'))),
      'page callback' => 'cdm_dataportal_taxon_page_view',
      'access arguments' => array('access cdm content'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 5,
      'page arguments' => array(2, "images")
      , // Expected callback arguments: taxon_uuid.
    );

    $items['cdm_dataportal/taxon/%/specimens'] = array( // Specimens
      'title' => '@tabname',
      'title arguments' => array('@tabname' => theme('cdm_taxonpage_tab', array('tabname' => 'Specimens'))),
      'page callback' => 'cdm_dataportal_taxon_page_view',
      'access arguments' => array('access cdm content'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 6,
      'page arguments' => array(2, "specimens")
      , // Expected callback arguments: taxon_uuid.
    );

    $items['cdm_dataportal/taxon/%/keys'] = array( // Keys
      'title' => '@tabname',
      'title arguments' => array('@tabname' => theme('cdm_taxonpage_tab', array('tabname' => 'Keys'))),
      'page callback' => 'cdm_dataportal_taxon_page_view',
      'access arguments' => array('access cdm content'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 6,
      'page arguments' => array(2, "keys")
      , // Expected callback arguments: taxon_uuid.
    );

    $items['cdm_dataportal/taxon/%/experts'] = array( // Experts
      'title' => '@tabname',
      'title arguments' => array('@tabname' => theme('cdm_taxonpage_tab', array('tabname' => 'Experts'))),
        'page callback' => 'cdm_dataportal_taxon_page_view',
        'access arguments' => array('access cdm content'),
        'type' => MENU_LOCAL_TASK,
        'weight' => 6,
        'page arguments' => array(2, "experts")
    , // Expected callback arguments: taxon_uuid.
    );

    $items['cdm_dataportal/taxon/autosuggest/%/%/%/'] = array(
        'page callback' => 'cdm_dataportal_taxon_autosuggest',
        'access arguments' => array('access cdm content'),
        'page arguments' => array(3,4,5),
        'type' => MENU_CALLBACK
    );
  }

  // --- refresh link for all cdmnode types
  foreach (cdm_get_nodetypes() as $type=>$name) {
    $items['cdm_dataportal/' . $name . '/%/refresh'] = array(
        'title' => 'Refresh',
        'page callback' => 'cdm_dataportal_refresh_node',
        'access arguments' => array('administer cdm_dataportal'),
        'type' => MENU_LOCAL_TASK,
        'weight' => 100,
        'page arguments' => array($name, 2)
    );
  }

  return $items;
}

/**
 * Implements hook_init().
 *
 */
function cdm_dataportal_init() {
  //FIXME To add CSS or JS that should be present on all pages, modules
  //      should not implement this hook, but declare these files in their .info file.
  drupal_add_css(drupal_get_path('module', 'cdm_dataportal') . '/cdm_dataportal.css');
  // drupal_add_css(drupal_get_path('module', 'cdm_dataportal').'/cdm_dataportal_print.css', 'print');
  drupal_add_css(drupal_get_path('module', 'cdm_dataportal') . '/cdm_dataportal_screen.css', array('type' => 'screen'));

  if(variable_get('cdm_debug_mode', FALSE)){
    $file = 'temporary://drupal_debug.txt';
    file_put_contents($file, 'CDM DEBUG LOG for ' . $_GET['q']. "\n"); // will overwrite the file
  }

  $bibliography_settings = get_bibliography_settings();
  $enclosing_tag = $bibliography_settings['enabled'] == 1 ? 'div' : 'span';
  FootnoteManager::registerFootnoteSet('BIBLIOGRAPHY', $enclosing_tag, $bibliography_settings['key_format']);
}

function cdm_dataportal_refresh_node($cdm_node_name, $uuid, $parameters = array()){

  $base_path = 'cdm_dataportal/' . $cdm_node_name . '/' . $uuid;

  if($cdm_node_name == 'taxon' && variable_get('cdm_dataportal_taxonpage_tabs', 1)){
    // force reloading of all and notify user about this special loading
    drupal_set_message(t('The level 2 cache has been cleared for all tabs of this taxon page at once, please click here to return to the tabbed page: ')
        . l('Back to tabbed taxon page', $base_path));
    $base_path .= '/all';
  } else {
    drupal_set_message(t('The level 2 cache has been cleared for this page'));
  }

  $parameters['cacheL2_refresh'] ='1';


  drupal_goto($base_path, array('query' => $parameters));
}

/**
 * The function generate form for own user cdm dataportal configurations.
 */
function cdm_dataportal_user_form($form, &$form_state) {

  global $user;
  $checkbox_value = 'cdm_dataportal_' . $user->uid . '_default_tab_active';

  $form['taxon_page_tabs'] = array(
      '#type' => 'fieldset',
      '#tree' => true,
      '#title' => t('Taxon page tabs'),
  );

  $form['taxon_page_tabs']['user_defined'] = array(
    '#type' => 'checkbox',
    '#title' => t('Activate user default configuration'),
    '#default_value' => variable_get($checkbox_value, 0),
    '#description' => t('Check this if you want configure your own default tab from the below menu.'),
  );

  $form['taxon_page_tabs']['default_tab'] = array(
    '#type' => 'select',
    '#title' => t('Default tab to display'),
    '#default_value' => get_default_taxon_tab(TRUE),
    '#options' => unserialize(CDM_DATAPORTAL_DEFAULT_TAXON_TAB),
    '#description' => t('<p>Select the default tab to display when visiting a taxon page. Only available if Tabbed Taxon Page is enable.</p>
              <strong>Note:</strong> After performing a search and clicking in any synonym, the taxon tab
              to be rendered will be the synonymy of the accepted taxon and not the above selected tab.'),
  );


  if(false){
    $form['developer_options'] = array(
        '#type' => 'fieldset',
        '#tree' => true,
        '#title' => t('Developer options'),
    );

    $form['developer_options']['show_render_path'] = array(
      '#type' => 'checkbox',
      '#title' => t('Display the render path for each taxon name.'),
      '#default_value' => variable_get($checkbox_value, 0),
      '#description' => t('This option is very helpful if you are editing the !link for taxon names.',
        array(
            '!link' => l(
              'render template', 'admin/config/cdm_dataportal/settings/layout', array('fragment' => 'edit-cdm-name-render-templates'))
            )
        ),
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  return $form;
}

/**
 * Form submission handler for user_form().
 *
 * Submits the user cdm dataportal configurations.
 */
function cdm_dataportal_user_form_submit($form, &$form_state) {
  global $user;
  $msg_type = 'status';
  $username = $user->name;
  $variable_to_use = 'cdm_dataportal_' . $user->uid . '_default_tab';

  // FIXME: this is completely wrong, see user_profile_form_submit()

  // it is only possible to change own user settings
  if (arg(0) == 'user' && is_numeric(arg(1)) && $user->uid == arg(1)) {

    // DEFAULT_TAXON_TAB
    $variable = unserialize(CDM_DATAPORTAL_DEFAULT_TAXON_TAB);
    variable_set($variable_to_use . '_active', $form_state['values']['taxon_page_tabs']['user_defined']);
    variable_set($variable_to_use, $form_state['values']['taxon_page_tabs']['default_tab']);
    if ($form_state['values']['taxon_page_tabs']['user_defined']) {
      drupal_set_message(check_plain(t('The user default tab will be used for the next taxon site visit.')));
      drupal_set_message(check_plain(t('The user default tab has been changed to: !tab for the user !user', array(
        '!tab' => $variable[variable_get($variable_to_use, 0)],
        '!user' => $username,
      ))), $msg_type);
    }
    else {
      drupal_set_message(check_plain(t('The user default tab wont be used for
        the next taxon site, check the box if you want to use the user default configuration.')));
    }

  }
  else {
    // Problem with the user id => variables wont be saved.
    $msg_type = 'warning';
    drupal_set_message(check_plain(t('Default tab has not been saved due to user id problems')), $msg_type);
  }
}

/**
 * Implements hook_block_info().
 */
function cdm_dataportal_block_info() {

    // $block[0]["info"] = t("CDM DataPortal DevLinks");
    // $block[1]["info"] = t("CDM DataPortal Credits");
    $block["2"] = array(
        "info" => t("CDM - Search Taxa"),
        "cache" => DRUPAL_NO_CACHE
      );
    // $block[3]["info"] = t("CDM Filters");
    $block["4"]["info"] = t("CDM  - Dataportal Print");
    $block["keys"]["info"] = t("CDM - Identification keys");
    $block["fundedByEDIT"]["info"] = t('Funded by EDIT');
    $block["classification_breadcrumbs"] =  array(
        'info' => t('CDM - Classification breadcrumbs'),
        'cache' => DRUPAL_CACHE_PER_PAGE
      );
    $block["taxonomic_children"] =  array(
      'info' => t('CDM - Taxonomic children'),
      'cache' => DRUPAL_CACHE_PER_PAGE
    );
    $block["back_to_search_results"] =  array(
      'title' => '<none>',
      'info' => t('CDM - Back to search Results'),
      'cache' => DRUPAL_CACHE_PER_PAGE,
      'visibility' => BLOCK_VISIBILITY_LISTED,
      'pages' => "cdm_dataportal/taxon/*", // multiple page paths separated by "\n"!!!
    );

    return $block;
}

/**
 * Implements hook_block_view().
 */
function cdm_dataportal_block_view($delta) {
  // TODO Rename block deltas (e.g. '2') to readable strings.
  switch ($delta) {
    // case 'delta-1':
    // $block['subject'] = t('Credits');
    // $block['content'] = theme('cdm_credits');
    // return $block;
    case '2':
      $block['subject'] = t('Search taxa');
      $form = drupal_get_form('cdm_dataportal_search_taxon_form');
      $block['content'] = drupal_render($form);

      if (variable_get('cdm_dataportal_show_advanced_search', 1)) {
        $block['content'] .= '<div>' . l(t('Advanced Search'), 'cdm_dataportal/search') . '</div>';
      }
      return $block;
    case '4':
      $block['subject'] = '';
      $block['content'] = theme('cdm_print_button');
      return $block;
    case "keys":
      $block['subject'] = t('Identification Keys');
      $block['content'] = theme('cdm_block_IdentificationKeys', array('taxonUuid' => NULL));
      return $block;
    case "fundedByEDIT":
      // t('Funded by EDIT');
      $text = '<none>';
      $block['subject'] = $text;
      $img_tag = '<img src="' . base_path() . drupal_get_path('module', 'cdm_dataportal') . '/images/powered_by_edit.png' . '" alt="' . $text . '"/>';
      $block['content'] = l($img_tag, "http://cybertaxonomy.org/", array(
        'attributes' => array("target" => "EDIT"),
        'absolute' => TRUE,
        'html' => TRUE,
      ));
      return $block;
    case 'classification_breadcrumbs':
      $taxon_uuid = get_current_taxon_uuid();
      $block['subject'] = '<none>';
      $block['content'] = compose_classification_breadcrumbs($taxon_uuid);
      return $block;
    case 'taxonomic_children':
      $taxon_uuid = get_current_taxon_uuid();
      $block['subject'] = '<none>';
      $block['content'] = compose_taxonomic_children($taxon_uuid);
      return $block;
    case 'back_to_search_results':
      $block['subject'] = '<none>';
      if (isset($_SESSION['cdm']['search'])) {
        $block['content'] = l(t('Back to search result'), "http://" . $_SERVER['SERVER_NAME'] . $_SESSION['cdm']['last_search']);
      }
      return $block;
    default:
      return null;
  }
}

/**
 * Provides the uuid of the taxon for pages with the path ./taxon/{taxon_uuid}
 *
 * @return string
 *   the taxon uuid or NULL
 */
function get_current_taxon_uuid()
{
  static $taxon_uuid;

  if(!isset($taxon_uuid)){
    if(isset($_REQUEST['currentTaxon']) && is_uuid($_REQUEST['currentTaxon'])) {
      $taxon_uuid = $_REQUEST['currentTaxon'];
    } else if (arg(1) == 'taxon' && is_uuid(arg(2))) {
      $taxon_uuid = arg(2);
    } else {
      $taxon_uuid = null;
    }
  }

  return $taxon_uuid;
}

/**
 * Returns the currently classification tree in use.
 *
 * @return string
 *   The uuid of the currently focused classification
 */
function get_current_classification_uuid() {
  if (isset($_SESSION['cdm']['taxonomictree_uuid']) && is_uuid($_SESSION['cdm']['taxonomictree_uuid'])) {
    return $_SESSION['cdm']['taxonomictree_uuid'];
  }
  else {
    return variable_get(CDM_TAXONOMICTREE_UUID, FALSE);
  }
}

/*
 function cdm_dataportal_session_clear($cdm_ws_uri_update = FALSE){
 $_SESSION['cdm'] = NULL;
 if(is_string($cdm_ws_uri_update)){
 $_SESSION['cdm'] = array('ws_uri'=>$cdm_ws_uri_update);
 }
 }

 function cdm_dataportal_session_validate(){
 if(!isset($_SESSION['cdm']['ws_uri'])){
 $_SESSION['cdm'] = array('ws_uri'=>variable_get('cdm_webservice_url', FALSE));
 } else if($_SESSION['cdm']['ws_uri'] != variable_get('cdm_webservice_url', FALSE)){
 cdm_dataportal_session_clear(variable_get('cdm_webservice_url', FALSE));
 }
 }
 */

/**
 * creates a  selector form for taxonomic trees.
 *
 * @return array
 *  a drupal form array
 */
function cdm_taxonomictree_selector() {
  _add_js_treeselector();

  $form = drupal_get_form('cdm_taxonomictree_selector_form');
  return $form;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 *
 * @deprecated use compose_classification_selector instead
 */
function cdm_taxonomictree_selector_form($form, &$form_state) {

  $url = url('cdm_api/setvalue/session', array('query' => NULL));
  $form['#action'] = $url;

  $form['var'] = array(
    '#weight' => -3,
    '#type' => 'hidden',
    '#value' => '[cdm][taxonomictree_uuid]',
  );

  $destination_array = drupal_get_destination();
  $destination = $destination_array['destination'];

  $form['destination'] = array(
    '#weight' => -3,
    '#type' => 'hidden',
    '#value' =>  $destination,
  );

  $options = cdm_get_taxontrees_as_options();
  $taxontree_includes = variable_get(CDM_TAXONTREE_INCLUDES, null);
  if($taxontree_includes){
    $filtered_options = array();
    foreach($options as $uuid=>$label){
      if(!empty($taxontree_includes[$uuid])){
        $filtered_options[$uuid] = $label;
      }
    }
    $options = $filtered_options;
  }

  $form['val'] = array(
    '#type' => 'select',
    '#title' => t('Available classifications'),
    '#default_value' => get_current_classification_uuid(),
    '#options' => $options,
    '#attributes' => array('class' => array('highlite-first-child')),
  );

  return $form;

}

/**
 *
 * @ingroup compose
 */
function compose_classification_selector() {

  $destination_array = drupal_get_destination();
  $destination = $destination_array['destination'];

  $options = cdm_get_taxontrees_as_options();
  $items = array();
  $taxontree_includes = variable_get(CDM_TAXONTREE_INCLUDES, null);

  $current_classification_uuid = get_current_classification_uuid();


  foreach($options as $uuid=>$label){
    if(!$taxontree_includes || !empty($taxontree_includes[$uuid])){

      $class_attributes = '';
      if($current_classification_uuid == $uuid){
        $class_attributes  = array('focused');
      }
      $items[] = array(
        'data' => l($label,
          'cdm_api/setvalue/session',
          array(
            'query' => array(
              'destination' => $destination,
              'val' => $uuid,
              'var' => '[cdm][taxonomictree_uuid]'
            ),
          )
        ),
        'class' => $class_attributes
      );
    }
  }

  $render_array = array(
    '#theme' => 'item_list',
    '#type' => 'ul',
    '#items' => $items
  );

  return $render_array;
}


/* UNREACHABLE since action of form directly links to view.
 function cdm_dataportal_search_taxon_form_submit($form_id, $form_values) {

 $_SESSION['cdm']['search'] = $form_values;
 //return '/cdm_dataportal/search/taxon/'.$form_values['queryString'].'/'.($form_values['vernacular']?'1':'0').'/'.$form_values['language'];
 return '/cdm_dataportal/search/taxon/'.$form_values['queryString'].'/'.($form_values['onlyAccepted']?'1':'0');
 //$paramstr = compose_url_prameterstr($form_values);
 //return url('/cdm_dataportal/search/taxon/', array('query' => $paramstr));
 }
 */
/* ====================== menu callback functions ====================== */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
/*
function cdm_dataportal_form_alter(&$form, &$form_state, $form_id) {
  static $comment_node_disabled =  0;
  static $comment_node_read_only =  1;
  static $comment_node_read_write =  2;

  if ($form_id == 'node_type_form'
   && isset($form['identity']['type'])
   && array_key_exists($form['#node_type']->type, cdm_get_nodetypes())
  ) {
    $form['workflow']['comment'] = array(
      '#type' => 'radios',
      '#title' => t('Default comment setting'),
      '#default_value' => variable_get('comment__' . $node->type . $form['#node_type']->type, $comment_node_disabled),
      '#options' => array(t('Disabled'), t('Read only'), t('Read/Write')),
      '#description' => t('Users with the <em>administer comments</em> permission will be able to override this setting.'),
    );
  }
}
*/

/**
 * Displays a list of the known taxonomic names.
 *
 * When the list of taxonomic names is displayed, long lists are split up into
 * multiple pages.
 *
 * TODO: Parameters are still preliminary.
 *
 * @param string $beginsWith
 * @param string $page
 *   Page number to diplay defaults to page 1.
 * @param bool $onlyAccepted
 */
function cdm_dataportal_view_names($beginsWith = 'A', $page = 1, $onlyAccepted = FALSE) {

  $out = t('<h3>Sorry, the name list feature is not yet available in this version of the DataPortal software<h3>');

  /*
  // FIXME the filter for accepted names will be a form element, thus this
  // widget should be generated via form api preferably as block.
  $out  = theme('cdm_dataportal_widget_filter_accepted', $onlyAccepted);
  $out .= theme('cdm_dataportal_widget_names_list', $names, $page);
  $out .= theme('cdm_listof_taxa', $taxonPager);
  return $out;
  */
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_dataportal_view_reference($uuid, $arg2 = NULL) {

  cdm_check_valid_portal_page();

  $reference = cdm_ws_get(CDM_WS_REFERENCE, $uuid);
  return theme('cdm_reference_page', array('reference' => $reference));
}

/**
 * Creates a view on a all references contained in the portal.
 *
 * This function is used at the path cdm_dataportal/reference/list
 */
function cdm_dataportal_view_reference_list($pageNumber) {
  $referencePager = cdm_ws_page(CDM_WS_REFERENCE, variable_get('cdm_dataportal_search_items_on_page', CDM_DATAPORTAL_SEARCH_ITEMS_ON_PAGE), $pageNumber);
  cdm_reference_pager($referencePager, 'cdm_dataportal/reference/list/');
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_dataportal_view_media($mediaUuid, $mediarepresentation_uuid = FALSE, $part = 0) {

  cdm_check_valid_portal_page();

  $media = cdm_ws_get(CDM_WS_PORTAL_MEDIA, $mediaUuid);
  return theme('cdm_media_page', array(
    'media' => $media,
    'mediarepresentation_uuid' => $mediarepresentation_uuid,
    'partId' => $part,
    ));
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function _load_taxonBase(&$taxonBase) {
  if (isset($taxonBase->uuid)) {
    $taxonBase->name = cdm_ws_get(CDM_WS_TAXON, array($taxonBase->uuid, "name"));
    $taxonBase->name->taggedName = cdm_ws_get(CDM_WS_NAME, array($taxonBase->name->uuid, "taggedName"));
    $taxonBase->name->nomenclaturalReference = cdm_ws_get(CDM_WS_NAME, array($taxonBase->name->uuid, "nomenclaturalReference"));
  }
}

/**
 * Loads the media associated to the given taxon from the cdm server.
 * The aggregation settings regarding taxon relathionships and
 * taxonnomic childen are taken into account.
 *
 * The media lists are cached in a static variable.
 *
 * @param Taxon $taxon
 *   A CDM Taxon entitiy
 *
 * @return array
 *   An array of CDM Media entities
 *
 */
function _load_media_for_taxon($taxon) {

  static $media = NULL;

  if(!isset($media)) {
    $media = array();
  }
  if (!isset($media[$taxon->uuid])) {

    // --- GET Images --- //
    $mediaQueryParameters = array(
        "type" => "ImageFile",
    );

    $relationship_choice = variable_get(CDM_AGGREGATE_BY_TAXON_RELATIONSHIPS, unserialize(CDM_AGGREGATE_BY_TAXON_RELATIONSHIPS_DEFAULT));
    $mediaQueryParameters['relationships'] = implode(',', get_selection($relationship_choice['direct']));
    $mediaQueryParameters['relationshipsInvers'] = implode(',', get_selection($relationship_choice['invers']));

    $taxon_media_filter_choice = variable_get(CDM_TAXON_MEDIA_FILTER, unserialize(CDM_TAXON_MEDIA_FILTER_DEFAULT));
    $mediaQueryParameters['includeTaxonDescriptions'] = (boolean) $taxon_media_filter_choice['includeTaxonDescriptions'] != 0;
    $mediaQueryParameters['includeOccurrences'] = (boolean) $taxon_media_filter_choice['includeOccurrences'] != 0;
    $mediaQueryParameters['includeTaxonNameDescriptions'] = (boolean) $taxon_media_filter_choice['includeTaxonNameDescriptions'] != 0;

    $ws_endpoint = NULL;
    if ( variable_get('cdm_images_include_children', 0) == 0) {
      $ws_endpoint = CDM_WS_PORTAL_TAXON_MEDIA;
    } else {
      $ws_endpoint = CDM_WS_PORTAL_TAXON_SUBTREE_MEDIA;
    }

    $media[$taxon->uuid] = cdm_ws_get($ws_endpoint,
        array(
            $taxon->uuid,
        ),
        queryString($mediaQueryParameters)
       );
  }

  return $media[$taxon->uuid];
}

/**
 *
 * @param Taxon $taxon
 *   A CDM Taxon entitiy
 *
 * @return array
 *   An array of CDM SpecimenOrObservation entities
 *
function _load_occurences_for_taxon($taxon){

  static $occurences = NULL;

  if(!isset($occurences)) {
    $occurences = array();
  }

  if (!isset($occurences[$taxon->uuid])){

    $relationship_choice = variable_get(CDM_AGGREGATE_BY_TAXON_RELATIONSHIPS, unserialize(CDM_AGGREGATE_BY_TAXON_RELATIONSHIPS_DEFAULT));
    $relationship_choice['direct'] = get_selection($relationship_choice['direct']);
    $relationship_choice['invers'] = get_selection($relationship_choice['invers']);

    $by_associatedtaxon_query = http_build_query(array(
        'relationshipsInvers' => implode(',', $relationship_choice['invers']),
        'relationships' => implode(',', $relationship_choice['direct']),
        'pageSize' => null // all hits in one page
    )
    );

    $pager = cdm_ws_get(CDM_WS_OCCURRENCE_BY_ASSOCIATEDTAXON,
        null,
        $by_associatedtaxon_query . '&taxonUuid=' . $taxon->uuid
    );


    if(isset($pager->records[0])){
      $occurences[$taxon->uuid] =  $pager->records;
    }
  }
  return $occurences[$taxon->uuid];
}
 */

/**
 * Gets a Drupal variable, string or array and returns it.
 *
 * Similar to the variable_get() function of Drupal, except that this function
 * is able to handle arrays correctly. This function is especially useful
 * when dealing with collections of settings form elements (#tree = TRUE).
 *
 * @param string $variableKey
 *   The Unique key of the Drupal variable in the Drupal variables table.
 * @param string $defaultValueString
 *   A string as for example derived from a CONSTANT.
 *
 * @return mixed
 *   usually an array, depending on the nature of the variable.
 *
 * TODO compare with get_array_variable_merged() duplicate functions?
 * @deprecated rather use get_array_variable_merged() since this function
 * used an array as second parameter
 */
function mixed_variable_get($variableKey, $defaultValueString) {
  $systemDefaults = unserialize($defaultValueString);
  $storedSettings = variable_get($variableKey, array());
  if (is_array($storedSettings)) {
    // TODO better use drupal_array_merge_deep() ?
    $settings = array_merge($systemDefaults, $storedSettings);
  }
  else {
    $settings = $systemDefaults;
  }
  return $settings;
}

/**
 * Recursive function to convert an object into an array.
 * also subordinate objects will be converted.
 *
 * @param object $object
 * @return the array
 */
function convert_to_array($object) {
  if(is_object($object) || is_array($object)) {
    $array = (array)$object;
    foreach ($array as $key=>$value){
      $array[$key] = convert_to_array($value);
    }
    return $array;
  } else {
    return $object;
  }
}

/**
 * Searches the $collection for the cdm entitiy given as $element.
 *
 * The elements are compared by their UUID.
 *
 * @param $element
 *  the CDM entitiy to search for
 * @param $collection
 *  the list of CDM entities to search in
 *
 * @return boolean TRUE if the $collection contains the $element, otheriwse FALSE
 *
 */
function contains_cdm_entitiy($element, $collection) {
  $result = FALSE;
  foreach ($collection as $a) {
    if ($a->uuid == $element->uuid) {
      $result = TRUE;
    }
  }
  return $result;
}

/**
 * Fiters the array $entity_list of CDM entities by the list
 * of $excludes. Any element contained in the $excludes will be removed
 * from included int the retuned list.
 *
 * If the $entity_list is not an array the $excludes will be returned.
 */
function filter_cdm_entity_list($entity_list, $excludes) {
  if (is_array($entity_list)) {
    $result = $entity_list;
    if ($excludes) {
      foreach ($excludes as $exclude) {
        if (!contains_cdm_entitiy($exclude, $entity_list)) {
          $result[] = $exclude;
        }
      }
    }
  }
  else {
    $result = $excludes;
  }
  return $result;
}

/**
 * Wraps the given $html string into a render array suitable for drupal_render()
 *
 * @param $html
 *   the html string, see
 *   http://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7#markup
 * @param $weight
 *   A positive or negative number (integer or decimal).
 *   see http://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7#weightval
 * @param $prefix
 *   Optional markup for the '#prefix' element of the render array
 * @param $suffix
 *   Optional markup for the '#suffix' element of the render array
 *
 * @return array
 *   A render array
 *
 */
function markup_to_render_array($html, $weight = FALSE, $prefix = NULL, $suffix = NULL) {
  $render_array = array(
    '#markup' => $html
      );
  if (is_numeric($weight)) {
    $render_array['#weight'] = $weight;
  }
  if($prefix){
    $render_array['#prefix'] = $prefix;
  }
  if($suffix) {
    $render_array['#suffix'] = $suffix;
  }
  return $render_array;
}

/**
 * Loads the subgraph of a given PolytomousKeyNode.
 *
 * Loads the subgraph of the given PolytomousKeyNode recursively from
 * the CDM REST service.
 *
 * @param mixed $polytomousKeyNode
 *   PolytomousKeyNode passed by reference.
 *
 * @return void
 */
function _load_polytomousKeySubGraph(&$polytomousKeyNode) {

  if (!$polytomousKeyNode) {
    return;
  }
  if ($polytomousKeyNode->class != "PolytomousKeyNode") {
    drupal_set_message('_load_polytomousKeySubGraph(): ' . t('invalid type given.'), 'error');
    return;
  }
  if (!is_uuid($polytomousKeyNode->uuid)) {
    drupal_set_message('_load_polytomousKeySubGraph(): ' . t('invalid type given.'), 'error');
    return;
  }

  $polytomousKeyNode = cdm_ws_get(CDM_WS_POLYTOMOUSKEY_NODE, $polytomousKeyNode->uuid);

  if (!$polytomousKeyNode) {
    // drupal_set_message("_load_polytomousKeyChildNodes() : could not load polytomousKeyNode", "error");
    return;
  }

  // Load children.
  foreach ($polytomousKeyNode->children as &$childNode) {
    _load_polytomousKeySubGraph($childNode);
  }

  // Load subkey.
  $polytomousKeyNode->subkey = cdm_ws_get(CDM_WS_POLYTOMOUSKEY_NODE, array($polytomousKeyNode->uuid, "subkey"));

  // Load taxon.
  $polytomousKeyNode->taxon = cdm_ws_get(CDM_WS_POLYTOMOUSKEY_NODE, array($polytomousKeyNode->uuid, "taxon"));
  _load_taxonBase($polytomousKeyNode->taxon);
  return;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function cdm_dataportal_view_polytomousKey($polytomousKeyUuid) {

  cdm_check_valid_portal_page();

  $polytomousKey = cdm_ws_get(CDM_WS_POLYTOMOUSKEY, $polytomousKeyUuid);

  $sourcePager = cdm_ws_get(CDM_WS_POLYTOMOUSKEY, array($polytomousKeyUuid, 'sources'));
  if (is_array($sourcePager->records)) {
    $polytomousKey->sources = $sourcePager->records;
    // $polytomousKey->sources->citation = cdm_ws_get(CDM_WS_POLYTOMOUSKEY, array($polytomousKeyUuid, 'sources'));
  }

  $annotationPager = cdm_ws_get(CDM_WS_POLYTOMOUSKEY, array($polytomousKeyUuid, 'annotations'));
  if (is_array($annotationPager->records)) {
    $polytomousKey->annotations = $annotationPager->records;
  }

  _load_polytomousKeySubGraph($polytomousKey->root);
  return theme('cdm_polytomousKey_page', array('polytomousKey' => $polytomousKey));
}

/**
 * Creates a taxon page view or a chapter of it.
 *
 * The taxon page gives detailed information on a taxon, it shows:
 *  - Taxon name.
 *  - Full list of synonyms homotypic synonyms on top, followed by the
 *    heterotypic and finally followed by misapplied names.
 *    The list is ordered historically.
 *  - All description associated with the taxon.
 *
 * @param string $uuid
 * @param string $chapter
 *   Name of the part to display, valid values are:
 *   'description', 'images', 'synonymy', 'specimens', 'all'.
 *
 * @return string
 */
function cdm_dataportal_taxon_page_view($uuid, $chapter = 'all') {

  cdm_check_valid_taxon_page($chapter);
  cdm_dd("START OF TAXON PAGE [" . $chapter . "] " . $uuid . ' for ' . $_GET['q']);
  // show a warning in case the javascript development mode is anabled
  if(variable_get('cdm_js_devel_mode', FALSE)) {
    drupal_set_message(t('The !url1 is enabled.
        WARNING: this is a performance penalty and must be turned off on production websites.', array(
          '!url1' => l('java-script development mode', 'admin/config/cdm_dataportal/settings', array('fragment' => 'edit-cdm-js-devel-mode'))
    )),
    'warning'
        );
  }

  // Display the page for the taxon defined by $uuid.
  // set_last_taxon_page_tab(arg(3));
  $taxonpage = cdm_dataportal_taxon_view($uuid, $chapter);
  if (!empty($taxonpage)) {
    cdm_dd("END OF TAXON PAGE [" . $chapter . "] " . $uuid);
    return cdm_node_show(NODETYPE_TAXON, $uuid, $taxonpage->title, $taxonpage->content);
  }
  else {
    cdm_dd("END OF TAXON PAGE [" . $chapter . "] " . $uuid . ' !!! PAGE IS EMPTY !!!');
    return '';
  }
}

/**
 * This function will genreate the taxon page part ($chapter) and returns a taxonpage object
 * which has two fields, one for the page title and one for the content. Later on in the
 * process chain the value contained in these fields will be passed to the cdm_node_show()
 * function as the function parameters $title and $content.
 *
 * @param string $uuid
 *   the uuid of the taxon to show
 * @param string $chapter
 *   Name of the part to display, valid values are:
 *   'description', 'images', 'synonymy', 'all'.
 *
 * @return object with the following fields:
 *   - title : the title of the page
 *   - content: the content of the page
 *
 */
function cdm_dataportal_taxon_view($uuid, $chapter = 'all') {
  // Taxon object.
  $taxon = cdm_ws_get(CDM_WS_PORTAL_TAXON, $uuid);
  if (empty($taxon)) {
    drupal_set_title(t('Taxon does not exist'), PASS_THROUGH);
    return FALSE;
  }
  $taxonpage = new stdClass();

  $taxonpage->title = theme('cdm_taxon_page_title', array(
    'taxon' => $taxon
  ));

  // Check if the taxon id contained in the currently selected tree.
  $taxon_in_current_classification = taxon_in_current_classification($uuid);

  if (!$taxon_in_current_classification) {
    $classifications = get_classifications_for_taxon($taxon);
    RenderHints::pushToRenderStack('not_in_current_classification');
    $taxon_name_markup = render_taxon_or_name($taxon);

    if (count($classifications) == 0) {
      drupal_set_message(t('This concept of the taxon !taxonname is not contained as an accepted taxon in the currently chosen classification.',
        array(
        '!taxonname' => $taxon_name_markup,
        )
      ), 'warning');
    }
    else {
      $trees = '';
      foreach ($classifications as $classification) {
        if (isset($classification->titleCache)) {
          $trees .= ($trees ? ', ' : '') . '<strong>' . $classification->titleCache . '</strong>';
        }
      }

      drupal_set_message(format_plural(count($trees),
          'This concept of the taxon !taxonname is not contained as an accepted taxon in the currently chosen classification, but in this one: !trees',
          'This concept of the taxon !taxonname is not contained as an accepted taxon in the currently chosen classification, but in one of these: !trees',
          array('!taxonname' => $taxon_name_markup, '!trees' => $trees)
        ) ,
        'warning');
    }
    RenderHints::popFromRenderStack();
  }

  // Render the taxon page.
  $render_array = compose_cdm_taxon_page($taxon, $chapter);
  $taxonpage->content = drupal_render($render_array);

  return $taxonpage;
}

/**
 * Creates a specimen page view.
 * @param string $uuid the UUID of the specimen
 * @return array|string
 */
function cdm_dataportal_specimen_page_view($uuid) {

    //cdm_check_valid_taxon_page($chapter);
    //cdm_dd("START OF TAXON PAGE [" . $chapter . "] " . $uuid . ' for ' . $_GET['q']);
    // show a warning in case the javascript development mode is anabled
    if(variable_get('cdm_js_devel_mode', FALSE)) {
        drupal_set_message(t('The !url1 is enabled.
        WARNING: this is a performance penalty and must be turned off on production websites.', array(
            '!url1' => l('java-script development mode', 'admin/config/cdm_dataportal/settings', array('fragment' => 'edit-cdm-js-devel-mode'))
        )),
            'warning'
        );
    }

    // Display the page for the specimen defined by $uuid.
    $specimenpage = cdm_dataportal_specimen_view($uuid);
    if (!empty($specimenpage)) {
        return cdm_node_show(NODETYPE_TAXON, $uuid, $specimenpage->title, $specimenpage->content);
    }
    else {
        return '';
    }
}

/**
 *
 * Creates a specimen view.
 * @param string $uuid the UUID of the specimen
 * @return array|string
 */
function cdm_dataportal_specimen_view($uuid) {
    $specimen = cdm_ws_get(CDM_WS_OCCURRENCE, $uuid);
    if (empty($specimen)) {
        drupal_set_title(t('Specimen does not exist'), PASS_THROUGH);
        return FALSE;
    }
    $specimenpage = new stdClass();

    $specimenpage->title = theme('cdm_specimen_page_title', array(
        'specimen' => $specimen
    ));

    // Render the specimen page.
    $render_array = compose_cdm_specimen_page($uuid);
    $specimenpage->content = drupal_render($render_array);

    return $specimenpage;
}

/**
 *
 * Creates a named area view.
 * @param string $uuid the UUID of the specimen
 *  * @return object
 *   An object with two fields:
 *     - title: the page title
 *     - content: the page content
 */

function cdm_dataportal_named_area_view($uuid) {
  $named_area = cdm_ws_get(CDM_WS_PORTAL_TERM, $uuid);
  if (empty($named_area) || $named_area->class !== 'NamedArea') {
    drupal_set_title(t('Named area does not exist'), PASS_THROUGH);
    return FALSE;
  }
  $named_area_page = new stdClass();

  $named_area_page->title = $named_area->representation_L10n;

  // Render the specimen page.
  $render_array = compose_cdm_named_area_page($uuid);
  $named_area_page->content = drupal_render($render_array);

  return $named_area_page;
}

function cdm_dataportal_named_area_page_view($uuid) {

  cdm_check_valid_portal_page();

  $named_area_page = cdm_dataportal_named_area_view($uuid);
  if (!empty($named_area_page)) {
    return cdm_node_show(NODETYPE_NAME, $uuid, $named_area_page->title, $named_area_page->content);
  }
  else {
    return '';
  }


}

/**
 * Returns a name page as a Drupal node ready to be renderized by Drupal.
 *
 * The node page shows the taxon name title and the list of taxon related
 * with such taxon. Name on the tree already in use.
 *
 * @param UUID $taxon_name_uuid
 *   The uuid of the CDM TaxonNameBase to show a name page for
 * @param UUID $taxon_to_hide_uuid
 *   A taxon which should not be displayed in the taxon list
 * @param UUID $highlite_synonym_uuid
 *   Optinal parameter wich takes another taxon uuid, if given the
 *   target taxon pages will show the syonymy tab where the taxon
 *   refenrenced by the $highlite_synonym_uuid will be highlighted
 *   in case it is found on this page.
 *
 * @return mixed
 *   The formatted name page as node.
 */
function cdm_dataportal_name_page_view($taxon_name_uuid, $taxon_to_hide_uuid, $synonym_uuid = NULL) {

  cdm_check_valid_portal_page();

  $taxonname_page = cdm_dataportal_name_view($taxon_name_uuid, $taxon_to_hide_uuid, $synonym_uuid);
  if (!empty($taxonname_page)) {
    return cdm_node_show(NODETYPE_NAME, $taxon_name_uuid, $taxonname_page->title, $taxonname_page->content);
  }
  else {
    return '';
  }
}

/**
 * View function for a TaxonNameBase page.
 *
 * The name page lists all taxa for which the name specified by the
 * $taxon_name_uuid is being used. I case there is only one name the
 * page automatically redirects ti the according taxon page. Otherwise
 * the list of names is displayed.
 *
 * The parameter $taxon_to_hide_uuid allows to exclude a taxon from the
 * list of taxa. This is useful for example when referencing from a taxon
 * to the name page and the referring taxon should not be repeaded in the
 * name page.
 *
 *
 * @param UUID $taxon_name_uuid
 *   The uuid of the CDM TaxonNameBase to show a name page for
 * @param UUID $taxon_to_hide_uuid
 *   A taxon which should not be displayed in the taxon list
 * @param UUID $highlite_synonym_uuid
 *   Optinal parameter wich takes another taxon uuid, if given the
 *   target taxon pages will show the syonymy tab where the taxon
 *   refenrenced by the $highlite_synonym_uuid will be highlighted
 *   in case it is found on this page.
 *
 * @return object
 *   An object with two fields:
 *     - title: the page title
 *     - content: the page content
 */
function cdm_dataportal_name_view($taxon_name_uuid, $taxon_to_hide_uuid, $highlite_synonym_uuid = NULL) {
  // Getting the full taxonname object from the server.
  $taxon_name = cdm_ws_get(CDM_WS_PORTAL_NAME, array($taxon_name_uuid));
  if (!$taxon_name) {
    drupal_set_title(t('Taxon name does not exist'), PASS_THROUGH);
    return FALSE;
  }
  // Searching for all the taxa connected with the taxon name on the tree
  // in use.
  $name_cache = cdm_ws_get(CDM_WS_NAME_NAMECAHE, array($taxon_name_uuid));
  $request_params = array();
  $request_params['query'] = $name_cache;
  $request_params['tree'] = get_current_classification_uuid();
  $request_params['doTaxa'] = 1;
  $request_params['doSynonyms'] = 1;
  $request_params['doTaxaByCommonNames'] = 0;
  $request_params['matchMode'] = "EXACT";
  $taxon_pager = cdm_ws_get(CDM_WS_PORTAL_TAXON_FIND, NULL, queryString($request_params));

  // Removing the name where we came from.
  foreach ($taxon_pager->records as $k => &$taxon) {
    if ($taxon->uuid == $taxon_to_hide_uuid) {
      unset($taxon_pager->records[$k]);
    }
  }
  // Show the taxa list or go to the singular taxon.
  if (sizeof($taxon_pager->records) == 1) {// Single taxon case.
    $singleTaxon = array_pop($taxon_pager->records);
    if ($singleTaxon->class != "Taxon") {
      // It is a Synonym -> look for the accepted.
      $accepted_taxon = cdm_ws_get(CDM_WS_PORTAL_TAXON_ACCEPTED, array($singleTaxon->uuid), 'classificationFilter=' . get_current_classification_uuid());
      if (!empty($highlite_synonym_uuid)) {
        drupal_goto('cdm_dataportal/taxon/' . $accepted_taxon->uuid . '/synonymy', array('query' => array('highlite' => $highlite_synonym_uuid)));
      }
      else {
        drupal_goto('cdm_dataportal/taxon/' . $accepted_taxon->uuid . '/synonymy', array('query' => array('highlite' => $singleTaxon->uuid)));
      }
    }
    else {
      // It is an accepted taxon.
      if (!empty($highlite_synonym_uuid)) {
        drupal_goto('cdm_dataportal/taxon/' . $singleTaxon->uuid . '/synonymy', array('query' => array('highlite' => $highlite_synonym_uuid)));
      }
      else {
        drupal_goto('cdm_dataportal/taxon/' . $singleTaxon->uuid);
      }
    }
  }
  else {// More than one taxa case.
    $taxon_name_page = new stdClass();
    $taxon_name_page->title = theme('cdm_name_page_title', array('taxon_name' => $taxon_name));
    if ($taxon_pager->records) {
      $taxon_name_page->content = compose_list_of_taxa($taxon_pager->records);
    }
    else {
      $taxon_name_page->content = 'This name has no taxa';
    }
    return $taxon_name_page;
  }
}

/**
 * Creates a page with the advance search form.
 *
 * NOTE: The advance search form allows searching for taxa.
 */
function cdm_dataportal_view_search_advanced() {
  drupal_set_title(t('Advanced search'), PASS_THROUGH);
  return drupal_get_form('cdm_dataportal_search_taxon_form_advanced');
}

/**
 * Creates a page with the search form for searching by taxon descriptions.
 */
function cdm_dataportal_view_search_taxon_by_description() {
  drupal_set_title(t('Search by factual data'), PASS_THROUGH);
  return drupal_get_form('cdm_dataportal_search_taxon_by_description_form');
}

/**
 * Executes the search and generates the result list of taxa.
 */
function cdm_dataportal_view_search_results_taxon() {

  $taxonPager = cdm_dataportal_search_execute();

  $showThumbnails = do_showThumbnails();

  $setSessionUri = url('cdm_api/setvalue/session', array(
      'query' => array('var' => '[pageoption][searchtaxa][showThumbnails]', 'val' => ''),
  ));

  drupal_add_js('jQuery(document).ready(function() {

      // init
      if(' . $showThumbnails . ' == 1){
          jQuery(\'.media_gallery\').show(20);
      } else {
          jQuery(\'.media_gallery\').hide(20);
      }

      // add change handler
      jQuery(\'#showThumbnails input.showThumbnails\').change(
      function(event){
        var state = 0;
        if(jQuery(this).is(\':checked\')){
          jQuery(\'.media_gallery\').show(20);
          state = 1;
        } else {
          jQuery(\'.media_gallery\').hide(20);
        }
        // store state in session variable
        var uri = \'' . $setSessionUri . '\' + state;
        jQuery.get(uri);
      });
  });',
  array('type' => "inline", 'scope' => JS_DEFAULT));

  drupal_set_title(t('Search results'), PASS_THROUGH);

  return theme('cdm_search_results', array(
    'pager' => $taxonPager,
    'path' => 'cdm_dataportal/search/results/taxon',
    ));
}

/**
 * Provides the standart image wich indicated a loading process
 *
 * @return string
 *  The img html tag
 */
function loading_image_html() {
  return '<img class="loading" src="' . base_path() . drupal_get_path('module', 'cdm_dataportal')
    . '/images/loading_circle_grey_16.gif" style="display:none;">';
}

/**
 * Returns the state of the the showThumbnails flag set in the
 * users session ($_SESSION['pageoption']['searchtaxa']['showThumbnails']).
 *
 * @return boolean
 *    returns 1 if the flag is set
 */
function do_showThumbnails() {
  static $showThumbnails = null;

  if($showThumbnails == null) {
    $showThumbnails = 0;
    if (!isset($_SESSION['pageoption']['searchtaxa']['showThumbnails'])) {
      $showThumbnails = 0;
      $search_gallery_settings = variable_get(CDM_DATAPORTAL_SEARCH_GALLERY_NAME, null);
      $showThumbnails = is_array($search_gallery_settings)
        && isset($search_gallery_settings['cdm_dataportal_show_taxon_thumbnails'])
        && (
            $search_gallery_settings['cdm_dataportal_show_taxon_thumbnails'] +
            $search_gallery_settings['cdm_dataportal_show_synonym_thumbnails'] +
            $search_gallery_settings['cdm_dataportal_show_thumbnail_captions'] > 0
            )
         ? 1 : 0;

       drupal_array_set_nested_value($_SESSION, array('pageoption', 'searchtaxa', 'showThumbnails'), $showThumbnails);
    }
    $showThumbnails = $_SESSION['pageoption']['searchtaxa']['showThumbnails'];
    if (!is_numeric($showThumbnails)) {
      $showThumbnails = 1;
    }
  }

  return $showThumbnails;
}


/* ====================== other functions ====================== */
/**
 * Creates a URL to the taxon page specified by the $uuid parameter.
 *
 * The URL will be prepended with a path element to a specific taxon page tab.
 *
 * This tab is either taken from the CDM_DATAPORTAL_DEFAULT_TAXON_TAB which can
 * be set globally in the administrative settings or individually in the user
 * profile. If the CDM_DATAPORTAL_DEFAULT_TAXON_TAB value is set to LAST_VISITED_TAB
 * the last portal will stay on this last tab.
 *
 * A third option is offerered by the $page_tab parameter which allows overwriting this
 * internal mechanism by a specific value.
 *
 * @param string $uuid
 *   The UUID of the taxon.
 * @param string $page_tab
 *   Overwriting the preset mechanism by defining specific value for the
 *   taxon page tab.
 *
 * @return string
 *   The created URL.
 */
function path_to_taxon($uuid, $page_tab = FALSE) {

  $tab = get_default_taxon_tab();
  $values = unserialize(CDM_DATAPORTAL_DEFAULT_TAXON_TAB);

  if (!$uuid) {
    return FALSE;
  }

  if ($page_tab) {
    return 'cdm_dataportal/taxon/' . $uuid . '/' . $page_tab;
  }
  elseif (!$tab || strtolower($tab) == 'general') {
    return 'cdm_dataportal/taxon/' . $uuid;
  }
  elseif (get_last_taxon_page_tab() &&   $tab == $values[CDM_DATAPORTAL_LAST_VISITED_TAB_ARRAY_INDEX]) {
    return 'cdm_dataportal/taxon/' . $uuid . '/' . get_last_taxon_page_tab();
  }
  else {
    return 'cdm_dataportal/taxon/' . $uuid . '/' . strtolower($tab);
  }
}

function path_to_specimen($uuid) {

    if (!$uuid) {
        return FALSE;
    }
    else {
        return 'cdm_dataportal/specimen/' . $uuid;
    }
}

function path_to_named_area($uuid) {

  if (!$uuid) {
    return FALSE;
  }
  else {
    return 'cdm_dataportal/named_area/' . $uuid;
  }
}

/**
 * Creates a URL to show a synonmy in the according taxon page.
 *
 * The URL will point to the synonymy tab of the taxon page of the accepted taxon given as parameter $acceptedUuid.
 * The resulting URI will include query parameters to highlight the synonym, and to optionally display
 * the accepted taxons name in aform like "Foo bar is accepted taxon for Ree doo". The URI will also
 * include the sysnonym uuid as fragment in order to let the browser scroll to the according location
 * in the page
 *
 * @param string $synonymUuid
 *    The uuid of the synonym
 * @param string $acceptedUuid
 *    The uuid of the according accepted taxon
 * @return string
 *    The URL to show a synonmy in the according taxon page
 */
function uri_to_synonym($synonymUuid, $acceptedUuid) {
  $acceptedPath = path_to_taxon($acceptedUuid, "synonymy");
  return url($acceptedPath, array(
      'query' => array(
        // highlite the synony in the synonymy
        'highlite' => $synonymUuid,
        // the taxon page is refered from a synonym and the synonym can optionally be named in the page title
        // see theme_taxon_page_title()
        'acceptedFor' => $synonymUuid
      ),
      'fragment' => $synonymUuid
  ));

}

/**
 * Compses the drupal path to the key identified by the uuid.
 *
 * @param string $keyType
 *    the key typer corresponds to the specific class of the CDM
 *    IdentificationKey. Possible values are
 *      -PolytomousKey
 *      -MultimediaKey
 *      - ...
 * @param UUID $keyUuid
 *   The UUID of the key
 */
function path_to_key($keyType, $keyUuid) {
  if (!$keyUuid || !$keyType) {
    return FALSE;
  }
  $keyType{0} = strtolower($keyType{0});
  return "cdm_dataportal/" . $keyType . "/$keyUuid";
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function path_to_reference($uuid) {
  if (!$uuid) {
    return FALSE;
  }
  return 'cdm_dataportal/reference/' . $uuid;
}

/**
 * Creates the path to a cdm_dataportal taxon name page.
 *
 * @param UUID $taxon_name_uuid
 *   The uuid of the CDM TaxonNameBase to show a name page for
 * @param UUID $taxon_to_hide_uuid
 *   A taxon which should not be displayed in the taxon list
 * @param UUID $highlite_synonym_uuid
 *   Optinal parameter wich takes another taxon uuid, if given the
 *   target taxon pages will show the syonymy tab where the taxon
 *   refenrenced by the $highlite_synonym_uuid will be highlighted
 *   in case it is found on this page.
 *
 * @return a URI path element as string
 */
function path_to_name($name_uuid, $taxon_to_hide_uuid = NULL, $synonym_uuid  = NULL) {
  $res = FALSE;
  if ($name_uuid) {
    $res = 'cdm_dataportal/name/' . $name_uuid;
  }
  if($taxon_to_hide_uuid){
    $res .= '/' . $taxon_to_hide_uuid;
    if($synonym_uuid){
      $res .= '/' . $synonym_uuid;
    }
  }
  return $res;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function path_to_media($uuid, $representaion_uuid = FALSE, $partId = FALSE) {
  if (!$uuid) {
    return FALSE;
  }
  $out = 'cdm_dataportal/media/' . $uuid;
  if ($representaion_uuid) {
    $out .= '/' . $representaion_uuid;
    if ($partId !== FALSE) {
      $out .= '/' . $partId;
    }
  }
  return $out;
}

/**
 * Compares thisRank with thatRank.
 *
 * Returns a negative integer, zero, or a positive integer
 * as the of thisRank is higher than, equal to, or lower than thatRank.
 * e.g:
 * <ul>
 * <li>rank_compare({species_uuid}, {genus_uuid}) = -1</li>
 * <li>rank_compare({genus_uuid}, {genus_uuid}) = 0</li>
 * <li>rank_compare({genus_uuid}, {tribus_uuid}) = 1</li>
 * </ul>
 * <p>
 * This compare logic of the underlying webservice is the
 * <b>inverse logic</b> of the the one implemented in
 * java.lang.Comparable#compareTo(java.lang.Object)
 *
 * @param $thisRankUuid
 * @param $thatRankUuid
 *
 * @return int
 *   A negative integer, zero, or a positive integer
 *   as the thisRank is lower than, equal to, or higher than thatRank.
 */
function rank_compare($thisRankUuid, $thatRankUuid) {
  $result = cdm_ws_get(CDM_WS_TERM_COMPARE, array($thisRankUuid, $thatRankUuid));
  return $result->Integer;
}

/**
 * Composes an HTML element class attribute value composed of
 * the shortname of the cdm class and the uuid of the entity.
 * This class attribute should be used whereever an cdm-entity is rendered.
 *
 * These according class selectors in css must be escaped, eg:
 *    .cdm\:TextData
 *
 * @param $cdmEntity
 */
function html_class_attribute_ref($cdmEntity) {

  if (is_cdm_entity($cdmEntity)) {
    return "cdm:" . $cdmEntity->class . " uuid:" . $cdmEntity->uuid;
  }
}


/**
 * Creates a short version of a taxonname.
 *
 * The short name is created by using the taggedTitle field of
 * TaxonNodeDTO instances.
 * If the taggedTitle if empty the fullname will be returned.
 *
 * @param object $taxonNodeDTO
 *   A TaxonNodeDTO object
 *
 * @return string
 */
function cdm_dataportal_shortname_of($taxonNodeDTO) {

  $nameStr = '';

  normalize_tagged_text($taxonNodeDTO->taggedTitle);

  // Get all tagged text tokens of the scientific name.
  foreach ($taxonNodeDTO->taggedTitle as $tagtxt) {
    if ($tagtxt->type == 'name' || $tagtxt->type == 'rank') {
      $nameStr .= ($nameStr ? ' ' : '') . $tagtxt->text;
    }
  }
  $nameStr = trim($nameStr);

  if ($nameStr) {

    // Do not return short names for these.
    if ($taxonNodeDTO->unplaced || $taxonNodeDTO->excluded) {
      return $nameStr;
    }

    /*
    1st capture group (^[a-zA-Z]): First letter of uninomial.
    Second capture group ([\p{L}]+): remaining letters of uninomial ([\p{L} = an UTF-8 letter).
    Third capture group (\s+[^(\x2E]+\s+.+$|\s+[a-zA-Z]+$): letters of name,
    but only matching if no '(' or '.' in second word of name,        ( \x2E = '.')
    OR only one specific epithet \s+[\p{L}\x22\x2D\xD7]+$             (\x22= '"', \x2D='-', \xD7='×' )
    */
    $pattern = '/(^[a-zA-Z])([\p{L}]+)(\s+[^(\x2E]+\s+.+$|\s+[\p{L}\x22\x2D\xD7]+$)/u';
    if (preg_match($pattern, $nameStr, $matches, PREG_OFFSET_CAPTURE)) {
      return $matches[1][0] . "." . $matches[3][0];
    }
    else {
      return $nameStr;
    }
  }
  else {
    return $taxonNodeDTO->titleCache;
  }
}

/**
 * Check if a taxon is accepted by the current taxonomic tree.
 *
 * @param mixed $taxon
 *   The Taxon obkect to check.
 *
 * @return bool
 *   Returns TRUE if $taxon is accepted, FALSE otherwise.
 */
function _cdm_dataportal_acceptedByCurrentView($taxon) {

  $defaultTreeUuid = get_current_classification_uuid();

  if (isset($taxon->taxonNodes)) {
    $taxonNodes = $taxon->taxonNodes;
  }
  else {
    $taxonNodes = cdm_ws_get(CDM_WS_PORTAL_TAXON_TAXONNODES, $taxon->uuid);
  }

  if ($taxon->class == "Taxon" && isset($taxonNodes)) {
    foreach ($taxonNodes as $node) {
      if (isset($node->classification)){
        if(is_object($node->classification)) {
          if ($node->classification->uuid == $defaultTreeUuid) {
            return TRUE;
          }
        }
        else {
          if ($node->classification == $defaultTreeUuid) {
            return TRUE;
          }
        }
      }
    }
  }

  return FALSE;
}

/**
 * Checks is the source has one of the given types.
 *
 * @param object $source
 *   The original source entity
 * @param array $types
 *   An array of elementd of the OriginalSourceType enumeration
 *   If not set the default will be used which is:
 *    - Lineage
 *    - PrimaryMediaSource
 *    - PrimaryTaxonomicSource
 *    - Unknown
 *    - Other
 * @return boolean
 */
  function _is_original_source_type($source, $types = null) {
    // this is the default
    // maybe this should also be put into the settings
    static $default = array(
      OriginalSourceType::Lineage,
      OriginalSourceType::PrimaryMediaSource,
      OriginalSourceType::PrimaryTaxonomicSource,
      OriginalSourceType::Unknown,
      OriginalSourceType::Other,
    );

    if(!$types){
      $types = $default;
    }
    return isset($source->type) && in_array($source->type, $types);
  }

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function _is_invers_taxonRelationship($taxonRelationship, $focusedTaxon) {
  return $taxonRelationship->toTaxon->uuid == $focusedTaxon->uuid;
}


/**
 * Collects all the media from a list of description elements.
 *
 * @param array $descriptionElements
 *   The description elements from which to collect the media.
 *
 * @return array
 *   The output with all the collected media.
 */
function cdm_dataportal_media_from_descriptionElements($descriptionElements) {

  $outArrayOfMedia = array();

  // Avoiding a warning box in Drupal for Flora Malesiana.
  if (isset($descriptionElements) && is_array($descriptionElements)) {
    foreach ($descriptionElements as $descriptionElement) {
      if (isset($descriptionElement->media) && is_array($descriptionElement->media)) {
        foreach ($descriptionElement->media as $media) {
          if (is_object($media)) {
            $outArrayOfMedia[] = $media;
          }
        }
      }
    }
  }
  return $outArrayOfMedia;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 *
 * @param array $cdm_entities
 *   An array of CdmBase instances or a single instance.
 * @param string $footnote_list_key_suggestion
 *
 * @return unknown
 */
function cdm_annotations_as_footnotekeys($cdm_entities, $footnote_list_key_suggestion = NULL) {

   static $annotations_types_filter = null;
   if(!$annotations_types_filter) {
     $annotations_types_filter = unserialize(ANNOTATIONS_TYPES_AS_FOOTNOTES_DEFAULT);
   }

  $footNoteKeys = array();

  // Is argument cdmBase an array?
  if (!is_array($cdm_entities)) {
    $cdmBase_array = array();
    $cdmBase_array[] = $cdm_entities;
  }
  else {
    $cdmBase_array = $cdm_entities;
  }

  // Getting the key for the footnotemanager.
  if (isset($footnote_list_key_suggestion)) {
    $footnote_list_key = $footnote_list_key_suggestion;
  }
  else {
    $footnote_list_key = RenderHints::getFootnoteListKey() . '-annotations';
  }

  // Adding the footnotes keys.
  foreach ($cdmBase_array as $cdmBase_element) {
    $annotations = cdm_ws_getAnnotationsFor($cdmBase_element, variable_get('annotations_types_as_footnotes', $annotations_types_filter));
    if (is_array($annotations)) {
      foreach ($annotations as $annotation) {
        $footNoteKeys[] = FootnoteManager::addNewFootnote($footnote_list_key, $annotation->text);
      }
    }
  }

  return $footNoteKeys;
}


/**
 * Creates a CDM Dynabox.
 *
 * @param string $dynabox_id
 *   a uninque name for tha dynabox, using a cdm entity uuid as id is good practice.
 * @param string $label
 *   The clickable text to show.
 * @param string $content_url
 *   The cdm REST service request url wich will deliver the content to be shown
 *   once the dynabox toggles open.
 * @param string $theme
 *   The theme to be used for rendering the cdm REST service response with is
 *   returned from the $content_url.
 * @param string $link_alt_text
 *   The value for the alt attribute of the dynabox link.
 * @param array $enclosingtags
 *   An array with two elements: $enclosingtags[0] will be used for the dynabox
 *   element itself, $enclosingtags[1] is the tag to be used for the
 *   dynabox_content (optional)
 * @param array $attributes
 * @param $content_element_selector
 *   Optional jQuery selector which can be used to reference a dom element which should
 *   be used as container for the content to be shown. The dynabox-<dynabox id>-content
 *  element will be placed in this container.
 *
 * @param string $open_callback
 *   optional javascript call back function to be triggered after toggling the box to
 *   the open state.
 * @param string $close_callback
 *   optional javascript call back function to be triggered after toggling the box to
 *   the closed state.
 * @return string Returns HTML for a dynabox.
 * Returns HTML for a dynabox.
 */
function cdm_dynabox($dynabox_id, $label, $content_url, $theme, $link_alt_text,
                     $enclosingtags = array('li', 'ul'), $attributes = array(),
                     $content_element_selector = null,
                     $open_callback = 'function(){}', $close_callback = 'function(){}' ) {
  $out = '';

  // check for plain class attribute string
  $dynabox_id = preg_replace('/[^a-zA-Z0-9\-]/', '', $dynabox_id);

  if(!array_key_exists('class', $attributes)) {
    $attributes['class'] = array();
  }
  $attributes['id'][] = 'dynabox-' . $dynabox_id;
  $dynabox_attributes = drupal_attributes($attributes);


  _add_js_domEvent(); // requires domEvent.js
  drupal_add_js(drupal_get_path('module', 'cdm_dataportal') . '/js/cdm_dynabox.js');
  drupal_add_js("
  jQuery(document).ready(
      function() {
        dynabox('". $dynabox_id ."',
          {
            open_callback: " . $open_callback .",
            close_callback: " . $close_callback .
            ($content_element_selector ? ",\n content_container_selector: '" . $content_element_selector . "'" : "") . "
          }
        );
      }
   );",
   array(
    'type'=>'inline',
    'scope'=>'footer'
    )
  );


  $cdm_proxy_url = url('cdm_api/proxy/' . urlencode($content_url) . "/$theme");
  $out .= '<!-- dynabox for ' . $content_url . ' -->';
  $out .= '<' . $enclosingtags[0] . ' ' .  $dynabox_attributes. '><a href="' . $cdm_proxy_url . '" class="label" alt="' . t('@link-alt-text', array('@link-alt-text' => $link_alt_text)) . '">' . $label . '</a>';
  $out .= '  <' . $enclosingtags[1] . ' id="dynabox-' . $dynabox_id . '-content">';
  $out .= '    <' . $enclosingtags[0] . ' class="dynabox-content-inner">' . loading_image_html() . '</' . $enclosingtags[0] . '>';
  $out .= '    </' . $enclosingtags[1] . '>';
  $out .= '  </' . $enclosingtags[0] . '>';
  $out .= '<!-- dynabox end -->';
  return $out;
}

/**
 * Checks whether a feature has any description elements.
 *
 * @param mixed $featureNode
 *   A feature node as produced by the function _mergeFeatureTreeDescriptions().
 *
 * @see _mergeFeatureTreeDescriptions()
 *
 * @return bool
 *   Returns TRUE if the given $featureNode or any of its subordinate nodes
 *   contains at least one non empty TextData or at least one DescriptionElement
 *   of an other type. A TextData element holding a multilanguageText or a
 *   source reference is considered to be not empty.
 *
 * @TODO this function may have become obsolete by the new method of detecting empty blocks,
 *       see $block_content_is_not_empty in compose_feature_blocks() and
 *       $feature_block_has_content in compose_feature_block_items_generic
 */
function has_feature_node_description_elements($featureNode) {

  if (isset($featureNode->descriptionElements) && is_array($featureNode->descriptionElements) && count($featureNode->descriptionElements) > 0) {
    if(!isset($featureNode->descriptionElements['#type'])){ // #type is used to identify e.g. DTO elements: '#type' => 'DTO'
      foreach ($featureNode->descriptionElements as $descriptionElement) {
        if ($descriptionElement->class != "TextData" || isset($descriptionElement->multilanguageText_L10n->text)
          && $descriptionElement->multilanguageText_L10n->text != ''
          || isset($descriptionElement->sources[0])
          || isset($descriptionElement->media[0]) ) {
          return TRUE;
        }
      }
    }
  }
  else if (isset($featureNode->childNodes) && is_array($featureNode->childNodes)) {
    foreach ($featureNode->childNodes as $child) {
      if (has_feature_node_description_elements($child)) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Checks if the current page is a valid taxon portal page and responds with HTTP status 404 (not found) otherwise
 *
 * @param $chapter
 *   The taxon page chapter or part
 */
function cdm_check_valid_taxon_page($chapter){
  static $taxon_tabs = null;

  cdm_check_valid_portal_page();

  if($taxon_tabs == null){
    $taxon_tabs = array('all', 'description');
    foreach(get_taxon_tabs_list() as $tab){
      $taxon_tabs[] = strtolower($tab);
    }
  }

  if(!in_array($chapter, $taxon_tabs)){
    // oops this is not a valid chapter name
    http_response_code(404); // 404 = Not Found
  }

}

/**
 * Checks if the current page is a valid portal page and responds with HTTP status 404 (not found) otherwise
 *
 * @param $chapter
 *   The taxon page chapter or part
 */
function cdm_check_valid_portal_page(){
  $ends_with_file_suffix_pattern = '/\/[^\.\/]*[\.][^\.\/]*$/';
  if(preg_match($ends_with_file_suffix_pattern, $_GET['q'])){
    // oops this urls ends with a file_suffix and thus does not refer to a portal page
    http_response_code(404); // 404 = Not Found
    exit('HTTP 404');
  }
}

/**
 * Generates the diff of the texts and presents it in a HTML diff viewer.
 *
 * @param $text_a
 * @param $text_b
 * @return string
 */
function diff_viewer($text_a, $text_b) {

  static $diff_viewer_count = 0;

  $element_id = 'part_definitions_diff_' . $diff_viewer_count++;

  // http://code.stephenmorley.org/php/diff-implementation/
  module_load_include('php', 'cdm_dataportal', 'lib/class.Diff');
  drupal_add_css(drupal_get_path('module',
      'cdm_dataportal') . '/css/diff.css');
  _add_jquery_ui();
  drupal_add_js(
    'jQuery(document).ready( function(){
        jQuery(\'#' . $element_id . '\').accordion({
        collapsible: true,
        active: false,
        fillSpace: true,
        }).children(\'div\').css({ \'height\': \'auto\' });
        jQuery(\'#' . $element_id . ' table.diff\').prepend(\'<thead><tr><th>Default</th><th>User defined<th></th><tr></thead>\');
     });'
    , array(
    'type' => 'inline',
    'scope' => 'footer'
  ));

  $diff = Diff::compare($text_a,
    $text_b);
  $diff_viewer_markup = '<div id="' . $element_id . '"><h3>View Diff</h3><div>'
    . Diff::toTable($diff, '', '')
    . '</div></div>';
  return $diff_viewer_markup;
}


