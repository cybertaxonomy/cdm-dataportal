<?php
// $Id$

/*
 * @file
 * cdm_taxontree.module
 *
 * Copyright (C) 2007 EDIT
 * European Distributed Institute of Taxonomy
 * http://www.e-taxonomy.eu
 *
 * The contents of this file are subject to the Mozilla Public License Version 1.1
 * See LICENSE.TXT at the top of this package for the full license terms.
 */


/**
 * Implementation of hook_menu()
 */
function cdm_taxontree_menu($may_cache) {
  
  $items = array();
  if ($may_cache) {

    $items[] = array(
      'path' => 'cdm_taxontree/set',
      'callback' => 'cdm_taxontree_set',
      'access' => true,
      'type' => MENU_CALLBACK, 
    );

  }
  return $items;
}


/**
 * Implementation of hook_block()
 *
 * @param String $op
 * @param int $delta
 */
function cdm_taxontree_block($op='list', $delta=0) {
  if ($op == "list") {
    $block[0]["info"] = t('CDM Taxon Tree');
    return $block;
  }
  else if ($op == 'view') {
    switch($delta){
      case 0:
        $block['subject'] = t('CDM Taxon Tree');
        $taxonUuid_inFocus = _cdm_get_taxonuuid();
        $tree = cdm_taxontree_build_tree($taxonUuid_inFocus);
        $block['content'] = theme('cdm_taxontree_block', $tree, $taxonUuid_inFocus);
        drupal_add_css(drupal_get_path('module', 'cdm_taxontree').'/cdm_taxontree.css');
        drupal_add_js(drupal_get_path('module', 'cdm_taxontree').'/cdm_taxontree.js');
        return $block;
    }
  }
}

function cdm_taxontree_set($key, $value){
  
  if(is_string($key)){
    $_SESSION['cdm']['taxontree'][$key] = $value; 
  }
  
  if($_REQUEST['destination']){
    $destination = $_REQUEST['destination'];
    unset($_REQUEST['destination']);
    drupal_goto($destination);
  }
}

function _is_compact_mode(){
  return isset($_SESSION['cdm']['taxontree']['compact']) && $_SESSION['cdm']['taxontree']['compact'];
}

function cdm_taxontree_build_tree($taxonUuid){

  // find the secRefUuid
  if($taxonUuid){
    //TODO poor performance here:
    $taxon =  cdm_ws_get(CDM_WS_TAXON, $taxonUuid);
    $secRefUuid = $taxon->sec->uuid;
  }

  if(!$secRefUuid){
    $secRef = _cdm_dataportal_currentSecRef_array();
    $secRefUuid = $secRef['uuid'];
  }

  $filtersActive = cdm_dataportal_filters_areset();
  $compact_tree = $filtersActive && _is_compact_mode();
  
  if(!$compact_tree){
    // get the root
    $root_tree = cdm_ws_get(CDM_WS_TREENODE_ROOT, $secRefUuid);
    $root_tree = _cdm_resultset2tree($root_tree);
    
    if($filtersActive){
      // the paths up to active filters are inactivated and thus cannot be browsed by expanding nodes
      // therefore we need to build up the branches for all nodes which are set as filters
      // the branches are merged with the root
      foreach(cdm_dataportal_filters_get() as $uuid=>$filter){
        $branch = cdm_taxontree_build_branch($uuid);
        $root_tree = _cdm_taxontree_merge($root_tree, $branch);
      }
    }
  } else {
    $root_tree = cdm_dataportal_filters_get();
    
  }
  
  // build the the branch for the focused node and merge it with the root
  if($taxonUuid){
    $branch = cdm_taxontree_build_branch($taxonUuid);
    $root_tree = _cdm_taxontree_merge($root_tree, $branch);
  }
  
  return $root_tree;
}

/**
 * Builds the specific branch for $taxonUuid. 
 * The branch reaches from the parent root node of $taxonUuid up to the children of $taxonUuid.
 * The siblings od all parent of $taxonUuid are included except for the root siblings.
 *
 * @param unknown_type $taxonUuid
 * @return a subtree
 */
function cdm_taxontree_build_branch($taxonUuid){
  
  $branch = array();
  $parents = cdm_ws_get(CDM_WS_TREENODE_PARENTS, $taxonUuid);
  //TODO improve performance by changing the web service and thus making this line obsolete
  $parents = array_reverse($parents);
  $parents = _cdm_resultset2tree($parents);
  $lastParent = null;
  foreach($parents as $pnode){
    if($pnode->hasChildren){
        $children = cdm_ws_get(CDM_WS_TREENODE_CHILDREN, $pnode->uuid);
        $children = _cdm_resultset2tree($children);
        $pnode->children = $children;
      if($lastParent){
        $pnode->children[$lastParent->uuid] = $lastParent;
      }
    }
    $lastParent = $pnode;
  }
  $branch[$pnode->uuid] = $pnode;
  return $branch;
}

/**
 * Merge a branch into a root tree
 *
 * @param unknown_type $tree
 * @param unknown_type $branch
 * @return the merged $tree
 */
function _cdm_taxontree_merge($tree, $branch) {
      
    foreach($tree AS $uuid => $node) {       
        // check IF node exists is $branch
        if(!empty($branch[$uuid])) {
            // $Uuid exists check if the node in tree1 or tree2 contains children
            if(is_array($branch[$uuid]->children) && is_array($tree[$uuid]->children)) {
              // merge recursive
              $tree[$uuid]->children = _cdm_taxontree_merge($tree[$uuid]->children, $branch[$uuid]->children);
            } else if(is_array($branch[$uuid]->children)){
              $tree[$uuid] =  $branch[$uuid];
            }  
        } 
    }
    // unset($uuid, $node);
    return $tree;
}

function theme_cdm_taxontree_block($tree, $taxonUuid_inFocus = null){
    
  $out = '';
  if(cdm_dataportal_filters_areset()){
        $out = '<div class="settings">'.l((_is_compact_mode()? t('expand tree'):t('compact tree')), 'cdm_taxontree/set/compact/'.(_is_compact_mode() ? 0:1), array(), drupal_get_destination()).'</div>';
  }
  $out .= theme('cdm_taxontree', $tree, $taxonUuid_inFocus, !cdm_dataportal_filters_areset());
  return $out;
}

function theme_cdm_taxontree($tree, $taxonUuid_inFocus = null, $filterIncludes = null){
  
  if(!is_array($tree)) {
    return false;
  }
 
  if(is_null($filterIncludes)){
    // set $filterIncludes true if no filters are set.
    $filterIncludes = !cdm_dataportal_filters_areset();
  }
  
  $out = '<ul class="cdm_taxontree">';
  foreach($tree as $node){
    $out .= theme('cdm_taxontree_node', $node, $taxonUuid_inFocus == $node->uuid, $filterIncludes);
  }
  $out .= '</ul>';
  return $out;
}

function theme_cdm_taxontree_node($node, $isFocused, $filterIncludes){
  //TODO clean up function
  $is_leaf = !$node->hasChildren || $node->hasChildren == 0;
  
  $is_expanded = !$is_leaf && isset($node->children);


  if($filterIncludes){
    // 
    $name = l(cdm_dataportal_shortname_of($node), cdm_dataportal_taxon_path($node->uuid));
    $filter_icon = 'visible_implicit_small.gif';
    $filter_on = false;
  } else {
    $filter_on = isset($_SESSION['cdm']['filters'][$node->uuid]);
    if($filter_on) {
      $name = l(cdm_dataportal_shortname_of($node), cdm_dataportal_taxon_path($node->uuid));
      $filter_icon = 'visible_small.gif';
    } else {
      $filter_icon = 'invisible_small.gif';
      $name .= cdm_dataportal_shortname_of($node);
    }
  }
  $nextLevelIncluded = $filter_on || $filterIncludes;

  $cdm_proxy_url = false;
  if(!$is_leaf && !$is_expanded){
    $ws_url = cdm_compose_url(CDM_WS_TREENODE_CHILDREN, array($node->uuid));
    $cdm_proxy_url = url('cdm_api/proxy/'.urlencode($ws_url).'/cdm_taxontree/0/'.($nextLevelIncluded ? 1 : 0));
  }

  $filter_op = isset($_SESSION['cdm']['filters'][$node->uuid]) ? 'remove' : 'add';
  
  // list item
  $out = '<li class="'
  .($isFocused ?'focused ':'')
  .($is_leaf ?'leaf ':($is_expanded ?'expanded ':'collapsed '))
  .($filterIncludes ? 'filter_includes' : ($filter_on ? 'filter_on' : 'filter_excludes'))
  .'"'
  .($cdm_proxy_url ? 'title="'.$cdm_proxy_url.'"' : '')
  .'>';
  
  // filter icon 
  $out .= '&nbsp;'
     .l('<img src="'.drupal_get_path('module', 'cdm_taxontree').'/'.$filter_icon.'" alt="[f]" />', 
    'cdm_dataportal/filter/'.$filter_op.'/'.$node->uuid, array('class'=>'filter_'.$filter_op), 
    'destination='.cdm_dataportal_taxon_path($node->uuid), 
     null, false, true);
  
  // taxon name
  $out .= $name;
  
  // concept_switch
  if(isset($node->alternativeConceptRefs[0])){
    $out .= l(
      '<img src="'.drupal_get_path('module', 'cdm_taxontree').'/concept_switch.gif" alt="[-&gt;]" />', 
      'cdm_dataportal/taxon/alternative/'.$node->uuid, 
      array('rel'=>'cdm_dataportal/taxon/alternative/'.$node->uuid, 'class'=>'concept_switch'), 
      null, null, false, true);
  }
  
  if(isset($node->children) && is_array($node->children)){
      $out .= theme('cdm_taxontree', $node->children, $taxonUuid_inFocus, $nextLevelIncluded);
  }
  $out .= '</li>';
  
  return $out;
}

/**
 * Replaces the keys of an array of TreeNode instances
 * by the $treeNode->uuid of the single array elements.
 *
 * @param $resultset array of TreeNode instances as +returned by the cdm web service
 */
function _cdm_resultset2tree($resultset){

  if(! is_array($resultset)) {
    return false;
  }

  $tree = array();
  foreach($resultset as $treeNode){
    $tree[$treeNode->uuid] = $treeNode;
  }
  return $tree;
}


function _cdm_get_taxonuuid(){

  //TODO make the path configurable
  if (arg(0)=="cdm_dataportal" && arg(1)=="taxon" && arg(2)!==0){
    $taxon_uuid = arg(2);
  } else {
    $taxon_uuid = $_SESSION['cdm_dataportal']['tree']['taxon_uuid'];
  }

  return $taxon_uuid;
}