<?php
// $Id$

/*
 * @file
 * cdm_taxontree.module
 *
 * Copyright (C) 2007 EDIT
 * European Distributed Institute of Taxonomy
 * http://www.e-taxonomy.eu
 */

/**
 * Implementation of hook_menu()
 */
function cdm_taxontree_menu($may_cache) {

    $items = array();
    if ($may_cache) {
  
        $items[] = array(
          'path' => 'cdm_taxontree/set',
          'callback' => 'cdm_taxontree_set',
          'access' => true,
          'type' => MENU_CALLBACK,
        );
        
         $items[] = array(
    
          'path' => 'cdm_taxontree/filter',
          'callback' => 'cdm_taxontree_view_filter',
          'access' => true,
          'type' => MENU_CALLBACK,
        );
        
        $items[] = array(
          'path' => 'cdm_taxontree/taxonomy/children',
          'callback' => 'cdm_taxontree_taxonomy_children',
          'access' => true,
          'type' => MENU_CALLBACK,
        );
  
    }
    return $items;
}


/**
 * Implementation of hook_block()
 *
 * @param String $op
 * @param int $delta
 */
function cdm_taxontree_block($op='list', $delta=0, $edit = array()) {
  if ($op == "list") {
    $block['cdm_tree']["info"] = t('CDM Taxon Tree');
    $block['filters']["info"] = t('Active Filters');
    $block[1]["info"] = t('Drupal Taxonomy Tree');
    return $block;
  }
  else if ($op == 'view') {
    switch($delta){
      case 'cdm_tree':
        $block['subject'] = t('CDM Taxon Tree');
        $taxonUuid_inFocus = _cdm_get_taxonuuid();
        $tree = cdm_taxontree_build_tree($taxonUuid_inFocus);
        $block['content'] = theme('cdm_taxontree_block', $tree, $delta, TRUE, 'cdm_taxontree_node_concept_switch');
        theme('cdm_taxontree_add_scripts');
        drupal_add_js('
        if (Drupal.jsEnabled) {
        $(document).ready(function()
        {
          $(\'ul.cdm_taxontree\').cdm_taxontree();
          $(\'div.cdm_taxontree_scroller_x\').scrollTo($(\'.active\'), 800, {over:-3});});
        }', 'inline');
         return $block;
        
      case 'filters':
        $block['subject'] = t('Active Filters');
        $block['content'] = cdm_taxontree_view_filter('list');
        return $block;
        
      case 1:
        $block['subject'] = t('Drupal Taxonomy Tree ');
        $term_inFocus = arg(0) == 'taxonomy' && arg(1) == 'term' ? arg(2) : 0;
        $tree = cdm_taxontree_build_tree($term_inFocus, true, variable_get('cdm_taxontree_block_1_vid', 0));
        $block['content'] = theme('cdm_taxontree_block', $tree);
        theme('cdm_taxontree_add_scripts');
        drupal_add_js('
        if (Drupal.jsEnabled) {
        $(document).ready(function()
        {
          $(\'ul.cdm_taxontree\').cdm_taxontree();
          $(\'div.cdm_taxontree_scroller_x\').scrollTo($(\'.active\'), 800, {over:-3});});
        }', 'inline');

        return $block;
      }
    } else if ($op == 'configure') {
      switch($delta){
        case 1:
          $vocs = taxonomy_get_vocabularies();
          $options = array();
          foreach($vocs as $voc){
            $options[$voc->vid] = $voc->name;
          }
          $form['vid'] = array(
            '#type' => 'select',
            '#title' => t('Category'),
            '#default_value' => variable_get('cdm_taxontree_block_1_vid', 0),
            '#options' => $options,
          );
          return $form;
      }
    } else if ($op == 'save') {
      switch($delta){
        case 1:
         variable_set('cdm_taxontree_block_1_vid', $edit['vid']);
         return;
      }
    }
}

/**
 * Enter description here...
 *
 * @param unknown_type $key
 * @param unknown_type $value
 */
function cdm_taxontree_set($key, $value){

  if(is_string($key)){
    $_SESSION['cdm']['taxontree'][$key] = $value;
  }

  if($_REQUEST['destination']){
    $destination = $_REQUEST['destination'];
    unset($_REQUEST['destination']);
    drupal_goto($destination);
  }
}





/**
 * Enter description here...
 *
 * @param UUID $secUuid
 * @return unknown
 */
function cdm_taxontree_secRefTitle_for($secUuid){
  
  $refSTO = cdm_api_secref_cache_get($secUuid);
  if($refSTO && isset($refSTO->fullCitation)){
    $cit = $refSTO->fullCitation;
  } else {
    $cit = '[no title for:'.$secUuid.']';
  }
  return $cit;
}

/**
 * Theme function that returns a <span> element containing the secundum of a given TreeNode> element
 *
 * @param array $node The <TreeNode> element as returned by the webservice
 *
 * @return String html formatted title of the secundum
 */
function theme_cdm_taxontree_node_reference(&$node){

  $secRefTitle = cdm_taxontree_secRefTitle_for($node->secUuid);
  // encode any special characters
  $secRefTitle = check_plain($secRefTitle);
  $out = ' <span class="sec_ref widget_select" title="'.$secRefTitle.'" style="background-color:#'._uuid_to_rgbhex($node->secUuid).'" alt="'.$node->secUuid.'">'
      .$secRefTitle.'</span>';
  return $out;
}

/**
 * Queries the Drupal database for the location of a certain block with the given $delta
 *
 * @param [String | Number] $delta
 * @return values (left |Â right | <empty>)
 */
function _get_block_region($delta){
  global $user, $theme_key;
  
  $result = db_fetch_array(db_query("SELECT DISTINCT b.region FROM {blocks} b LEFT JOIN {blocks_roles} r ON b.module = r.module AND b.delta = r.delta WHERE b.theme = '%s' AND b.status = 1 AND (r.rid IN (%s) OR r.rid IS NULL) AND b.module = '%s' AND b.delta = '%s'", $theme_key, implode(',', array_keys($user->roles)), 'cdm_taxontree', $delta));
  return $result['region'];
}

/**
 * Enter description here...
 *
 * @return unknown
 */
function _get_compact_mode(){

  if(!isset($_SESSION['cdm']['taxontree']['compact_mode'])){
    $_SESSION['cdm']['taxontree']['compact_mode'] = 'expanded';
  }
  return  $_SESSION['cdm']['taxontree']['compact_mode'];
}

/**
 * Enter description here...
 *
 * @param unknown_type $str
 * @return unknown
 */
function _is_uuid($str){
  return strlen($str) == 36 && strpos($str, '-');
}

/**
 * Converts an array of drupal taxonomy terms into an
 * array of partially instantiated cdm tree nodes by adding the fields
 * relevant for tree node processing in cdm_taxontree
 *
 *
 * term       =>      cdm tree node
 * ------------------------------------
 * tid       ->     uuid
   name      ->     fullname
                    taggedName
                    secUuid
                    isAccepted
                    hasChildren
                    alternativeConceptRefs
 *
 * @param unknown_type $terms
 */
function cdm_taxontree_terms2treenodes(&$terms){
  foreach($terms as &$term){
    $term->uuid = $term->tid;
    $term->fullname = $term->name;
    $term->hasChildren = count(taxonomy_get_children($term->tid, $term->vid));
  }
  return $terms;
}

/**
 * Enter description here...
 *
 * @param unknown_type $tid
 * @param unknown_type $vid
 * @param unknown_type $theme
 */
function cdm_taxontree_taxonomy_children($tid, $vid, $theme){
  $args = func_get_args();
  $tid = array_shift($args);
  $vid = array_shift($args);
  $theme = array_shift($args);
  
  $children = cdm_taxontree_get_children($tid, $vid);
  $children = cdm_taxontree_terms2treenodes($children);
  array_unshift($args, $theme, $children);
  print call_user_func_array('theme', $args);
}

/**
 * Enter description here...
 *
 * @param unknown_type $vid
 * @param unknown_type $secRefUuuid
 * @return unknown
 */
function cdm_taxontree_get_root($vid = null, $secRefUuuid = null){
  if(is_numeric($vid)){
    // vid, $parent = 0, $depth = -1, $max_depth = NULL) {
    $terms = taxonomy_get_tree($vid, 0, -1, 1);
    return cdm_taxontree_terms2treenodes($terms);
  } else {
    return cdm_ws_get(CDM_WS_TREENODE_ROOT, $secRefUuuid);
  }
}

/**
 * Enter description here...
 *
 * @param unknown_type $uuid
 * @param unknown_type $vid
 * @return unknown
 */
function cdm_taxontree_get_children($uuid, $vid = null){

  if(is_numeric($vid)){
    $terms = taxonomy_get_children($uuid, $vid);
    return cdm_taxontree_terms2treenodes($terms);
  } else {
    return cdm_ws_get(CDM_WS_TREENODE_CHILDREN, $uuid);
  }
}

/**
 * Enter description here...
 *
 * @param unknown_type $uuid
 * @return unknown
 */
function cdm_taxontree_get_parents($uuid){

  if(!_is_uuid($uuid)){
    $terms = taxonomy_get_parents($uuid);
    array_push($terms, taxonomy_get_term($uuid));
    $terms = array_reverse($terms);
    return cdm_taxontree_terms2treenodes($terms);
  } else {
    return cdm_ws_get(CDM_WS_TREENODE_PARENTS, $uuid);
  }
}

/**
 * builds a tree of TaxonNode instances, whereas the instances are extended by some fields:
 *
 *  - $node->filter: values ( 'on', 'excluded', 'included' )
 *  - $node->expanded: values ( 'expanded', 'collapsed' )
 *    $node->focused: values ( TRUE, FALSE )
 *
 * @param unknown_type $taxonUuid
 * @return unknown
 */
function cdm_taxontree_build_tree($taxonUuid = null, $hideOtherConcepts = true, $vid = null){

  // find the secRefUuid
  $secRefUuid = null;
  if(is_null($vid)){
    if($taxonUuid){
      //TODO poor performance here:
      $taxon =  cdm_ws_get(CDM_WS_TAXON, $taxonUuid);
      $secRefUuid = $taxon->sec->uuid;
    }
  
    if(!$secRefUuid){
      $secRefUuid = variable_get('cdm_secUuid_default',false);
    }
    
    $compact_tree = cdm_taxontree_filters_active() && _get_compact_mode() != 'expanded';
  }
  // compact_modes: 'expanded', 'compact', 'flattened'

  // get the root level
  $root_tree = cdm_taxontree_get_root($vid, ($hideOtherConcepts ? $secRefUuid : null));
//  if(!$root_tree || !is_array($root_tree)){
//    return array();
//  }
  $root_tree = _cdm_resultset2nodelist($root_tree, cdm_taxontree_filters_active());
  

  if(cdm_taxontree_filters_active()){
    // the paths up to active filters are inactive in the user interface and
    // thus cannot be browsed by expanding nodes
    // therefore we need to build up the branches for all nodes which are set as filters
    // the branches are merged with the root
    foreach(cdm_taxontree_filters_get() as $uuid=>$filter){
      $branch = cdm_taxontree_build_path($uuid, TRUE, ($compact_tree === false ? true :null));
      $root_tree = _cdm_taxontree_merge($root_tree, $branch);
    }
  }

  // build the the branch for the focused node and merge it with the root
  if($taxonUuid){
    $branch = cdm_taxontree_build_path($taxonUuid, NULL, (cdm_taxontree_filters_active() ? NULL : TRUE), TRUE);
    $root_tree = _cdm_taxontree_merge($root_tree, $branch);
  }

  //reorder siblings & populate expanded nodes with children and propagate the filter attribute
  $root_tree = cdm_taxontree_populate($root_tree, $compact_tree === false);

  // flatten tree
  if($compact_tree){
    if( _get_compact_mode() == 'flattened'){
      $root_tree = cdm_taxontree_flatten($root_tree);
    } else if(_get_compact_mode() == 'compact') {
      foreach($root_tree as $uuid => $node){
        if( $node->filter == 'excluded' && !$node->children){
          unset($root_tree[$uuid]);
        }
      }
    }
  }

  return $root_tree;
}

/**
 * Builds the specific branch path for $taxonUuid.
 * The branch path reaches from the parent root node of $taxonUuid up to $taxonUuid.
 *
 * @param UUID $taxonUuid
 * @param Boolean $is_filter_path whether the upmost node of this path is mapped by an active filter
 * @param Boolean $is_expanded whether all nodes along the tree are expanded
 * @param Boolean $is_focused whether to upper most element of this branch is set as filter
 * @return a subtree
 */
function cdm_taxontree_build_path($taxonUuid, $is_filter_path = null, $is_expanded = null, $is_focused = FALSE){

  $branch_path = array();
  
  $parents = cdm_taxontree_get_parents($taxonUuid);
  if(!$parents){
    if($is_filter_path){
      // remove invalid filter
      cdm_taxontree_filters_remove($taxonUuid);
    }
    return false;
  }

  $parents = _cdm_resultset2nodelist($parents, NULL);
  $lastParent = null;
  foreach($parents as $pnode){
    $pnode->focused = false;
    if($lastParent){
      $pnode->children = array($lastParent->uuid => $lastParent);
      if(!is_null($is_filter_path)){
        $pnode->filter = ($is_filter_path ? 'excludes' : 'included');
      }
      if(!is_null($is_expanded)){
        $pnode->expanded = ($is_expanded ? 'expanded' : 'collapsed');
      }
    } else {
      // the uppermost node of branch
      if(!is_null($is_filter_path)){
        $pnode->filter = ($is_filter_path ? 'on' : 'includes');
      }
      // uppermost node is always expanded if it has children
      $pnode->focused = $is_focused;
      $pnode->expanded = ($pnode->hasChildren ? 'expanded' : 'collapsed');
    }
    $lastParent = $pnode;
  }
  $branch_path[$pnode->uuid] = $pnode;
  return $branch_path;
}

/**
 * Performs two steps on each level of the tree:
 *  1. reorder siblings except root (is expected to be ordered jet) alphabetically
 *  2. populate children of expanded nodes  & propagate the filter attribute
 *
 * @param unknown_type $tree
 * @return unknown
 */
function cdm_taxontree_populate($tree, $expand_excluded, $filter_default = null){

  if(!is_array($tree)){
    return false;
  }
  foreach(array_keys($tree) as $uuid){

    if(!isset($tree[$uuid]->filter) && !is_null($filter_default)){
      $tree[$uuid]->filter = $filter_default;
    }

    if( $tree[$uuid]->expanded == 'expanded' && ($expand_excluded || $tree[$uuid]->filter != 'excluded')){
      $children = cdm_taxontree_get_children($uuid, $tree[$uuid]->vid);
      //$children = cdm_ws_get(CDM_WS_TREENODE_CHILDREN, $uuid);
      $children = _cdm_resultset2nodelist($children, ($tree[$uuid]->filter == 'excludes'));

      // store the children of the node for later processing
      if(is_array($tree[$uuid]->children)){
        $pnode_children = $tree[$uuid]->children;
      } else {
        $pnode_children = false;
      }
      // replace the children by the newly retrieved child nodes
      $tree[$uuid]->children = $children;
       
      if($pnode_children){
        // recurse into the childtree which was stored before
        $pnode_children =  cdm_taxontree_populate($pnode_children, $expand_excluded ,$tree[$uuid]->filter);
        // recombine
        foreach($pnode_children as $childUuid=>$cnode){
          $tree[$uuid]->children[$childUuid] = $cnode;
        }
      }
    } else {
      // reorder nodes which are not expanded, expanded nodes are reordered implicitly above
      if(isset($tree[$uuid]->children) && count($tree[$uuid]->children) > 1) {
        // copy the children into an array which can be sorted by its keys
        $ordered = array();
        foreach($tree[$uuid]->children as $cnode){
          // concatenate full name and uid
          $reordered[str_pad($cnode->fullname, 255, '-').$cnode->uuid] = $cnode;
        }
        // sort
        ksort($reordered);
        // move the children back into the parent node
        $tree[$uuid]->children = array();
        foreach($reordered as $cnode){
          $tree[$uuid]->children[$cnode->uuid] = $cnode;
        }
      }
      $tree[$uuid]->children = cdm_taxontree_populate($tree[$uuid]->children, $expand_excluded, $tree[$uuid]->filter);
    }
  }
  return $tree;
}

/**
 * Enter description here...
 *
 * @param unknown_type $tree
 * @param unknown_type $new_root
 * @return unknown
 */
function cdm_taxontree_flatten($tree, &$new_root = null){
  if(!$new_root){
    $new_root = array();
  }
  foreach($tree as $node){
    if($node->filter == 'on'){
      $new_root[$node->uuid] = $node;
    } else if(is_array($node->children)){
      cdm_taxontree_flatten($node->children, $new_root);
    }
  }
  return $new_root;
}


/**
 * Merge a branch into a tree whereas the tree dominated the branch except
 * nodes having property filter set to "on". These always dominate
 * nevertheless if they are in tree or branch.
 *
 * @param unknown_type $tree the dominant tree
 * @param unknown_type $branch the tree to be merged in
 * @return the merged $tree
 */
function _cdm_taxontree_merge($tree, $branch) {

  if(!$branch){
    return $tree;
  }
  
  foreach(array_keys($tree) as $uuid) {
    // check if node exists in $branch
    if(!empty($branch[$uuid])) {
      // preserve filter property
      if(isset($tree[$uuid]->filter) && !(isset($branch[$uuid]->filter) && $branch[$uuid]->filter == 'on') ){
        $branch[$uuid]->filter = $tree[$uuid]->filter;
      } else if(isset($branch[$uuid]->filter)){
        $tree[$uuid]->filter = $branch[$uuid]->filter;
      }
      // preserve expanded property
      if(isset($tree[$uuid]->expanded)){
        $branch[$uuid]->expanded = $tree[$uuid]->expanded;
      } else if(isset($branch[$uuid]->expanded)){
        $tree[$uuid]->expanded = $branch[$uuid]->expanded;
      }
      // $Uuid exists check if the node in tree1 or tree2 contains children
      if(is_array($branch[$uuid]->children) && is_array($tree[$uuid]->children)) {
        // merge recursive
        $tree[$uuid]->children = _cdm_taxontree_merge($tree[$uuid]->children, $branch[$uuid]->children);
      } else if(is_array($branch[$uuid]->children)){
        $tree[$uuid] =  $branch[$uuid];
      }
      unset($branch[$uuid]);
    }
  }
  // append remaining items from branch to tree
  foreach(array_keys($branch) as $uuid){
    $tree[$uuid] =  $branch[$uuid];
  }
  return $tree;
}


/**
 * Replaces the keys of an array of TreeNode instances
 * by the $treeNode->uuid of the single array elements.
 * An sets additional fields
 *
 * @param $resultset array of TreeNode instances as +returned by the cdm web service
 * @param $excluded  whether the $resultset is included by a active filter. Is ignored if NULL.
 * @param $expanded  whether the children of the nodes in the $resultset are expanded or not. Is ignored if NULL.
 */
function _cdm_resultset2nodelist($resultset, $excluded = null, $expanded = null){

  if(! is_array($resultset)) {
    return false;
  }

  $tree = array();
  foreach($resultset as $treeNode){
    if(!is_null($excluded)){
      $treeNode->filter = ($excluded ? 'excluded': 'included');
    }
    if(!is_null($expanded)){
      $treeNode->expanded = ($expanded ? 'expanded': 'collapsed');
    }
    $tree[$treeNode->uuid] = $treeNode;
  }
  return $tree;
}


// ------------------------ THEME --------------------------- //


function theme_cdm_taxontree_add_scripts(){
  $path_cdm_taxontree = drupal_get_path('module', 'cdm_taxontree');
  $path_preferred_module = drupal_get_path('module', 'cdm_dataportal') ? drupal_get_path('module', 'cdm_dataportal') : $path_cdm_taxontree;
  drupal_add_css($path_cdm_taxontree.'/cdm_taxontree.css');
  drupal_add_js($path_preferred_module.'/js/jquery.dimensions.js');
  drupal_add_js($path_cdm_taxontree.'/js/cdm_taxontree.js');
  drupal_add_js($path_cdm_taxontree.'/js/jquery.scrollTo.js');
}

/**
 * @param $tree 				the tree of TreeNode to be displayed
 * @param $magicbox 			if true, the tree will be embedded into a set of div tags which allow the
 *            					tree to expand and overlap other content. This is useful if the node titles are
 *            					quite long or if the tree is nested deeply.
 *            					If $magicbox ist set to the delta of the containing block the direction into which the
 *            					box expands is dependent on the region in which the blockis located.
 *            					See also Variable $left_expand_region in this function!
 * @param $show_filter_switch 	The tree can offer buttons to add a node to a set of filters
 *            					which can then be applied to the tree to limit the visible subtrees and thus
 *            					to compact the tree. Three different compact modes are available.
 * @param $tree_node_callback 	name of a callback method which will be called for each node
 *            					in theme_cdm_taxontree_node(). The output of this callback, which takes the
 *            					$node object as single arument, is appended to the end of the redered node.
 */
function theme_cdm_taxontree_block($tree, $magicbox = false, $show_filter_switch = false, $tree_node_callback = false){

   // THEMERS: change the line below according the specific regions of your theme
   $left_expand_region = 'right';
  
  $out = '';
  if(cdm_taxontree_filters_active()){
    $out .= theme('cdm_taxontree_contoller', _get_compact_mode());
  }
  if($magicbox){
    if(is_numeric($magicbox) || is_string($magicbox)){
      $region = _get_block_region($magicbox);
    }
    // the magicbox expands to the right by default,
    // if the class 'expand-left' to  the cdm_taxontree_scroller_x the box will expand to the left
    $expand_direction = $region == 'right' ? 'expand-left' : '';
    $out .= '<div class="cdm_taxontree_scroller_x '.$expand_direction.'"><div class="cdm_taxontree_container"><div class="cdm_taxontree_scroller_y">';
  }
  
  $out .= theme('cdm_taxontree', $tree, !cdm_taxontree_filters_active(), $show_filter_switch , $tree_node_callback);
  
  if($magicbox){
    $out .= '</div></div></div>';
  }
  return $out;
}

function theme_cdm_taxontree_contoller($compact_mode){

  static $modes = array('expanded', 'compact', 'flattened');

  $out = '<div class="settings">';
  foreach($modes as $mode){
    if($compact_mode == $mode){
      $out .= t($mode);
    } else {
      $out .= l(t($mode), 'cdm_taxontree/set/compact_mode/'.$mode, array(), drupal_get_destination());
    }
    $out .= ' ';
  }

  return $out.'</div>';
}

function theme_cdm_taxontree($tree, $filterIncludes = null, $show_filter_switch = false, $tree_node_callback = false){

  if(!is_array($tree)) {
//    $out = '<ul class="cdm_taxontree">';
//    $out .= '<li>----------------------------NO TREE---------------------------------------</li>';
//    $out .= '</ul>';
//    return $out;
    return false;
  }

  if(is_null($filterIncludes)){
    // set $filterIncludes true if no filters are set.
    $filterIncludes = !cdm_taxontree_filters_active();
  }

  $out = '<ul class="cdm_taxontree">';
  foreach($tree as $node){
    $out .= theme('cdm_taxontree_node', $node, $filterIncludes, $show_filter_switch, $tree_node_callback);
  }
  $out .= '</ul>';
  return $out;
}

function theme_cdm_taxontree_node($node, $filterIncludes, $show_filter_switch = false, $tree_node_callback = false){

  $is_leaf = !$node->hasChildren || $node->hasChildren == 0;
  $is_expanded = isset($node->expanded) && $node->expanded = 'expanded';
  
  if($node->tid){
    $node_name = $node->name;
    $path = "taxonomy/term/".$node->tid;
    // disable filterswitch
    $show_filter_switch = false;
    
  } else {
    $node_name = cdm_dataportal_shortname_of($node);
    $path = cdm_dataportal_taxon_path($node->uuid);
  }

  if($filterIncludes){
    $name = l($node_name, $path);
    $filter_class = 'filter_included';
  } else {
    if($node->filter == 'on') {
      $name = l($node_name,  $path);
      $filter_class = 'filter_on';
    } else {
      $name .= $node_name;
      $filter_class = 'filter_excluded';
    }
  }
  $nextLevelIncluded = $node->filter == 'on' || $filterIncludes;

  $ahah_url = false;
  if(!$is_leaf && !$is_expanded && $filter_class != 'filter_excluded'){
    if($node->tid){
      $ahah_url = url('cdm_taxontree/taxonomy/children/'.$node->tid.'/'.$node->vid.'/cdm_taxontree/'.($nextLevelIncluded ? 1 : 0).'/'.($show_filter_switch ? 1 : 0).'/'.$tree_node_callback);
    } else {
      $ws_url = cdm_compose_url(CDM_WS_TREENODE_CHILDREN, array($node->uuid));
      $ahah_url = url('cdm_api/proxy/'.urlencode($ws_url).'/cdm_taxontree/'.($nextLevelIncluded ? 1 : 0).'/'.($show_filter_switch ? 1 : 0).'/'.$tree_node_callback);
    }
  }

  // list item
  $out = '<li class="'
  .($node->focused ? 'focused ' : '')
  .($is_leaf ? 'leaf ':($is_expanded ?'expanded ':'collapsed '))
  .$filter_class.'"'
  .($ahah_url ? 'title="'.$ahah_url.'"' : '')
  .'>';

  if($show_filter_switch){
    // filter icon
    $out .= theme('cdm_taxontree_node_filter_switch', $node, $filter_class);
  }

  // taxon name
  $out .= $name;

  // concept_switch or other theme callbacks
  if($tree_node_callback){
    $out .= theme($tree_node_callback, $node);
  }

  if($node->children && is_array($node->children)){
    $out .= theme('cdm_taxontree', $node->children, $nextLevelIncluded, $show_filter_switch, $tree_node_callback);
  }
  $out .= '</li>';

  return $out;
}

function theme_cdm_taxontree_node_filter_switch(&$node, $filter_class){
  $out = '';

  switch($filter_class){
    case 'filter_included':
      $filter_icon = 'visible_implicit_small.gif';
      break;
    case 'filter_excluded':
      $filter_icon = 'invisible_small.gif';
      break;
    case 'filter_on':
      $filter_icon = 'visible_small.gif';
      break;
  }

  $filter_op = $node->filter == 'on' ? 'remove' : 'add';

  $out .= '&nbsp;'
  .l('<img src="'.drupal_get_path('module', 'cdm_taxontree').'/'.$filter_icon.'" alt="[f]" />',
    'cdm_taxontree/filter/'.$filter_op.'/'.$node->uuid, array('class'=>'filter_'.$filter_op),
    'destination='.cdm_dataportal_taxon_path($node->uuid),
  null, false, true);
   
  return $out;
}

function theme_cdm_taxontree_node_concept_switch(&$node){
  $out = '';

  if(isset($node->alternativeConceptRefs[0])){
    $out = l(
      '<img src="'.drupal_get_path('module', 'cdm_taxontree').'/concept_switch.gif" alt="[-&gt;]" />',
      'cdm_dataportal/taxon/alternative/'.$node->uuid,
    array('rel'=>'cdm_dataportal/taxon/alternative/'.$node->uuid, 'class'=>'concept_switch'),
    null, null, false, true);
  }
  return $out;
}




// ----------------- FILTERS -------------------------- //

/**
 * filters on children override already set parent filters and vice versa
 *
 * @param STRING $op [add | remove] a taxon from the filtered taxa
 * 					 TODO at the moment there is also a 'list' operation that displays all set filters and provides the ability to delete them.
 * 						  This option depends on function is defined in cdm_dataportal. Problem is, that the dependency is the other way round.
 * @param UUID $taxonUuid
 * @return unknown
 */
function cdm_taxontree_view_filter($op, $taxonUuid = null){
  
  if(!isset($_SESSION['cdm']['filters'])){
    $_SESSION['cdm']['filters'] = array();
  }
  if($taxonUuid || $op == 'list'){
    switch($op){
      case 'add':
        cdm_taxontree_filters_add($taxonUuid);
        break;
      case 'remove':
        cdm_taxontree_filters_remove($taxonUuid);
        break;
      case 'list':
        //TODO put in cdm_dataportal_theme to decouple both modules by this!!!
        $out = '<ul>';
        foreach($_SESSION['cdm']['filters'] as $uuid=>$node){
          $out .= '<li>'.cdm_dataportal_shortname_of($node).' '.l('[x]', 'cdm_dataportal/filter/remove/'.$uuid, array(), drupal_get_destination()).'</li>';
        }
        $out .= '</ul>';
        return $out;
    }
  }
  if($_REQUEST['destination']){
    $destination = $_REQUEST['destination'];
    unset($_REQUEST['destination']);
    drupal_goto($destination);
  }
}

/**
 * Filters are set in cdm_dataportal_view_filter().
 * functions using filters should remove invalid filters
 *
 * @return true if any filter is active
 */
function cdm_taxontree_filters_active(){
 return isset($_SESSION['cdm']['filters']) && count($_SESSION['cdm']['filters']) > 0;
}

/**
 * Filters are set in cdm_dataportal_view_filter().
 *
 * @return a reference on the filters array stored in the SESSION
 */
function &cdm_taxontree_filters_get(){
  if(!isset($_SESSION['cdm']['filters'])){
    $_SESSION['cdm']['filters'] = array();
  }
 return $_SESSION['cdm']['filters'];
}

/**
 * Adds a taxon to the filtered taxa array
 *
 * @param UUID $taxonUuid
 */
function cdm_taxontree_filters_add($taxonUuid){
  $parents = cdm_ws_get(CDM_WS_TREENODE_PARENTS, $taxonUuid);
  
  $parents = array_reverse($parents);
  
  // pop off last element since this is the TreeNode object for $taxonUuid!
  $this_node = array_pop($parents);
  // will contain the uuid of the parent nodes excluding the $taxonUuid node itself
  $parent_uuids = array();
  
  // children override parents rule: remove all parent filters,
  foreach($parents as $pnode){
    unset($_SESSION['cdm']['filters'][$pnode->uuid]);
    $parent_uuids[] = $pnode->uuid;
  }
  
  // search for potential children of this $taxonUuid
  foreach($_SESSION['cdm']['filters'] as $uuid=>$node){
    if(in_array($taxonUuid, $node->parentUuids)){
      unset($_SESSION['cdm']['filters'][$node->uuid]);
    }
  }
  // finally add this $taxonUuid as new filter
  $this_node->parentUuids = $parent_uuids;
  $_SESSION['cdm']['filters'][$taxonUuid] = $this_node;
}

/**
 * Unsets a taxon from the filtered taxa array
 *
 * @param UUID $taxonUuid
 */
function cdm_taxontree_filters_remove($taxonUuid){
  unset($_SESSION['cdm']['filters'][$taxonUuid]);
}


// ------------------------ PRIVATE --------------------------- //

/**
 * Analyses the current Drupal path.
 * If a certain taxon was requested in the request, returns the UUID of that taxon.
 * A stored UUID if no taxon was requested.
 * TODO where does the dtored UUID come from?
 *
 * @return UUID
 */
function _cdm_get_taxonuuid(){

  //TODO make the path configurable
  if (arg(0)=="cdm_dataportal" && arg(1)=="taxon" && arg(2)!==0){
    $taxon_uuid = arg(2);
  } else {
    $taxon_uuid = $_SESSION['cdm_dataportal']['tree']['taxon_uuid'];
  }

  return $taxon_uuid;
}

/**
 * Converts a UUID into a hexadecimal RGB colour code.
 *
 * @param UUID $uuid
 * @return Number hexadecimal
 */
function _uuid_to_rgbhex($uuid){

  $xfoot = _str_crossfoot($uuid);
  $h = $xfoot / 255;
  $h = $h - floor($h);
  $RGB = _hsv_2_rgb($h, 0.45, 1);
  return dechex($RGB['R']).dechex($RGB['G']).dechex($RGB['B']);
}

/**
 * Sums up ASCII values of the character in the given string.
 *
 * @param String $str
 * @return Number
 */
function _str_crossfoot($str){
  $xfoot = 0;
  for($i=0; $i<strlen($str); $i++){
    $xfoot = $xfoot + ord($str[$i]);
  }
  return $xfoot;
}

/**
 * Converts HSV colour codes into their RGB counterpart
 *
 * @param Number $H value 0-1
 * @param Number $S value 0-1
 * @param Number $V value 0-1
 * @return array three values  0-255
 */
function _hsv_2_rgb($H, $S, $V) // HSV Values:Number 0-1
{ //
  $RGB = array();
  
  if($S == 0){
    $R = $G = $B = $V * 255;
  } else {
    $var_H = $H * 6;
    $var_i = floor( $var_H );
    $var_1 = $V * ( 1 - $S );
    $var_2 = $V * ( 1 - $S * ( $var_H - $var_i ) );
    $var_3 = $V * ( 1 - $S * (1 - ( $var_H - $var_i ) ) );
  
    if ($var_i == 0) { $var_R = $V ; $var_G = $var_3 ; $var_B = $var_1 ; }
    else if ($var_i == 1) { $var_R = $var_2 ; $var_G = $V ; $var_B = $var_1 ; }
    else if ($var_i == 2) { $var_R = $var_1 ; $var_G = $V ; $var_B = $var_3 ; }
    else if ($var_i == 3) { $var_R = $var_1 ; $var_G = $var_2 ; $var_B = $V ; }
    else if ($var_i == 4) { $var_R = $var_3 ; $var_G = $var_1 ; $var_B = $V ; }
    else { $var_R = $V ; $var_G = $var_1 ; $var_B = $var_2 ; }
  
    $R = $var_R * 255;
    $G = $var_G * 255;
    $B = $var_B * 255;
  }
  
  $RGB['R'] = $R;
  $RGB['G'] = $G;
  $RGB['B'] = $B;
  
  return $RGB;
}