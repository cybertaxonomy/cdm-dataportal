<?php
// $Id$

/*
 * @file
 * cdm_taxontree.module
 *
 * Copyright (C) 2007 EDIT
 * European Distributed Institute of Taxonomy
 * http://www.e-taxonomy.eu
 *
 * The contents of this file are subject to the Mozilla Public License Version 1.1
 * See LICENSE.TXT at the top of this package for the full license terms.
 */


/**
 * Implementation of hook_menu()
 */
function cdm_taxontree_menu($may_cache) {
  
  $items = array();
  if ($may_cache) {

    $items[] = array(
      'path' => 'cdm_taxontree/set',
      'callback' => 'cdm_taxontree_set',
      'access' => true,
      'type' => MENU_CALLBACK, 
    );

  }
  return $items;
}


/**
 * Implementation of hook_block()
 *
 * @param String $op
 * @param int $delta
 */
function cdm_taxontree_block($op='list', $delta=0) {
  if ($op == "list") {
    $block[0]["info"] = t('CDM Taxon Tree');
    return $block;
  }
  else if ($op == 'view') {
    switch($delta){
      case 0:
        $block['subject'] = t('CDM Taxon Tree');
        $taxonUuid_inFocus = _cdm_get_taxonuuid();
        $tree = cdm_taxontree_build_tree($taxonUuid_inFocus);
        $block['content'] = theme('cdm_taxontree_block', $tree);
        drupal_add_css(drupal_get_path('module', 'cdm_taxontree').'/cdm_taxontree.css');
        drupal_add_js(drupal_get_path('module', 'cdm_taxontree').'/cdm_taxontree.js');
        return $block;
    }
  }
}

function cdm_taxontree_set($key, $value){
  
  if(is_string($key)){
    $_SESSION['cdm']['taxontree'][$key] = $value; 
  }
  
  if($_REQUEST['destination']){
    $destination = $_REQUEST['destination'];
    unset($_REQUEST['destination']);
    drupal_goto($destination);
  }
}

function _is_compact_mode(){
  return isset($_SESSION['cdm']['taxontree']['compact']) && $_SESSION['cdm']['taxontree']['compact'];
}

/**
 * builds a tree of TaxonNode instances, whereas the instances are extended by some fields:
 * 
 *  - $node->filter: values ( 'on', 'excluded', 'included' ) 
 *  - $node->expanded: values ( 'expanded', 'collapsed' ) 
 *    $node->focused: values ( TRUE, FALSE ) 
 *
 * @param unknown_type $taxonUuid
 * @return unknown
 */
function cdm_taxontree_build_tree($taxonUuid){

  // find the secRefUuid
  $secRefUuid = null;
  if($taxonUuid){
    //TODO poor performance here:
    $taxon =  cdm_ws_get(CDM_WS_TAXON, $taxonUuid);
    $secRefUuid = $taxon->sec->uuid;
  }

  if(!$secRefUuid){
    $secRef = _cdm_dataportal_currentSecRef_array();
    $secRefUuid = $secRef['uuid'];
  }

  $compact_tree = (cdm_dataportal_filters_active() && _is_compact_mode() ? 'hidden' : false);
  
  // get the root level
  $root_tree = cdm_ws_get(CDM_WS_TREENODE_ROOT, $secRefUuid);
  $root_tree = _cdm_resultset2nodelist($root_tree, cdm_dataportal_filters_active());

  if(cdm_dataportal_filters_active()){
    // the paths up to active filters are inactive in the user interface and
    // thus cannot be browsed by expanding nodes
    // therefore we need to build up the branches for all nodes which are set as filters
    // the branches are merged with the root
    foreach(cdm_dataportal_filters_get() as $uuid=>$filter){
      $branch = cdm_taxontree_build_path($uuid, TRUE, $compact_tree === false);
      $root_tree = _cdm_taxontree_merge($root_tree, $branch);
    }
  }
  
  // build the the branch for the focused node and merge it with the root
  if($taxonUuid){
    $branch = cdm_taxontree_build_path($taxonUuid, NULL, (cdm_dataportal_filters_active() ? NULL : TRUE), TRUE);
    $root_tree = _cdm_taxontree_merge($root_tree, $branch);
  }
  
  //reorder siblings & populate expanded nodes with children and propagate the filter attribute
  $root_tree = cdm_taxontree_populate($root_tree);
  
  // flatten tree 
  /*
  if($compact_tree == 'flat'){
    $root_tree = cdm_taxontree_flatten($root_tree);
  }
  */
  
  return $root_tree;
}

/**
 * Builds the specific branch path for $taxonUuid. 
 * The branch path reaches from the parent root node of $taxonUuid up to $taxonUuid.
 *
 * @param unknown_type $taxonUuid
 * @param $is_filter_path whether the upmost node of this path is mapped by an active filter 
 * @param $is_expanded whether all nodes along the tree are expanded 
 * @return a subtree
 */
function cdm_taxontree_build_path($taxonUuid, $is_filter_path = null, $is_expanded = null, $is_focused = FALSE){
  
  $branch_path = array();
  $parents = cdm_ws_get(CDM_WS_TREENODE_PARENTS, $taxonUuid);
  //TODO improve performance by changing the web service and thus making the next line below obsolete:
  $parents = array_reverse($parents);
  $parents = _cdm_resultset2nodelist($parents, NULL);
  $lastParent = null;
  foreach($parents as $pnode){
    $pnode->focused = false;
    if($lastParent){
      $pnode->children = array($lastParent->uuid => $lastParent);
      if(!is_null($is_filter_path)){
        $pnode->filter = ($is_filter_path ? 'excludes' : 'included');
      }
      if(!is_null($is_expanded)){
        $pnode->expanded = ($is_expanded ? 'expanded' : 'collapsed');
      }
    } else {
      // the uppermost node of branch
      if(!is_null($is_filter_path)){
        $pnode->filter = ($is_filter_path ? 'on' : 'includes');
      }
      // uppermost node is always expanded if it has children
      $pnode->focused = $is_focused;
      $pnode->expanded = ($pnode->hasChildren ? 'expanded' : 'collapsed');
    }
    $lastParent = $pnode;
  }
  $branch_path[$pnode->uuid] = $pnode;
  return $branch_path;
}

/**
 * Performs two steps on each level of the tree:
 *  1. reorder siblings except root (is expected to be ordered jet) alphabetically 
 *  2. populate children of expanded nodes  & propagate the filter attribute
 *
 * @param unknown_type $tree
 * @return unknown
 */
function cdm_taxontree_populate($tree, $filter_default = null){
  
  foreach(array_keys($tree) as $uuid){
    
    if(!isset($tree[$uuid]->filter) && !is_null($filter_default)){
      $tree[$uuid]->filter = $filter_default;
    }
    
    if( $tree[$uuid]->expanded == 'expanded' && $tree[$uuid]->filter != 'excluded'){
       $children = cdm_ws_get(CDM_WS_TREENODE_CHILDREN, $uuid);
       $children = _cdm_resultset2nodelist($children, ($tree[$uuid]->filter == 'excludes'));

       // store the children of the node for later processing
       if(isset($tree[$uuid]->children)){
         $pnode_children = $tree[$uuid]->children;
       } else {
         $pnode_children = false;
       }
       // replace the children by the newly retrieved child nodes
       $tree[$uuid]->children = $children;
       
       if($pnode_children){         
         // recurse into the childtree which was stored before
         $pnode_children =  cdm_taxontree_populate($pnode_children, $tree[$uuid]->filter);
         // recombine
         foreach($pnode_children as $childUuid=>$cnode){
           $tree[$uuid]->children[$childUuid] = $cnode;
         }
       }
    } else {
      // reorder nodes which are not expanded, expanded nodes are reordered implicitly above
      if(isset($tree[$uuid]->children) && count($tree[$uuid]->children) > 1) {
       // copy the children into an array which can be sorted by its keys
       $ordered = array();
       foreach($tree[$uuid]->children as $cnode){
         // concatenate full name and uid
         $reordered[str_pad($cnode->fullname, 255, '-').$cnode->uuid] = $cnode;
       }
       // sort
       ksort($reordered);
       // move the children back into the parent node
       $tree[$uuid]->children = array();
       foreach($reordered as $cnode){
         $tree[$uuid]->children[$cnode->uuid] = $cnode;
       }
      }
     $tree[$uuid]->children =  cdm_taxontree_populate($tree[$uuid]->children, $tree[$uuid]->filter);
    }
  }
  return $tree;
}

/**
 * Merge a branch into a root tree
 *
 * @param unknown_type $tree
 * @param unknown_type $branch
 * @return the merged $tree
 */
function _cdm_taxontree_merge($tree, $branch) {
      
    foreach(array_keys($tree) as $uuid) {       
        // check if node exists in $branch
        if(!empty($branch[$uuid])) {
            if(isset($tree[$uuid]->filter)){
               $branch[$uuid]->filter = $tree[$uuid]->filter;
            }
            if(isset($tree[$uuid]->expanded)){
               $branch[$uuid]->expanded = $tree[$uuid]->expanded;
            }
            // $Uuid exists check if the node in tree1 or tree2 contains children
            if(is_array($branch[$uuid]->children) && is_array($tree[$uuid]->children)) {
              // merge recursive
              $tree[$uuid]->children = _cdm_taxontree_merge($tree[$uuid]->children, $branch[$uuid]->children);
            } else if(is_array($branch[$uuid]->children)){
              $tree[$uuid] =  $branch[$uuid];
            }  
            unset($branch[$uuid]);
        } 
    }
    // append remaining items from branch to tree
    foreach(array_keys($branch) as $uuid){
      $tree[$uuid] =  $branch[$uuid];
    }
    return $tree;
}

function theme_cdm_taxontree_block($tree){
    
  $out = '';
  if(cdm_dataportal_filters_active()){
        $out = '<div class="settings">'.l((_is_compact_mode()? t('expand tree'):t('compact tree')), 'cdm_taxontree/set/compact/'.(_is_compact_mode() ? 0:1), array(), drupal_get_destination()).'</div>';
  }
  $out .= theme('cdm_taxontree', $tree, !cdm_dataportal_filters_active());
  return $out;
}

function theme_cdm_taxontree($tree, $filterIncludes = null){
  
  if(!is_array($tree)) {
    return false;
  }
 
  if(is_null($filterIncludes)){
    // set $filterIncludes true if no filters are set.
    $filterIncludes = !cdm_dataportal_filters_active();
  }
  
  $out = '<ul class="cdm_taxontree">';
  foreach($tree as $node){
    $out .= theme('cdm_taxontree_node', $node, $filterIncludes);
  }
  $out .= '</ul>';
  return $out;
}

function theme_cdm_taxontree_node($node, $filterIncludes){
  //TODO clean up function
  $is_leaf = !$node->hasChildren || $node->hasChildren == 0;
  
  $is_expanded = isset($node->expanded) && $node->expanded = 'expanded';


  if($filterIncludes){
    $name = l(cdm_dataportal_shortname_of($node), cdm_dataportal_taxon_path($node->uuid));
    $filter_icon = 'visible_implicit_small.gif';
    $filter_class = 'filter_included';
  } else {
     if($node->filter == 'on') {
      $name = l(cdm_dataportal_shortname_of($node), cdm_dataportal_taxon_path($node->uuid));
      $filter_icon = 'visible_small.gif';
      $filter_class = 'filter_on';
    } else {
      $filter_icon = 'invisible_small.gif';
      $name .= cdm_dataportal_shortname_of($node);
      $filter_class = 'filter_excluded';
    }
  }
  $nextLevelIncluded = $node->filter == 'on' || $filterIncludes;

  $cdm_proxy_url = false;
  if(!$is_leaf && !$is_expanded && $filter_class != 'filter_excluded'){
    $ws_url = cdm_compose_url(CDM_WS_TREENODE_CHILDREN, array($node->uuid));
    $cdm_proxy_url = url('cdm_api/proxy/'.urlencode($ws_url).'/cdm_taxontree/'.($nextLevelIncluded ? 1 : 0));
  }

  $filter_op = $node->filter == 'on' ? 'remove' : 'add';
  
  // list item
  $out = '<li class="'
  .($node->focused ? 'focused ' : '')
  .($is_leaf ? 'leaf ':($is_expanded ?'expanded ':'collapsed '))
  .$filter_class.'"'
  .($cdm_proxy_url ? 'title="'.$cdm_proxy_url.'"' : '')
  .'>';
  
  // filter icon 
  $out .= '&nbsp;'
     .l('<img src="'.drupal_get_path('module', 'cdm_taxontree').'/'.$filter_icon.'" alt="[f]" />', 
    'cdm_dataportal/filter/'.$filter_op.'/'.$node->uuid, array('class'=>'filter_'.$filter_op), 
    'destination='.cdm_dataportal_taxon_path($node->uuid), 
     null, false, true);
  
  // taxon name
  $out .= $name;
  
  // concept_switch
  if(isset($node->alternativeConceptRefs[0])){
    $out .= l(
      '<img src="'.drupal_get_path('module', 'cdm_taxontree').'/concept_switch.gif" alt="[-&gt;]" />', 
      'cdm_dataportal/taxon/alternative/'.$node->uuid, 
      array('rel'=>'cdm_dataportal/taxon/alternative/'.$node->uuid, 'class'=>'concept_switch'), 
      null, null, false, true);
  }
  
  if(isset($node->children) && is_array($node->children)){
      $out .= theme('cdm_taxontree', $node->children, $nextLevelIncluded);
  }
  $out .= '</li>';
  
  return $out;
}

/**
 * Replaces the keys of an array of TreeNode instances
 * by the $treeNode->uuid of the single array elements.
 * An sets additional fields
 *
 * @param $resultset array of TreeNode instances as +returned by the cdm web service
 * @param $excluded  whether the $resultset is included by a active filter. Is ignored if NULL.
 * @param $expanded  whether the children of the nodes in the $resultset are expanded or not. Is ignored if NULL.
 */
function _cdm_resultset2nodelist($resultset, $excluded = null, $expanded = null){

  if(! is_array($resultset)) {
    return false;
  }

  $tree = array();
  foreach($resultset as $treeNode){
    if(!is_null($excluded)){
      $treeNode->filter = ($excluded ? 'excluded': 'included');   
    }
   if(!is_null($expanded)){
      $treeNode->expanded = ($expanded ? 'expanded': 'collapsed');   
    }
    $tree[$treeNode->uuid] = $treeNode;
  }
  return $tree;
}


function _cdm_get_taxonuuid(){

  //TODO make the path configurable
  if (arg(0)=="cdm_dataportal" && arg(1)=="taxon" && arg(2)!==0){
    $taxon_uuid = arg(2);
  } else {
    $taxon_uuid = $_SESSION['cdm_dataportal']['tree']['taxon_uuid'];
  }

  return $taxon_uuid;
}