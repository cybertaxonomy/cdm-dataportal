<?php
/**
 * @file
 * Taxon Theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_acceptedFor($variables) {
  $accepted_for_uuid = $variables['acceptedFor'];

  if(!is_uuid($accepted_for_uuid)){
    return '';
  }

  RenderHints::pushToRenderStack('acceptedFor');
  $out = '';

  $synonym = cdm_ws_get(CDM_WS_PORTAL_TAXON, $accepted_for_uuid);
  if ($synonym) {
    $out .= '<span class="acceptedFor">';
    $out .= t('is accepted for ');
    if (isset($synonym->name->nomenclaturalReference)) {
      $referenceUri = url(path_to_reference($synonym->name->nomenclaturalReference->uuid));
    }
    $out .= render_taxon_or_name($synonym->name, NULL, $referenceUri);
    $out .= theme('cdm_annotations_as_footnotekeys', array('cdmBase_list' => $synonym));
    $out .= '</span>';
  }
  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * @todo document this function.
 */
function theme_cdm_list_of_taxa($variables) {

  $unclassified_snippet = '<span class="unclassified">' . t('unclassified') . '</span>';

  $records = $variables['records'];
  $freetextSearchResults = $variables['freetextSearchResults'];
  $show_classification = $variables['show_classification'];

  RenderHints::pushToRenderStack('list_of_taxa');

  $form_name = 'search_gallery';
  // $default_values = unserialize(CDM_DATAPORTAL_GALLERY_SETTINGS);
  // $gallery_settings = variable_get($form_name, $default_values);
  $gallery_settings = getGallerySettings(CDM_DATAPORTAL_SEARCH_GALLERY_NAME);

  $showMedia_taxa = $gallery_settings['cdm_dataportal_show_taxon_thumbnails'];
  $showMedia_synonyms = $gallery_settings['cdm_dataportal_show_synonym_thumbnails'];
  // $showMedia_taxa =
  // variable_get('cdm_dataportal_findtaxa_show_taxon_thumbnails', 1);
  // $showMedia_synonyms =
  // variable_get('cdm_dataportal_findtaxa_show_synonym_thumbnails', 0);
  $searched_in_classification = cdm_dataportal_searched_in_classification();
  $searched_in_classification_uuid = null;
  if(isset($searched_in_classification->uuid)){
    $searched_in_classification_uuid = $searched_in_classification->uuid;
  }

  // .. Well, for sure not as performant as before, but better than nothing.
  $synonym_uuids = array();
  $misappied_uuids = array();
  foreach ($records as $taxon) {
    if ($taxon->class == "Synonym") {
      if (!array_key_exists($taxon->uuid, $synonym_uuids)) {
        $synonym_uuids[$taxon->uuid] = $taxon->uuid;
      }
    }
    elseif (!_cdm_dataportal_acceptedByCurrentView($taxon)) {
      // Assuming that it is a misappied name, will be further examined below.
      $misappied_uuids[$taxon->uuid] = $taxon->uuid;
    }
  }

  // Batch service not jet implemented:
  // $table_of_accepted = cdm_ws_property(CDM_WS_PORTAL_TAXON_ACCEPTED,
  // join(',', $synonym_uuids));
  // thus ...
  $table_of_accepted = array();

  foreach ($synonym_uuids as $relatedUuid) {
    $table_of_accepted[$relatedUuid] = cdm_ws_get(CDM_WS_PORTAL_TAXON_ACCEPTED, array(
      $relatedUuid,
      $searched_in_classification_uuid,
    ));
  }

  foreach ($misappied_uuids as $relatedUuid) {
    $taxonRelations = cdm_ws_get(CDM_WS_PORTAL_TAXON_RELATIONS, array(
      $relatedUuid,
    ));
    foreach ($taxonRelations as $relation) {
      if ($relation->type->uuid == UUID_MISAPPLIED_NAME_FOR && _cdm_dataportal_acceptedByCurrentView($relation->toTaxon)) {
        $table_of_accepted[$relatedUuid][] = $relation->toTaxon;
      }
    }
  }

  $out = '<ul class="cdm_names" style="background-image: none;">';
  $itemCnt = -1;
  foreach ($records as $taxon) {
    $itemCnt++;
    if (isset($table_of_accepted[$taxon->uuid])) {
      // Its a synonym or misapplied name.
      $is_synonym = isset($synonym_uuids[$taxon->uuid]); //TODO better use the $taxon->class attribute?
      $taxon_type = $is_synonym ? "Synonym" : "misapplied-name";

      $acceptedTaxa = $table_of_accepted[$taxon->uuid];

      if (count($acceptedTaxa) == 1) {

        $acceptedTaxon = $acceptedTaxa[0];
        $taxonUri = uri_to_synonym($taxon->uuid, $acceptedTaxon->uuid, 'synonymy');
        $referenceUri = '';
        if (isset($acceptedTaxon->name->nomenclaturalReference)) {
          $referenceUri = url(path_to_reference($acceptedTaxon->name->nomenclaturalReference->uuid));
        }
        $taxon_or_name = $is_synonym ? $taxon->name : $taxon;
        // $taxon_or_name this is a trick to suppress the sec reference for sysnonyms
        // supplying the name will cause render_taxon_or_name() to not show the sec reference
        $out .= '<li class="' . $taxon_type . '">' . render_taxon_or_name($taxon_or_name, $taxonUri, $referenceUri);
        if ($show_classification) {
          $classifications = get_classifications_for_taxon($taxon);
          $classification_titles = array();
          foreach ($classifications as $classification) {
            if (isset($classification->titleCache)) {
              $classification_titles[] = $classification->titleCache;
            }
          }
          if(count($classification_titles) == 0){
            $classification_titles[] = $unclassified_snippet;
          }
          $out .= ' : <span class="classifications">' . implode(', ', $classification_titles) . '</span>';
        }
        $out .= theme('cdm_annotations_as_footnotekeys', array('cdmBase_list' => $taxon));
        if ($showMedia_synonyms) {
          $out .= theme('cdm_taxon_list_thumbnails', array('taxon' => $acceptedTaxon));
        }
      }
      else {

        // TODO avoid using Ajax in the cdm_dynabox .... why?
        // TODO add media.
        $out .= cdm_dynabox(
          $taxon->uuid,
          render_taxon_or_name($taxon->name, NULL, NULL, FALSE),
          cdm_compose_url(CDM_WS_PORTAL_TAXON_ACCEPTED,
            array(
              $taxon->uuid,
              $searched_in_classification_uuid
            )
          ),
          'cdm_list_of_taxa',
          'show accepted taxa of this ' . $taxon_type,
          array('li', 'ul'),
          array('class' => array($taxon_type))
         );
      }
    }
    else {
      // Its a Taxon.
      $taxonUri = url(path_to_taxon($taxon->uuid));
      $referenceUri = '';
      if (isset($taxon->name->nomenclaturalReference)) {
        $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
      }
      $out .= '<li class="Taxon">' . render_taxon_or_name($taxon, $taxonUri, $referenceUri);
      if ($show_classification) {
        $classifications = get_classifications_for_taxon($taxon);
        $classification_titles = array();
        foreach ($classifications as $classification) {
          if (isset($classification->titleCache)) {
            $classification_titles[] = $classification->titleCache;
          }
        }
        if(count($classification_titles) == 0){
          $classification_titles[] = $unclassified_snippet;
        }
        $out .= ' : <span class="classifications">' . implode(', ', $classification_titles) . '</span>';
      }
      $out .= theme('cdm_annotations_as_footnotekeys', array('cdmBase_list' => $taxon));

      if ($showMedia_taxa) {
        $out .= theme('cdm_taxon_list_thumbnails', array('taxon' => $taxon));
      }
    }

    /*
     * the score field will be empty in case of MultiTermQueries like
     * WildcardQueries, since these are  constant score by default
     * since Lucene 2.9
     */
    if(isset($freetextSearchResults[$itemCnt]) && $freetextSearchResults[$itemCnt]->score && $freetextSearchResults[$itemCnt]->maxScore){
      $percentage =  ( $freetextSearchResults[$itemCnt]->score / $freetextSearchResults[$itemCnt]->maxScore ) * 100;
      $out .= '<div class="score-bar"><div class="score-bar-indicator" style="width:' . $percentage .'% "></div></div>';
      $out .= '<div class="score-bar-value">' . number_format($percentage, 2) .'%</div>';
    }

    // Render highlighted fragments, these are made available by free text
    // searches.
    if (isset($freetextSearchResults[$itemCnt]->fieldHighlightMap)) {
      $field_fragments = (array) $freetextSearchResults[$itemCnt]->fieldHighlightMap;
      if (count($field_fragments) > 0) {
        $fragments_out = '';
        foreach ($field_fragments as $fieldName => $fragments) {
          $fragments_out .= '... <span class="' . $fieldName. '">' . filter_xss(join(" ... ", $fragments), array('b') ) . '</span>';
        }
        $out .= '<div class="fragment_highlight">' . $fragments_out . ' ...</div>';
      }
    }

    $out .= '</li>';
  }

  $out .= '</ul>';
  RenderHints::popFromRenderStack();

  return $out;
}

  /**
 * @todo document this function.
 */
function theme_cdm_taxon_list_thumbnails($variables) {

  $taxon = $variables['taxon'];
  $out = '';
  $gallery_settings = getGallerySettings(CDM_DATAPORTAL_SEARCH_GALLERY_NAME);
  $showCaption = $gallery_settings['cdm_dataportal_show_thumbnail_captions'];
  if ($showCaption) {
    $captionElements = array(
      'title',
      'rights',
    );
  } else {
    $captionElements = array();
  }

  $gallery_name = $taxon->uuid;

  $mediaList = _load_media_for_taxon($taxon);

  $galleryLinkUri = path_to_taxon($taxon->uuid, 'images');

  $out .= theme('cdm_media_gallerie', array(
    'mediaList' => $mediaList,
    'galleryName' => $gallery_name,
    'maxExtend' => $gallery_settings['cdm_dataportal_media_maxextend'],
    'cols' => $gallery_settings['cdm_dataportal_media_cols'],
    'maxRows' => $gallery_settings['cdm_dataportal_media_maxRows'],
    'captionElements' => $captionElements,
    'mediaLinkType' => 'LIGHTBOX',
    'alternativeMediaUri' => NULL,
    'galleryLinkUri' => $galleryLinkUri,
     ));

  return $out;
}
