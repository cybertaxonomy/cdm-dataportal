<?php
/**
 * @file
 * Taxon Theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */

/**
 * Returns HTML for misapplied names and invalid designations.
 *
 * Both relation types are currently treated the same!
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxonRelationships
 *   - focusedTaxon
 *
 * @ingroup themeable
 *
 * @return string
 *    the rendered html
 */
function theme_cdm_taxonRelationships($variables) {
  $taxonRelationships = $variables['taxonRelationships'];
  $focusedTaxon = $variables['focusedTaxon'];
  if (!$taxonRelationships) {
    return null;
  }

  RenderHints::pushToRenderStack('taxonRelationships');
  $footnoteListKey = 'taxonRelationships';
  RenderHints::setFootnoteListKey($footnoteListKey);

  $misapplied = array();
  $joinedAuthorTeams = array();

  $taxon_relationship_types = variable_get(CDM_TAXON_RELATIONSHIP_TYPES, unserialize(CDM_TAXON_RELATIONSHIP_TYPES_DEFAULT));

  // Aggregate misapplied names having the same fullname:
  foreach ($taxonRelationships as $taxonRelation) {

    if (in_array($taxonRelation->type->uuid, $taxon_relationship_types)) {

      if ($taxonRelation->type->uuid == UUID_MISAPPLIED_NAME_FOR || $taxonRelation->type->uuid == UUID_INVALID_DESIGNATION_FOR) {

        $name = $taxonRelation->fromTaxon->name->titleCache;

        $authorteam = cdm_ws_get(CDM_WS_REFERENCE_AUTHORTEAM, $taxonRelation->fromTaxon->sec->uuid);
        $authorteam = $authorteam->titleCache;

        if (!isset($misapplied[$name])) {
          // Render the first name found as representative for all others.
          $misapplied[$name]['out'] = cdm_related_taxon($taxonRelation->fromTaxon, UUID_MISAPPLIED_NAME_FOR);
        }
        else {
          // We need to add the anchors for all of the other mispplied names not
          // being rendered explicitly.
          $misapplied[$name]['out'] = uuid_anchor($taxonRelation->fromTaxon->uuid, $misapplied[$name]['out']);
        }

        // Collect all authors for this fullname.
        if (isset($authorteam)) {
          $misapplied[$name]['authorteam'][$authorteam] = '';
          $joinedAuthorTeams[$authorteam] = 'sensu ' . theme('cdm_reference', array('reference' => $taxonRelation->fromTaxon->sec));
        }
      }
      else {
        // All relationsship types but misapplied_name_for
        // invalid_designation_for.
        $taxon_relationships_lines[] = cdm_taxonRelationship($taxonRelation, TRUE, _is_invers_taxonRelationship($taxonRelation, $focusedTaxon));
      }
    }
  }

  // Sort the joinedAuthorTeams and create footnotes and footnotekeys.
  ksort($joinedAuthorTeams);
  foreach ($joinedAuthorTeams as $authorteam => $sensuCitation) {
    $footnoteKey = FootnoteManager::addNewFootnote($footnoteListKey, $sensuCitation);
    $joinedAuthorTeams[$authorteam] = '<span class="sensu">sensu '
      . $authorteam
      . theme('cdm_footnote_key', array('footnoteKey' => $footnoteKey))
      . '</span>';
  }

  // ---- Generate output ---- //

  $out = '<div class="taxon-relationships">';
  if (is_array($misapplied) && count($misapplied) > 0) {
    $out .= '<ul class="misapplied">';
    foreach ($misapplied as $misapplied_name) {

      $out .= '<li class="synonym"><span class="misapplied">' . $misapplied_name['out'] . ' </span>';

      if (isset($misapplied_name['authorteam'])) {
        // Fill authors with the renderedFootnoteKey and sorting 'em.
        foreach ($misapplied_name['authorteam'] as $authorteam => &$renderedFootnoteKey) {
          $renderedFootnoteKey = $joinedAuthorTeams[$authorteam];
        }
        ksort($misapplied_name['authorteam']);
        $out .= join('; ', $misapplied_name['authorteam']);
      }
      $out .= '</li>';
    }
    $out .= '</ul>';
  }

  if (isset($taxon_relationships_lines) && is_array($taxon_relationships_lines) && count($taxon_relationships_lines) > 0) {
    $out .= '<ul class="taxonRelationships">';
    foreach ($taxon_relationships_lines as $taxon_relationship_line) {
      $out .= '<li class="synonym">' . $taxon_relationship_line . '</li>';
    }
    $out .= '</ul>';
  }

  $footnotes = theme('cdm_footnotes', array('footnoteListKey' => $footnoteListKey, 'enclosingTag' => 'li'));
  $footnotes .= theme('cdm_annotation_footnotes', array('footnoteListKey' => $footnoteListKey, 'enclosingTag' => 'li'));

// AK: why splitting footnotes at the sennsu string ??? this is weired and hacky
//     TODO remove below dead code
//   $tr_footnotes_exploded = explode('sensu', $tr_footnotes);
//   $tr_footnotes_aux = '';
//   foreach ($tr_footnotes_exploded as $element) {
//     $tr_footnotes_aux .= $element;
//   }

  $out .= '<ul class="footnotes">' . $footnotes . '</ul>';

  $out .= '</div>';

  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_acceptedFor($variables) {
  $accepted_for_uuid = $variables['acceptedFor'];

  if(!is_uuid($accepted_for_uuid)){
    return '';
  }

  RenderHints::pushToRenderStack('acceptedFor');
  $out = '';

  $synonym = cdm_ws_get(CDM_WS_PORTAL_TAXON, $accepted_for_uuid);
  if ($synonym) {
    $out .= '<span class="acceptedFor">';
    $out .= t('is accepted for ');
    if (isset($synonym->name->nomenclaturalReference)) {
      $referenceUri = url(path_to_reference($synonym->name->nomenclaturalReference->uuid));
    }
    $out .= render_taxon_or_name($synonym->name, NULL, $referenceUri);
    $out .= theme('cdm_annotations_as_footnotekeys', array('cdmBase_list' => $synonym));
    $out .= '</span>';
  }
  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * @todo document this function.
 */
function theme_cdm_list_of_taxa($variables) {

  $unclassified_snippet = '<span class="unclassified">' . t('unclassified') . '</span>';

  $records = $variables['records'];
  $freetextSearchResults = $variables['freetextSearchResults'];
  $show_classification = $variables['show_classification'];

  RenderHints::pushToRenderStack('list_of_taxa');

  $form_name = 'search_gallery';
  // $default_values = unserialize(CDM_DATAPORTAL_GALLERY_SETTINGS);
  // $gallery_settings = variable_get($form_name, $default_values);
  $gallery_settings = getGallerySettings(CDM_DATAPORTAL_SEARCH_GALLERY_NAME);

  $showMedia_taxa = $gallery_settings['cdm_dataportal_show_taxon_thumbnails'];
  $showMedia_synonyms = $gallery_settings['cdm_dataportal_show_synonym_thumbnails'];
  // $showMedia_taxa =
  // variable_get('cdm_dataportal_findtaxa_show_taxon_thumbnails', 1);
  // $showMedia_synonyms =
  // variable_get('cdm_dataportal_findtaxa_show_synonym_thumbnails', 0);
  $searched_in_classification = cdm_dataportal_searched_in_classification();
  $searched_in_classification_uuid = null;
  if(isset($searched_in_classification->uuid)){
    $searched_in_classification_uuid = $searched_in_classification->uuid;
  }

  // .. Well, for sure not as performant as before, but better than nothing.
  $synonym_uuids = array();
  $misappied_uuids = array();
  foreach ($records as $taxon) {
    if ($taxon->class == "Synonym") {
      if (!array_key_exists($taxon->uuid, $synonym_uuids)) {
        $synonym_uuids[$taxon->uuid] = $taxon->uuid;
      }
    }
    elseif (!_cdm_dataportal_acceptedByCurrentView($taxon)) {
      // Assuming that it is a misappied name, will be further examined below.
      $misappied_uuids[$taxon->uuid] = $taxon->uuid;
    }
  }

  // Batch service not jet implemented:
  // $table_of_accepted = cdm_ws_property(CDM_WS_PORTAL_TAXON_ACCEPTED,
  // join(',', $synonym_uuids));
  // thus ...
  $table_of_accepted = array();

  foreach ($synonym_uuids as $relatedUuid) {
    $table_of_accepted[$relatedUuid] = cdm_ws_get(CDM_WS_PORTAL_TAXON_ACCEPTED, array(
      $relatedUuid,
      $searched_in_classification_uuid,
    ));
  }

  foreach ($misappied_uuids as $relatedUuid) {
    $taxonRelations = cdm_ws_get(CDM_WS_PORTAL_TAXON_RELATIONS, array(
      $relatedUuid,
    ));
    foreach ($taxonRelations as $relation) {
      if ($relation->type->uuid == UUID_MISAPPLIED_NAME_FOR && _cdm_dataportal_acceptedByCurrentView($relation->toTaxon)) {
        $table_of_accepted[$relatedUuid][] = $relation->toTaxon;
      }
    }
  }

  $out = '<ul class="cdm_names" style="background-image: none;">';
  $itemCnt = -1;
  foreach ($records as $taxon) {
    $itemCnt++;
    if (isset($table_of_accepted[$taxon->uuid])) {
      // Its a synonym or misapplied name.
      $is_synonym = isset($synonym_uuids[$taxon->uuid]); //TODO better use the $taxon->class attribute?
      $taxon_type = $is_synonym ? "Synonym" : "misapplied-name";

      $acceptedTaxa = $table_of_accepted[$taxon->uuid];

      if (count($acceptedTaxa) == 1) {

        $acceptedTaxon = $acceptedTaxa[0];
        $taxonUri = uri_to_synonym($taxon->uuid, $acceptedTaxon->uuid, 'synonymy');
        $referenceUri = '';
        if (isset($acceptedTaxon->name->nomenclaturalReference)) {
          $referenceUri = url(path_to_reference($acceptedTaxon->name->nomenclaturalReference->uuid));
        }
        $taxon_or_name = $is_synonym ? $taxon->name : $taxon;
        // $taxon_or_name this is a trick to suppress the sec reference for sysnonyms
        // supplying the name will cause render_taxon_or_name() to not show the sec reference
        $out .= '<li class="' . $taxon_type . '">' . render_taxon_or_name($taxon_or_name, $taxonUri, $referenceUri);
        if ($show_classification) {
          $classifications = get_classifications_for_taxon($taxon);
          $classification_titles = array();
          foreach ($classifications as $classification) {
            if (isset($classification->titleCache)) {
              $classification_titles[] = $classification->titleCache;
            }
          }
          if(count($classification_titles) == 0){
            $classification_titles[] = $unclassified_snippet;
          }
          $out .= ' : <span class="classifications">' . implode(', ', $classification_titles) . '</span>';
        }
        $out .= theme('cdm_annotations_as_footnotekeys', array('cdmBase_list' => $taxon));
        if ($showMedia_synonyms) {
          $out .= theme('cdm_taxon_list_thumbnails', array('taxon' => $acceptedTaxon));
        }
      }
      else {

        // TODO avoid using Ajax in the cdm_dynabox .... why?
        // TODO add media.
        $out .= cdm_dynabox(
          $taxon->uuid, render_taxon_or_name($taxon->name, NULL, NULL, FALSE), cdm_compose_url(CDM_WS_PORTAL_TAXON_ACCEPTED,
          array(
            $taxon->uuid,
            $searched_in_classification_uuid
          )
        ), 'cdm_list_of_taxa', 'show accepted taxa of this ' . $taxon_type, array('li', 'ul'), array('class' => array($taxon_type))
         );
      }
    }
    else {
      // Its a Taxon.
      $taxonUri = url(path_to_taxon($taxon->uuid));
      $referenceUri = '';
      if (isset($taxon->name->nomenclaturalReference)) {
        $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
      }
      $out .= '<li class="Taxon">' . render_taxon_or_name($taxon, $taxonUri, $referenceUri);
      if ($show_classification) {
        $classifications = get_classifications_for_taxon($taxon);
        $classification_titles = array();
        foreach ($classifications as $classification) {
          if (isset($classification->titleCache)) {
            $classification_titles[] = $classification->titleCache;
          }
        }
        if(count($classification_titles) == 0){
          $classification_titles[] = $unclassified_snippet;
        }
        $out .= ' : <span class="classifications">' . implode(', ', $classification_titles) . '</span>';
      }
      $out .= theme('cdm_annotations_as_footnotekeys', array('cdmBase_list' => $taxon));

      if ($showMedia_taxa) {
        $out .= theme('cdm_taxon_list_thumbnails', array('taxon' => $taxon));
      }
    }

    /*
     * the score field will be empty in case of MultiTermQueries like
     * WildcardQueries, since these are  constant score by default
     * since Lucene 2.9
     */
    if(isset($freetextSearchResults[$itemCnt]) && $freetextSearchResults[$itemCnt]->score && $freetextSearchResults[$itemCnt]->maxScore){
      $percentage =  ( $freetextSearchResults[$itemCnt]->score / $freetextSearchResults[$itemCnt]->maxScore ) * 100;
      $out .= '<div class="score-bar"><div class="score-bar-indicator" style="width:' . $percentage .'% "></div></div>';
      $out .= '<div class="score-bar-value">' . number_format($percentage, 2) .'%</div>';
    }

    // Render highlighted fragments, these are made available by free text
    // searches.
    if (isset($freetextSearchResults[$itemCnt]->fieldHighlightMap)) {
      $field_fragments = (array) $freetextSearchResults[$itemCnt]->fieldHighlightMap;
      if (count($field_fragments) > 0) {
        $fragments_out = '';
        foreach ($field_fragments as $fieldName => $fragments) {
          $fragments_out .= '... <span class="' . $fieldName. '">' . filter_xss(join(" ... ", $fragments), array('b') ) . '</span>';
        }
        $out .= '<div class="fragment_highlight">' . $fragments_out . ' ...</div>';
      }
    }

    $out .= '</li>';
  }

  $out .= '</ul>';
  RenderHints::popFromRenderStack();

  return $out;
}

/**
 * Renders a representation of the given taxon relationship.
 *
 * According name relationships are also being rendered.
 *
 * @param unknown_type $taxonRelationship
 * @param boolean $doLinkTaxon
 *     whether to create a link to the related taxon
 * @param boolean $inverse
 *     whether the $taxonRelationship should be treaded as invers relation
 *
 * @return void|string
 */
function cdm_taxonRelationship($taxonRelationship, $doLinkTaxon = FALSE, $inverse = FALSE) {

  // Validate object.
  if (!(isset($taxonRelationship->toTaxon) && isset($taxonRelationship->fromTaxon) && isset($taxonRelationship->type))) {
    return null;
  }

  $taxonRelationType = $taxonRelationship->type;

  if ($inverse) {
    $toTaxon = $taxonRelationship->fromTaxon;
    $relsign = $taxonRelationType->inverseRepresentation_L10n_abbreviatedLabel;
    $reltype_representation = $taxonRelationType->inverseRepresentation_L10n;
  }
  else {
    $toTaxon = $taxonRelationship->toTaxon;
    $relsign = $taxonRelationType->representation_L10n_abbreviatedLabel;
    $reltype_representation = $taxonRelationType->representation_L10n;
  }

  return cdm_related_taxon($toTaxon, NULL, $relsign, $reltype_representation, $taxonRelationship->doubtful, $doLinkTaxon);
}

/**
 * Renders a representation of the given taxon relationship.
 *
 * According name relationships are also being rendered.
 */
function cdm_related_taxon($taxon, $reltype_uuid = NULL, $relsign = NULL, $reltype_representation = NULL, $doubtful=false, $doLinkTaxon = FALSE) {
  static $relsign_homo = '≡';
  static $relsign_hetero = '=';
  static $relsign_invalid = '&ndash;';

  // 'taxonRelationships';
  $footnoteListKey = NULL;

  $name_prefix = '';
  $name_postfix = '';

  $skiptags = array();

  if (!$relsign) {

    $relsign = '';

    switch ($reltype_uuid) {
      case UUID_HETEROTYPIC_SYNONYM_OF:
      case UUID_SYNONYM_OF:
        $relsign = $relsign_hetero;
        break;

      case UUID_HOMOTYPIC_SYNONYM_OF:
        $relsign = $relsign_homo;
        break;

      case UUID_MISAPPLIED_NAME_FOR:
      case UUID_INVALID_DESIGNATION_FOR:
        $skiptags[] = 'authors';
        $relsign = $relsign_invalid;
        $name_prefix = '"';
        $name_postfix = '"';
        break;

      default:
        $relsign = $relsign_invalid;
    }

  }

  if($doubtful) {
    $relsign = '?' . $relsign;
  }

  /*
  Names with status invalid or nudum are to be displayed with the
  $relsign_invalid, these names appear at the end of all names in their
  homotypic group (ordered correctly by the java cdm_lib).
  */
  if (isset($taxon->name->status) && is_array($taxon->name->status)) {
    foreach ($taxon->name->status as $status) {
      if ($status->type->uuid == UUID_NOMENCLATURALSTATUS_TYPE_INVALID || $status->type->uuid == UUID_NOMENCLATURALSTATUS_TYPE_NUDUM) {
        $relsign = $relsign_invalid;
      }
    }
  }

  // Now rendering starts ..
  RenderHints::pushToRenderStack('related_taxon');

  if (isset($taxon->name->nomenclaturalReference)) {
    $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
  }
  $taxonUri = '';
  if ($doLinkTaxon) {
    $taxonUri = url(path_to_taxon($taxon->uuid, "synonymy"));
  }
  // Printing the taxonName and the handling the special case of annotations.
  if (!isset($referenceUri)) {
    $referenceUri = FALSE;
  }
  $out_taxon_part = render_taxon_or_name($taxon, $taxonUri, $referenceUri, TRUE, FALSE, $skiptags);
  $taxon_footnotes = theme('cdm_annotations_as_footnotekeys',
       array('cdmBase_list' => array(
         $taxon->name,
         $taxon,
       ),
       'footnote_list_key' => $footnoteListKey)
  );

  $homonyms = cdm_name_relationships_of($taxon);

  $out = '<span class="relation_sign" title="' . $reltype_representation . '">' . $relsign . '</span>'
      . $name_prefix . $out_taxon_part . $name_postfix . $taxon_footnotes . ' '
      . $homonyms;

  $out = uuid_anchor($taxon->uuid, $out);

  RenderHints::popFromRenderStack();

  return $out;
}


  /**
 * @todo document this function.
 */
function theme_cdm_taxon_list_thumbnails($variables) {

  $taxon = $variables['taxon'];
  $out = '';
  $gallery_settings = getGallerySettings(CDM_DATAPORTAL_SEARCH_GALLERY_NAME);
  $showCaption = $gallery_settings['cdm_dataportal_show_thumbnail_captions'];
  if ($showCaption) {
    $captionElements = array(
      'title',
      'rights',
    );
  } else {
    $captionElements = array();
  }

  $gallery_name = $taxon->uuid;

  $mediaList = _load_media_for_taxon($taxon);

  $galleryLinkUri = path_to_taxon($taxon->uuid, 'images');

  $out .= theme('cdm_media_gallerie', array(
    'mediaList' => $mediaList,
    'galleryName' => $gallery_name,
    'maxExtend' => $gallery_settings['cdm_dataportal_media_maxextend'],
    'cols' => $gallery_settings['cdm_dataportal_media_cols'],
    'maxRows' => $gallery_settings['cdm_dataportal_media_maxRows'],
    'captionElements' => $captionElements,
    'mediaLinkType' => 'LIGHTBOX',
    'alternativeMediaUri' => NULL,
    'galleryLinkUri' => $galleryLinkUri,
     ));

  return $out;
}
