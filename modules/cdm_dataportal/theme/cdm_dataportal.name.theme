<?php
// $Id$

/**
* Copyright (C) 2007 EDIT
* European Distributed Institute of Taxonomy 
* http://www.e-taxonomy.eu
* 
* The contents of this file are subject to the Mozilla Public License Version 1.1
* See http://www.mozilla.org/MPL/MPL-1.1.html for the full license terms.
*/



function theme_cdm_typedesignations($typeDesignations = array()){

	RenderHints::pushToRenderStack('typedesignations');
	_add_js_cluetip();
	$out = '<ul class="typeDesignations">';

	$specimenTypeDesignations = array();
	foreach($typeDesignations as $typeDesignation){
		if($typeDesignation->class == 'SpecimenTypeDesignation'){
			// SpecimenTypeDesignations should be ordered. collect theme here only
			$specimenTypeDesignations[] = $typeDesignation;
		}else {

			// it's a NameTypeDesignation
			if($typeDesignation->notDesignated){
				$out .= '<li class="nameTypeDesignation"><span class="status">Type</span>: '.t('not designated'). '</li>';
			}else if($typeDesignation->typeName){
                $link_to_name_page = '?q=' . path_to_name($typeDesignation->typeName->uuid);
				$out .= '<li class="nameTypeDesignation"><span class="status">Type</span>: ';

				if($typeDesignation->typeName->nomenclaturalReference){
					$referenceUri = url(path_to_reference($typeDesignation->typeName->nomenclaturalReference->uuid));
				}
				$out .= theme('cdm_taxonName', $typeDesignation->typeName, $link_to_name_page, $referenceUri);

				//        if($typeDesignation->typeName->class == 'ZoologicalName') {
				//          // appending authorTeam which has been skipped in cdm_name
				//          $authorTeam = cdm_taggedtext_value($typeDesignation->typeName->taggedName, 'authors');
				//          $authorTeamPart = l('<span class="authors">'.$authorTeam.'</span>', "/cdm_dataportal/reference/".$typeDesignation->typeName->nomenclaturalReference->uuid, array(), NULL, NULL, FALSE, TRUE);
				//          $out .= (str_endsWith($authorTeam, ')') ? '' : ', ').$authorTeamPart;
				//        } else {
				//          $out .= ' '.theme('cdm_reference', $typeDesignation->citation, true, $referenceStyle);
				//          $out .= '</li>';
				//        }
			}
		}
	}

	if(!empty($specimenTypeDesignations)){
		// sorting might be different for dataportals so this has to be parameterized
		usort($specimenTypeDesignations, "compare_specimenTypeDesignationStatus");
		foreach($specimenTypeDesignations as $std){

			$typeReference = '';
			//show citation only for Lectotype or Neotype
			$showCitation = isset($std->typeStatus) && ($std->typeStatus->uuid == UUID_NEOTYPE || $std->typeStatus->uuid == UUID_LECTOTYPE);
			if($showCitation && !empty($std->citation)){
				//$shortCitation = $std->citation->authorTeam->titleCache;

			     $author_team = cdm_ws_get(CDM_WS_REFERENCE_AUTHORTEAM, $std->citation->uuid);
			     $shortCitation = $author_team->titleCache;

				$shortCitation .= (strlen($shortCitation) > 0 ? ' ' : '' ). partialToYear($std->citation->datePublished->start);
				if(strlen($shortCitation) == 0){
					$shortCitation = theme('cdm_reference', $std->citation);
					$missingShortCitation = true;
				}
				$typeReference .= '&nbsp;(' . t('designated by');
				$typeReference .= '&nbsp;<span class="typeReference '.($missingShortCitation ? '' : 'cluetip').' no-print" title="'. htmlspecialchars('|'.theme('cdm_reference',$std->citation ).'|') .'">';
				$typeReference .= $shortCitation.'</span>';
				$typeReference .= ')';
				//$typeReference .= '<span class="reference only-print">(designated by '.theme('cdm_reference',$std->citation ).')</span>';
			}

			$out .= '<li class="specimenTypeDesignation">';
			$out .= '<span class="status">'.(($std->typeStatus->representation_L10n) ? $std->typeStatus->representation_L10n : t('Type')) .$typeReference.'</span>: '.$std->typeSpecimen->titleCache;
			//$out .= '<span class="status">'.(($std->typeStatus->representation_L10n) ? $std->typeStatus->representation_L10n : t('Type')) .$typeReference.'</span>: '.$std->typeSpecimen->titleCache . ' footnote: '. theme_cdm_footnote($std->typeSpecimen->collection->code, $std->typeSpecimen->collection->titleCache);
  
			$out .= theme('cdm_specimen', $std->typeSpecimen);
			$out .= '</li>';
		}
	}

	$out .= '</ul>';

	RenderHints::popFromRenderStack();
	return $out;
}


/**
 * FIXME this definitively has to be in another spot. just didn't know where to put it right now.
 * Compares the status of two SpecimenTypeDesignations
 * @param String $a 	a SpecimenTypeDesignations
 * @param String $b		another SpecimenTypeDesignations
 */
function compare_specimenTypeDesignationStatus($a, $b){
	/* this is the desired sort oder as of now:
	 * 	Holotype
	 * 	Isotype
	 * 	Lectotype
	 * 	Isolectotype
	 * 	Syntype
	 *
	 * TODO
	 * Basically, what we are trying to do is, we define an ordered array of TypeDesignation-states
	 * and use the index of this array for comparison. This array has to be filled with the cdm-
	 * TypeDesignation states and the order should be parameterisable inside the dataportal.
	 */
	// make that static for now
	$typeOrder = array('Holotype', 'Isotype', 'Lectotype', 'Isolectotype', 'Syntype');

	$aQuantifier = array_search($a->typeStatus->label, $typeOrder);
	$bQuantifier = array_search($b->typeStatus->label, $typeOrder);

	if ($aQuantifier == $bQuantifier) {
		// sort alphabetically
		return ($a->typeStatus->label < $b->typeStatus->label) ? -1 : 1;
	}
	return ($aQuantifier < $bQuantifier) ? -1 : 1;

}

function theme_cdm_nameRelationships($nameRelationships, $skipTypes = false){

    if(!$nameRelationships){
        return;
    }
    
	RenderHints::pushToRenderStack('nameRelationships');
    $footnoteListKey = 'nameRelationships';
    RenderHints::setFootnoteListKey($footnoteListKey);
    
	// group by relationship type
	$relationshipGroups = array();
	foreach($nameRelationships as $nameRelationship){
		if(!array_key_exists($nameRelationship->type->uuid, $relationshipGroups)){
			$relationshipGroups[$nameRelationship->type->uuid] = array();
		}
		$relationshipGroups[$nameRelationship->type->uuid][] = $nameRelationship;
	}

	// generate output
	$out = '';
	foreach($relationshipGroups as $group){
		$type = $group[0]->type;

		if(is_array($skipTypes) && in_array($type->uuid, $skipTypes)){
			continue;
		}

		$block->module = 'cdm_dataportal';
		$block->subject = t(ucfirst($type->inverseRepresentation_L10n));
		$block->delta = generalizeString(strtolower($type->inverseRepresentation_L10n));

		foreach($group as $relationship){
			$relatedNames[] = cdm_taggedtext2html($relationship->fromName->taggedName);
		}

		$block->content .= implode('; ', $relatedNames);
		$out .= theme('block', $block);
	}
	$out .= theme('cdm_footnotes', $footnoteListKey, 'div');
	
	RenderHints::popFromRenderStack();
	return $out;
}



function theme_cdm_homotypicSynonymLine($taxon){
	$out = '';
	$out .= '<li class="synonym">'.theme('cdm_related_taxon', $taxon, UUID_HOMOTYPIC_SYNONYM_OF).'</li>';
	
	return $out;
}

function theme_cdm_heterotypicSynonymyGroup($homotypicalGroup){
	
	RenderHints::pushToRenderStack('heterotypicSynonymyGroup');
	
	$out = '';
	$out = '<ul class="heterotypicSynonymyGroup">';
    $footnoteListKey = ( isset($homotypicalGroup[0]) ? $homotypicalGroup[0]->uuid : 'NULL');
	RenderHints::setFootnoteListKey($footnoteListKey);
    
	$is_first_entry = true;
	$typeDesignations = null;
	foreach($homotypicalGroup as $synonym){
		if($is_first_entry){
			$is_first_entry = false;
			//$typeDesignations = cdm_ws_get(CDM_WS_NAME_TYPEDESIGNATIONS, $synonym->name->uuid);
			$typeDesignations = cdm_ws_get(CDM_WS_PORTAL_TAXON_NAMETYPEDESIGNATIONS, $synonym->uuid);
			// is first list entry
			$out .= '<li class="firstentry synonym">'.theme('cdm_related_taxon',$synonym, UUID_HETEROTYPIC_SYNONYM_OF).'</li>';
		} else {
			$out .= '<li class="synonym">'.theme('cdm_related_taxon',$synonym, UUID_HOMOTYPIC_SYNONYM_OF).'</li>';
		}
	}
	if($typeDesignations){
		$out .= theme('cdm_typedesignations', $typeDesignations);
	}

	$out .= theme('cdm_footnotes', $footnoteListKey, 'li');
	$out .= '</ul>';
    
    
    RenderHints::popFromRenderStack();
	return $out;
}



function theme_cdm_homotypicSynonymyGroup($synonymList, $prependedSynonyms = array()){
	
	RenderHints::pushToRenderStack('homotypicSynonymyGroup');
	
	$footnoteListKey = isset($prependedSynonyms[0]) ? $prependedSynonyms[0]->uuid : (isset($synonymList[0]) ? $synonymList[0]->uuid : 'NULL');
	RenderHints::setFootnoteListKey($footnoteListKey);
	
	if(! is_array($synonymList) || count($synonymList) == 0){
		return;
	}

	$out = '<ul class="homotypicSynonyms">';

	if(!empty($prependedSynonyms)){
		foreach($prependedSynonyms as $taxon){
			$out .= '<li class="synonym">'.theme('cdm_related_taxon', $taxon, UUID_HOMOTYPIC_SYNONYM_OF).'</li>';
		}
	}

	foreach($synonymList as $synonym){
		$out .= '<li class="synonym">'.theme('cdm_related_taxon', $synonym, UUID_HOMOTYPIC_SYNONYM_OF).'</li>';
	}

	$typeDesignations = cdm_ws_get(CDM_WS_PORTAL_TAXON_NAMETYPEDESIGNATIONS, $synonymList[0]->uuid);
	if($typeDesignations){
		$out .= theme('cdm_typedesignations', $typeDesignations);
	}

	$out .= theme('cdm_footnotes', $footnoteListKey, 'li');
	$out .= '</ul>';
	
	RenderHints::popFromRenderStack();
	return $out;
}


function theme_cdm_taxonName($taxonName, $nameLink = NULL, $refenceLink = NULL){

  $renderTemplate = get_nameRenderTemplate(RenderHints::getRenderPath(), $nameLink, $refenceLink);
	$partDefinition = get_partDefinition($taxonName->class);

	// apply defintions to template
	foreach($renderTemplate as $part=>$uri){
		if(isset($partDefinition[$part])){
			$renderTemplate[$part] = $partDefinition[$part];
		}
		if(is_array($uri)){
			$renderTemplate[$part]['#uri'] = $uri['#uri'];
		}
	}

	$firstEntryIsValidNamePart = is_array($taxonName->taggedName)
	&& is_string($taxonName->taggedName[0]->text)
	&& $taxonName->taggedName[0]->text != ''
	&& $taxonName->taggedName[0]->type == 'name';
	
	// got to use second entry as first one, see ToDo comment below ...
	if($firstEntryIsValidNamePart){

		$taggedName = $taxonName->taggedName;
		
		$lastAuthorElementString = false;
		$hasNamePart_with_Authors = isset($renderTemplate['namePart']) && isset($renderTemplate['namePart']['authors']);
		$hasNameAuthorPart_with_Authors = isset($renderTemplate['nameAuthorPart']) && isset($renderTemplate['nameAuthorPart']['authors']);

		if(!($hasNamePart_with_Authors || $hasNameAuthorPart_with_Authors)){
			//      // find author and split off from name
			//      // TODO expecting to find the author as the last element
			//      if($taggedName[count($taggedName)- 1]->type == 'authors'){
			//        $authorTeam = $taggedName[count($taggedName)- 1]->text;
			//        unset($taggedName[count($taggedName)- 1]);
			//      }

			// remove all authors
			$taggedNameNew = array();
			foreach($taggedName as $element){
				if($element->type != 'authors'){
					$taggedNameNew[] = $element;
				} else {
					$lastAuthorElementString = $element->text;
				}
			}
			$taggedName = $taggedNameNew;

		}
		$name = '<span class="'.$taxonName->class.'">'.theme('cdm_taggedtext2html', $taggedName).'</span>';
	} else {
		$name = '<span class="'.$taxonName->class.'_titleCache">'.$taxonName->titleCache.'</span>';
	}

	// fill name into $renderTemplate
	array_setr('name', $name, $renderTemplate);

	//  // fill with authorTeam
	//  if($authorTeam){
	//    $authorTeamHtml = ' <span class="authorTeam">'.$authorTeam.'</span>';
	//    array_setr('authorTeam', $authorTeamHtml, $renderTemplate);
	//  }


	// fill with reference
	if(isset($renderTemplate['referencePart'])){

		// [Eckhard]:"Komma nach dem Taxonnamen ist grunsätzlich falsch,
		// Komma nach dem Autornamen ist überall dort falsch, wo ein "in" folgt."
		if(isset($renderTemplate['referencePart']['reference']) && $taxonName->nomenclaturalReference){
			$microreference = null;
			if(isset($renderTemplate['referencePart']['microreference'])){
				$microreference = $taxonName->nomenclaturalMicroReference;
			}
			$citation = cdm_ws_get(CDM_WS_NOMENCLATURAL_REFERENCE_CITATION, array($taxonName->nomenclaturalReference->uuid), "microReference=".urlencode($microreference));
			$citation = $citation->String;
			// find preceding element of the refrence
			$precedingKey = get_preceding_contentElementKey('reference', $renderTemplate);
			if(str_beginsWith($citation, ", in")){
				$citation = substr($citation, 2);
				$separator = ' ';
			} else if(!str_beginsWith($citation, "in") && $precedingKey == 'authors'){
				$separator = ', ';
			} else {
				$separator = ' ';
			}

			$referenceArray['#separator'] = $separator;
			$referenceArray['#html'] = '<span class="reference">'.$citation.'</span>';
			array_setr('reference', $referenceArray, $renderTemplate);
		}

		// if authors have been removed from the name part the last named authorteam
		// should be added to the reference citation, otherwise, keep the separator
		// out of the reference
		if(isset($renderTemplate['referencePart']['authors']) && $lastAuthorElementString){
			// if the nomenclaturalReference cintation is not included in the reference part but diplay of the microreference
			// is whanted append the microreference to the authorTeam
			if(!isset($renderTemplate['referencePart']['reference']) && isset($renderTemplate['referencePart']['microreference'])){
				$separator = ": ";
				$citation = $taxonName->nomenclaturalMicroReference;
			}
			$referenceArray['#html'] = ' <span class="reference">'.$lastAuthorElementString.$separator.$citation.'</span>';
			array_setr('authors', $referenceArray, $renderTemplate);
		}

	}

	// fill with status
	if(array_setr('status', true, $renderTemplate)){
		if(isset($taxon->name->status[0])){
			foreach($taxon->name->status as $status){
				$statusHtml .= ', '.$status->type->representation_L10n;
			}
		}
		array_setr('status', ' <span class="nomenclatural_status">'.$statusHtml.'</span>', $renderTemplate);
	}

	// fill with protologues etc...
	if(array_setr('description', true, $renderTemplate)){
		$descriptions = cdm_ws_get(CDM_WS_PORTAL_NAME_DESCRIPTIONS, $taxonName->uuid);
		foreach($descriptions as $description){
			if(!empty($description)){
				foreach($description->elements as $description_element){
					$descriptionHtml .= theme("cdm_media", $description_element, array('application/pdf', 'image/png', 'image/jpeg', 'image/gif', 'text/html'));
				}
			}
		}
		array_setr('description', $descriptionHtml, $renderTemplate);
	}

	// render
	$out = '<span ref="/name/'.$taxonName->uuid.'">';
	
	foreach($renderTemplate as $partName=>$part){
		$separator = '';
		$partHtml = '';
		$uri = false;
		if(!is_array($part)){
			continue;
		}
		if(isset($part['#uri']) && is_string($part['#uri'])){
			$uri = $part['#uri'];
			unset($part['#uri']);
		}
		foreach($part as $key=>$content){
			$html = '';
			if(is_array($content)){
				$html = $content['#html'];
				$separator = $content['#separator'];
			} else if(is_string($content)){
				$html = $content;
			}
			$partHtml .= '<span class="'.$key.'">'.$html.'</span>';
		}
		if($uri){
			$out .= $separator.'<a href="'.$uri.'" class="'.$partName.'">'.$partHtml.'</a>';
		} else {
			$out .= $separator.$partHtml;
		}
	}
    $out .= '</span>';
    
	// add annotations
	$out .= theme('cdm_annotations', $taxonName);
	
	return $out;
}

/**
 * Recursively searches the array for the $key and sets the given value
 * @param $key
 * @param $value
 * @param $array
 * @return true if the key has been found
 */
function &array_setr($key, $value, array &$array){
	foreach($array as $k=>&$v){
		if($key == $k){
			$v = $value;
			return $array;
		} else if(is_array($v)){
			$innerArray = array_setr($key, $value, $v);
			if($innerArray){
				return $array;
			}
		}
	}
	return null;
}

function &get_preceding_contentElement($contentElementKey, array &$renderTemplate){
	$precedingElement = null;
	foreach($renderTemplate as &$part){
		foreach($part as $key=>&$element){
			if($key == $contentElementKey){
				return $precedingElement;
			}
			$precedingElement = $element;
		}
	}
	return null;
}

function &get_preceding_contentElementKey($contentElementKey, array &$renderTemplate){
	$precedingKey = null;
	foreach($renderTemplate as &$part){
		foreach($part as $key=>&$element){
			if($key == $contentElementKey){
				return $precedingKey;
			}
			if(!str_beginsWith($key, '#')){
				$precedingKey = $key;
			}
		}
	}
	return null;
}







