<?php
/**
 * @file
 * Name theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */

/**
 * Return HTML for the lectotype citation with the correct layout.
 *
 * This function prints the lectotype citation with the correct layout.
 * Lectotypes are renderized in the synonymy tab of a taxon if they exist.
 *
 * @param mixed $typeDesignation
 *   Object containing the lectotype citation to print.
 *
 * @return string
 *   Valid html string.
 */
function type_designation_citation_layout($typeDesignation, $footnote_separator = ',') {
  $res = '';
  $citation = $typeDesignation->citation;
  $pages = $typeDesignation->citationMicroReference;
  if(isset($typeDesignation->typeStatus->uuid) && isset($typeDesignation->typeStatus->representation_L10n)) {
    if ( $typeDesignation->typeStatus->uuid == UUID_NTD_ORIGINAL_DESIGNATION || $typeDesignation->typeStatus->uuid == UUID_NTD_MONOTYPY) {
      $res = ' (' . $typeDesignation->typeStatus->representation_L10n . ')';
      return $res;
    }
  }

  if ($citation) {
    // $type = $typeDesignation_citation->type;
    $year = isset($citation->datePublished->start) ? substr($citation->datePublished->start, 0, 4) : '';
    $author = isset($citation->authorship->titleCache) ? $citation->authorship->titleCache : '';
    $res .= ' (designated by ';
    $res .= $author;
    $res .= ($year ? ' ' . $year : '');
    $res .= ($pages ? ': ' . $pages : '');
    // $res .= ')';

    // footnotes should be rendered in the parent element so we
    // are relying on the FootnoteListKey set there
    $fkey_typeDesignation = FootnoteManager::addNewFootnote(RenderHints::getFootnoteListKey(), $typeDesignation->citation->titleCache);
    $res .= theme('cdm_footnote_key', array(
      'footnoteKey' => $fkey_typeDesignation,
      'separator' => $footnote_separator,
      'highlightable' => TRUE,
      'separator_off' => TRUE,
    )) . ')';
  }
  return $res;
}


/**
 * Renders and array of CDM TypeDesignations
 *
 * @param array $variables
 *   - typeDesignations: an array of cdm TypeDesignation entities to render
 */
function theme_cdm_typedesignations($variables) {
  $type_designations = $variables['typeDesignations'];
  $enclosing_tag = $variables['enclosing_tag'];
  $element_tag = $variables['element_tag'];
  $link_to_specimen_page = $variables['link_to_specimen_page'];

  // need to add element to render path since type designations
  // need other name render template
  RenderHints::pushToRenderStack('typedesignations');

  $out = '<' . $enclosing_tag .' class="typeDesignations">';
  $typeDesignation_footnotes = FALSE;
  $is_lectotype = FALSE;
  $specimen_type_designations = array();
  $name_type_designations = array();
  $textual_type_designations = array();
  $separator = ',';

  foreach ($type_designations as $type_designation) {
    switch ($type_designation->class) {
      case 'SpecimenTypeDesignation':
        $specimen_type_designations[] = $type_designation;
        break;
      case 'NameTypeDesignation':
        $name_type_designations[] = $type_designation;
        break;
      case 'TextualTypeDesignation':
        $textual_type_designations[] = $type_designation;
        break;
      default:  throw new Exception('Unknown type designation class: ' . $type_designation->class);
    }
  }

  // NameTypeDesignation ..................................
  if(!empty($name_type_designations)){
    uksort($name_type_designations, "compare_type_designation_status");
    foreach($name_type_designations as $name_type_designation){
      if ($name_type_designation->notDesignated) {
        $out .= '<'. $element_tag .' class="' . html_class_attribute_ref($name_type_designation) . '">' .  type_designation_status_label_markup($name_type_designation)  . ': '
          . t('not designated') . '</'. $element_tag .'>';
      }
      elseif (isset($name_type_designation->typeName)) {
        $link_to_name_page = url(path_to_name($name_type_designation->typeName->uuid));
        $out .= '<'. $element_tag .' class="' . html_class_attribute_ref($name_type_designation) . '">' .  type_designation_status_label_markup($name_type_designation) ;

        if (!empty($name_type_designation->citation)) {
          $out .= type_designation_citation_layout($name_type_designation, $separator); // TODO type_designation_citation_layout() needs most probably to be replaced

        }
        $referenceUri = '';
        if (isset($name_type_designation->typeName->nomenclaturalReference)) {
          $referenceUri = url(path_to_reference($name_type_designation->typeName->nomenclaturalReference->uuid));
        }
        $out .= ': ' . render_taxon_or_name($name_type_designation->typeName, $link_to_name_page, $referenceUri, TRUE, TRUE);
      }
    }
  } // END NameTypeDesignation

  // SpecimenTypeDesignation ...................................
  if (!empty($specimen_type_designations)) {
    usort($specimen_type_designations, "compare_specimen_type_designation");
    foreach ($specimen_type_designations as $specimen_type_designation) {
      $type_citation_markup = '';

      if (!empty($specimen_type_designation->citation)) {

        $citation_footnote_str = theme('cdm_reference', array('reference' => $specimen_type_designation->citation, 'doIconLink' => true));
        $author_team = cdm_ws_get(CDM_WS_REFERENCE_AUTHORTEAM, $specimen_type_designation->citation->uuid);

        if (!empty($author_team->titleCache)) {
          $year = @timePeriodToString($specimen_type_designation->citation->datePublished, true, 'YYYY');
          $authorteam_str = $author_team->titleCache . ($year ? ' ' : '') . $year;
          if ($authorteam_str == $specimen_type_designation->citation->titleCache) {
            $citation_footnote_str = '';
          }
        } else {
          $authorteam_str = $citation_footnote_str;
          // no need for a footnote in case in case it is used as replacement for missing author teams
          $citation_footnote_str = '';
        }

        // for being registered a typedesignation MUST HAVE a citation, so it is save to handle the
        // Registration output in if condition checking if the citation is present
        $registration_markup = render_registrations($specimen_type_designation->registrations);
        $citation_footnote_str .= ($citation_footnote_str ? ' ' : '') . $registration_markup;

        $footnote_key_markup = '';
        if ($citation_footnote_str) {
          // footnotes should be rendered in the parent element so we
          // are relying on the FootnoteListKey set there
          $_fkey2 = FootnoteManager::addNewFootnote(RenderHints::getFootnoteListKey(), $citation_footnote_str);
          $footnote_key_markup = theme('cdm_footnote_key', array(
            'footnoteKey' => $_fkey2,
            'separator' => $separator,
            'highlightable' => TRUE,
            'separator_off' => TRUE,
          ));

        }

        $type_citation_markup .= '&nbsp;(' . t('designated by') . '&nbsp;<span class="typeReference">' . $authorteam_str . '</span>';
        if (!empty($specimen_type_designation->citationMicroReference)) {
          $type_citation_markup .= ': ' . trim($specimen_type_designation->citationMicroReference);
        }
        $type_citation_markup .= $footnote_key_markup . ')';

      }

      $out .= '<'. $element_tag .' class="' . html_class_attribute_ref($specimen_type_designation) . '">';
      $out .= type_designation_status_label_markup($specimen_type_designation) . $type_citation_markup;


      $derivedUnitFacadeInstance = null;
      if (isset($specimen_type_designation->typeSpecimen)) {
        $derivedUnitFacadeInstance = cdm_ws_get(CDM_WS_DERIVEDUNIT_FACADE, $specimen_type_designation->typeSpecimen->uuid);
      }

      if (!empty($derivedUnitFacadeInstance->titleCache)) {
        $specimen_markup = $derivedUnitFacadeInstance->titleCache;
        if($link_to_specimen_page && isset($derivedUnitFacadeInstance->specimenLabel) && $derivedUnitFacadeInstance->specimenLabel){
          $specimen_markup = str_replace($derivedUnitFacadeInstance->specimenLabel, l($derivedUnitFacadeInstance->specimenLabel, path_to_specimen($specimen_type_designation->typeSpecimen->uuid)), $specimen_markup);
        }
        $out .= ': <span class="' . html_class_attribute_ref($specimen_type_designation->typeSpecimen) . '">'
           . $specimen_markup
           . '</span>'; // . ': ' . theme('cdm_specimen', array('specimenTypeDesignation' => $derivedUnitFacadeInstance));
        if(!empty($derivedUnitFacadeInstance->preferredStableUri)){
          $out .= ' ' . l($derivedUnitFacadeInstance->preferredStableUri, $derivedUnitFacadeInstance->preferredStableUri, array('absolute' => true));
        }
      }


      $out .= '</'. $element_tag .'>';

    }
  } // END Specimen type designations

  // TextualTypeDesignation .........................
  if(!empty($textual_type_designations)) {
    foreach ($textual_type_designations as $textual_type_designation) {
      $encasement =  $textual_type_designation->verbatim ? '"' : '';
      $out .= '<' . $element_tag . ' class="' . html_class_attribute_ref($textual_type_designation) . '">' . type_designation_status_label_markup(null)
        . ': ' .  $encasement . $textual_type_designation->text_L10n->text . $encasement . '</' . $element_tag . '>';
      $annotations_and_sources = handle_annotations_and_sources(
        $textual_type_designation,
        array(
          'sources_as_content' => false, // as footnotes
          'link_to_name_used_in_source' => false,
          'link_to_reference' => true,
          'add_footnote_keys' => false,
          'bibliography_aware' => false),
      '',
        RenderHints::getFootnoteListKey() // passing a defined key to avoid separate annotation footnote key see https://dev.e-taxonomy.eu/redmine/issues/8543
        );
      $out .= $annotations_and_sources['foot_note_keys'];
        if(is_array( $annotations_and_sources['source_references'])){
          $citation_markup = join(', ', $annotations_and_sources['source_references']);
        }
    }
  }

  // Footnotes for citations, collection acronym?s.
  // footnotes should be rendered in the parent element so we
  // are relying on the FootnoteListKey set there
  $_fkey = FootnoteManager::addNewFootnote(
    RenderHints::getFootnoteListKey(),
    (isset($derivedUnitFacadeInstance->collection->titleCache) ? $derivedUnitFacadeInstance->collection->titleCache : FALSE)
  );
  $out .= theme('cdm_footnote_key', array('footnoteKey' => $_fkey, 'separator' => $separator));
  $out .= '</' . $enclosing_tag .'>';

  RenderHints::popFromRenderStack();

  return $out;
}

/**
 * Creates markup for the status of a type designation. In case the status or its representation is missing the label will be set to "Type"
 *
 * @param $type_designation
 * @return string
 */
function type_designation_status_label_markup($type_designation)
{
  return '<span class="type-status">'
    . ((isset($type_designation->typeStatus->representation_L10n)) ? ucfirst($type_designation->typeStatus->representation_L10n) : t('Type')) . '</span>'
    ;
}


/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_homotypicSynonymLine($variables) {
  $taxon = $variables['taxon'];
  $out = '';
  $out .= '<li class="synonym">' . cdm_related_taxon($taxon, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';

  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_heterotypicSynonymyGroup($variables) {
  $homotypical_group = $variables['homotypicalGroup'];
  RenderHints::pushToRenderStack('heterotypicSynonymyGroup');

  $out = '';
  $out = '<div class="heterotypic-synonymy-group"><ul class="heterotypicSynonymyGroup">';
  $footnoteListKey = (isset($homotypical_group[0]) ? $homotypical_group[0]->uuid : 'NULL');
  RenderHints::setFootnoteListKey($footnoteListKey);

  $type_designations= type_designations_for_synonymy_group($homotypical_group);

  $is_first_entry = TRUE;
  foreach ($homotypical_group as $synonym) {
    if ($is_first_entry) {
      $is_first_entry = FALSE;
      // Is first list entry.
      $out .= '<li class="firstentry synonym">' . cdm_related_taxon($synonym, UUID_HETEROTYPIC_SYNONYM_OF) . '</li>';
    }
    else {
      $out .= '<li class="synonym">' . cdm_related_taxon($synonym, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';
    }
  }

  if (count($type_designations) > 0) {
    $out .= theme('cdm_typedesignations', array('typeDesignations' => $type_designations));
  }
  $out .= '</ul>';

  // ------- footnotes ------- //
  $out .= '<ul class="footnotes">';
  $out .= theme('cdm_annotation_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= theme('cdm_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= '</ul>';

  $out .= '</div>';

  RenderHints::popFromRenderStack();
  return $out;
}

/**
 * Renders the homotypic synonymy group for the accepted taxon in the synonymy.
 *
 * Foonotes of the accepted taxon will also be rendered here in the
 * homotypic synonymy group even if the synonymList or prependedSynonyms are
 * empty. Therefore  the homotypic group and accepted taxon share the  same
 * footnote key.
 *
 * @param $variables
 *   an associative array:
 *   - synonymList: the list of cdm Synonym entities
 *   - accepted_taxon_uuid: the uuid of the accepted taxon
 *   - prependedSynonyms: further synonyms which should be prepended
 *      before the actual list of synonyms
 */
function theme_cdm_homotypicSynonymyGroup($variables) {
  $synonymList = $variables['synonymList'];
  $accepted_taxon_name_uuid = $variables['accepted_taxon_name_uuid'];
  $prependedSynonyms = $variables['prependedSynonyms'];

  RenderHints::pushToRenderStack('homotypicSynonymyGroup');

  $type_designations_in_group = NULL;

  $out = '<div class="homotypic-synonymy-group">';

  $type_designations = type_designations_for_synonymy_group($synonymList, $accepted_taxon_name_uuid);

  if (count($type_designations) > 0 || is_array($prependedSynonyms) || is_array($synonymList)) {
    $out .= '<ul class="homotypicSynonyms">';
  if (!empty($prependedSynonyms)) {
    foreach ($prependedSynonyms as $taxon) {
      $out .= '<li class="synonym">' . cdm_related_taxon($taxon, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';
    }
  }


  if (isset($synonymList[0])) {
    foreach ($synonymList as $synonym) {
      $out .= '<li class="synonym">' . cdm_related_taxon($synonym, UUID_HOMOTYPIC_SYNONYM_OF) . '</li>';
    }
  }

  if (count($type_designations) > 0) {
    $out .= theme('cdm_typedesignations', array('typeDesignations' => $type_designations));
  }

  }

  $out .= '</ul>';

  // ------- footnotes ------- //

  // all foonotes of the homotypic group and also of the accepted taxon are
  // rendered here, both should have the same footnote key
  $out .= '<ul class="footnotes">';
  $out .= theme('cdm_annotation_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= theme('cdm_footnotes', array('footnoteListKey' => RenderHints::getFootnoteListKey(), 'enclosingTag' => 'li'));
  $out .= '</ul>';

  $out .= '</div>';


  RenderHints::popFromRenderStack();
  return $out;
}
