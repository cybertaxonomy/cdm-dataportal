<?php
/**
 * @file
 * Page theming functions.
 *
 * @copyright
 *   (C) 2007-2012 EDIT
 *   European Distributed Institute of Taxonomy
 *   http://www.e-taxonomy.eu
 *
 *   The contents of this module are subject to the Mozilla
 *   Public License Version 1.1.
 * @see http://www.mozilla.org/MPL/MPL-1.1.html
 */

/**
 * Returns HTML for the default title of a taxon page.
 *  * The returned title is a formatted taxon name.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon: The taxon name being formatted for the title.
 *   - uuid: UUID for the taxon.
 *
 * @return string
 *  Markup for a taxon page title
 *
 * @ingroup themeable
 */
function theme_cdm_taxon_page_title($variables) {
  $taxon = $variables['taxon'];
  RenderHints::pushToRenderStack('taxon_page_title');
  $referenceUri = '';
  $out = '';
  if (isset($taxon->name->nomenclaturalReference)) {
    $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
  }

  $out .= render_taxon_or_name($taxon, NULL, $referenceUri, FALSE);
  RenderHints::popFromRenderStack();

  return '<span class="' . $taxon->class . '">' . $out . '</span>';
}

/**
 * Returns HTML for the default title of a specimen page.
 *  * The returned title is a the identifier of the specimen.
 *
 * @param array $variables
 *   An associative array containing:
 *   - specimen: The specimen being formatted for the title.
 *
 * @return string
 *  Markup for the title of a specimen page
 *
 * @ingroup themeable
 */
function theme_cdm_specimen_page_title($variables)
{

    $specimen = $variables['specimen'];
    RenderHints::pushToRenderStack('specimen_page_title');
    $referenceUri = '';
    $out = '';

    $collection = null;
    if (!($specimen->class == 'FieldUnit')) {
        if ($specimen->collection) {
            if ($specimen->collection->code) {
                $collection = $specimen->collection->code;
            } elseif ($specimen->collection->name) {
                $collection = $specimen->collection->name;
            }
        }
        if ($specimen->accessionNumber) {
            $specimenID = $specimen->accessionNumber;
        } elseif ($specimen->barcode) {
            $specimenID = $specimen->barcode;
        } elseif ($specimen->catalogNumber) {
            $specimenID = $specimen->catalogNumber;
        } elseif ($specimen->titleCache) {
            $specimenID = $specimen->titleCache;
        }
        if (!isset($specimenID) and !isset($collection)) {
            $specimenID = $specimen->uuid;
        }
    }else{
        if ($specimen->titleCache) {
            $specimenID = $specimen->titleCache;
        }
        if (!isset($specimenID) and !isset($collection)) {
            $specimenID = $specimen->uuid;
        }
    }

    if ($specimen ->class == 'FieldUnit'){
        $out .= "FieldUnit ";
    }else{
        $out .= "Specimen ";
    }

  if($collection){
    $out .= $collection." ";
  }
  $out .= $specimenID;

  RenderHints::popFromRenderStack();

  return '<span class="' . $specimen->class . '">' . $out . '</span>';
}

/**
 * Returns HTML for the default title for a name page.
 *
 * The returned title is a formatted name.
 *
 * @param array $variables
 *   An associative array containing:
 *   - taxon_name: The taxon name object.
 *
 * @return string
 *  Markup for the title of a name page
 *
 * @ingroup themeable
 */
function theme_cdm_name_page_title($variables) {
  $taxon_name = $variables['taxon_name'];
  RenderHints::pushToRenderStack('taxon_page_title');

  $referenceUri = NULL;
  if (isset($taxon_name->nomenclaturalReference)) {
    $referenceUri = url(path_to_reference($taxon_name->nomenclaturalReference->uuid));
  }

  $out = '<span class="' . $taxon_name->class . '">'
    . render_taxon_or_name($taxon_name, NULL, $referenceUri, FALSE)
    . '</span>';
  RenderHints::popFromRenderStack();
  return $out;
}


/**
 * Returns HTML containing the synonymy for the accepted taxon.
 *
 * Shows the whole synonymy for the accepted taxon.
 * The synonymy list is headed by the complete scientific name
 * of the accepted taxon with nomenclatural reference.
 *
 * @param object $taxon
 * @param boolean $add_accepted_taxon
 *
 * @return array
 *  Drupal render array for the synonymy
 *
 * @throws Exception
 *
 * @ingroup compose
 */
function compose_cdm_taxon_page_synonymy($taxon, $add_accepted_taxon) {

  RenderHints::pushToRenderStack('taxon_page_synonymy');

  // footnote key for the homotypic group and accepted taxon,
  // both should have the same footnote key
  RenderHints::setFootnoteListKey(RenderHints::getRenderPath());

  $synomymie = cdm_ws_get(CDM_WS_PORTAL_TAXON_SYNONYMY, array($taxon->uuid));

  $out = '';

  // Render accepted taxon.
  //
  // foonotes of the accepted taxon will be rendered in the homotypic group section
  // even if there are not synonyms in the homotypic group
  // homotypic group and accepted taxon should have the same footnote key
  $referenceUri = '';
  if ($add_accepted_taxon) {
    // remember the last part of the render path
    $synonymy_render_path = RenderHints::getRenderPath();
    // set new render path for the accepted taxon so
    // it can be styled differently via the name render part definitions
    RenderHints::pushToRenderStack('accepted_taxon');
    $accepted_name = '';
    if (variable_get(CDM_SYNONYMY_ACCEPTED_TAXON_SEC_SEPARATE, 0)) {
      $label = variable_get(CDM_SYNONYMY_ACCEPTED_TAXON_SEC_SEPARATE_LABEL, CDM_SYNONYMY_ACCEPTED_TAXON_SEC_SEPARATE_LABEL_DEFAULT);
      $accepted_name .= '<div class="secReference"><span class="label">' . t($label) . ':</span> ' . $taxon->sec->titleCache . '</div>';
    }
    if (isset($taxon->name->nomenclaturalReference)) {
      $referenceUri = url(path_to_reference($taxon->name->nomenclaturalReference->uuid));
    }

    $accepted_name .= '<div class="accepted-name">';
    $accepted_name .= render_taxon_or_name($taxon, NULL, $referenceUri);

    $name_relations = cdm_name_relationships_for_taxon($taxon);
    $name_relationships = render_name_relationships_of($name_relations, $taxon->name->uuid, $taxon->uuid);
    // Render relationships of accepted name.
    if($name_relationships){

      $accepted_name .= ' <span class="name_relationships">' . $name_relationships . '</span>';
    }

      // handle annotations of the name and taxon
    $special_annotations_array = array();
    $special_annotations_array[] = $taxon->name;
    $special_annotations_array[] = $taxon;
    $accepted_name .= theme('cdm_annotations_as_footnotekeys', array(
        'cdmBase_list' => $special_annotations_array,
        'footnote_list_key' => $synonymy_render_path . '-annotations')
      );
    $accepted_name .= '</div>';
    RenderHints::popFromRenderStack();
  }

  // --- Render homotypic synonymy group
  if (!empty($accepted_name)) {
    $out .= $accepted_name;
  }

  // Render the homotypicSynonymyGroup including the type information.
  $out .= theme(
      'cdm_homotypicSynonymyGroup',
      array(
          'synonymList' => $synomymie->homotypicSynonymsByHomotypicGroup,
          'accepted_taxon_name_uuid' => $taxon->name->uuid
      )
    );


  // Render accepted taxon heterotypic synonymy groups.
  if ($synomymie->heterotypicSynonymyGroups) {
    foreach ($synomymie->heterotypicSynonymyGroups as $homotypicalGroup) {
      $out .= theme('cdm_heterotypicSynonymyGroup', array('homotypicalGroup' => $homotypicalGroup));
    }
  }
  // Render taxon relationships.
  if (variable_get(CDM_DATAPORTAL_DISPLAY_TAXON_RELATIONSHIPS, CDM_DATAPORTAL_DISPLAY_TAXON_RELATIONSHIPS_DEFAULT)) {
    $taxonRelationshipsDTO = cdm_ws_get(CDM_WS_PORTAL_TAXON_RELATIONS_DTO, $taxon->uuid);
    $out .= cdm_taxonRelationships($taxonRelationshipsDTO, $taxon);
  }

  RenderHints::popFromRenderStack();

  return markup_to_render_array($out);
}


/**
 * Returns HTML for the given result page including a pager.
 *
 * @param array $variables
 *   An associative array containing:
 *   - pager: The cdmlib pager object containing the result set of cdm base
 *     objects (currently this function can only handle taxon instances =>
 *     TODO)
 *   - path: The target path for the pager links, this will usually point to
 *     'cdm_dataportal/search/results/taxon'
 *
 * @return string
 *  Markup for the result page
 *
 * @throws Exception
 *
 * @ingroup themeable
 */
function theme_cdm_search_taxa_results($variables)
{
  $pager = $variables['pager'];
  $path = $variables['path'];

  $freetextSearchResults = array();

  // If the pager contains records of SearchResults, extract the taxa and use
  // them as records instead.
  if (isset($pager->records[0]) && $pager->records[0]->class == "SearchResult") {
    $freetextSearchResults = $pager->records;
    $taxa = array();
    // $highlightedFragments = array();
    foreach ($pager->records as $searchResult) {
      $taxa[] = &$searchResult->entity;
      /*
       if(!isset($searchResult->fieldHighlightMap)){
      $searchResult->fieldHighlightMap = NULL;
      }
      $fragmentHighlighting[] = $searchResult->fieldHighlightMap;
      */
    }
    $pager->records = $taxa;
  }


  // Add thumbnails checkbox and refine search link.
  $out = '<div class="page_options">';
  if (isset($_REQUEST['ws'])) {
    if (cdm_dataportal_search_form_path_for_ws($_REQUEST['ws'])) {
      $out .= '<div id="backButton">' . l(t('Modify search'), cdm_dataportal_search_form_path_for_ws($_REQUEST['ws'])) . '</div>';
    }
  }
  if (variable_get(SEARCH_RESULTS_SHOW_THUMBNAIL_CHECKBOX, SEARCH_RESULTS_SHOW_THUMBNAIL_CHECKBOX_DEFAULT)) {
    $out .= '<form name="pageoptions"><div id="showThumbnails"><input class="showThumbnails" type="checkbox" name="showThumbnails" ' . (do_showThumbnails() == 1 ? 'checked="checked"' : '') . '> ' . t('Display image thumbnails') . '</div></form>';
  }
  $out .= '</div>';

  $classification = cdm_dataportal_searched_in_classification();


  if (  count(cdm_ws_fetch_all(CDM_WS_PORTAL_TAXONOMY)) > 1 ) { // FIXME use a count REST method for this!!!
    $out .= '<div id="search-summary">' . t('results for') . ' ';
    if ($classification != NULL) {
      $out .=  $classification->titleCache ;
    } else {
     $out .= t('any classification');
    }
    $out .= ':</div>';
  }

  // List results.
  if (isset($pager->records) && count($pager->records) > 0) {
    $out .= '<div id="search_results">';
    $list_of_taxa = compose_list_of_taxa($pager->records, $freetextSearchResults, $classification === NULL);
    $out .= drupal_render($list_of_taxa);
    $out .= '</div>';
    $out .= theme('cdm_pager', array(
        'pager' => $pager,
        'path' => $path,
        'parameters' => $_REQUEST,
    ));
  } else {
    $out .= '<h4 class="error">' . t('Sorry, no matching entries found.') . '</h4>';
  }
  return $out;
}


/**
 * TODO Implementation of Hook taxon_image_gallery()
 *
 * @param object $taxon
 * @param object $media
 *
 * @return string
 *  Markup for the default media gallery
 */
function taxon_image_gallery_default($taxon, $media) {
  $hasImages = isset($media[0]);

  if ($hasImages) {

    $maxExtend = 150;
    $cols = 3;
    $maxRows = FALSE;
    $alternativeMediaUri = NULL;
    /* Comment @WA: was in D5:
    $captionElements = array(
      'title',
      'rights',
      '#uri' => t('Open Image'),
    );
    */
    $captionElements = array(
      'title',
      'description',
      'artist',
      'location',
      'rights',
      '#uri' => t('Open image'),
    );
    $gallery_name = $taxon->uuid;
    $mediaLinkType = 'LIGHTBOX';

    // $gallery_settings = getGallerySettings(CDM_DATAPORTAL_MEDIA_GALLERY_NAME);

    $gallery_settings = getGallerySettings(CDM_DATAPORTAL_TAXON_MEDIA_GALLERY_NAME_TAB);

    $out = '<div class="image-gallerie">';
    $out .= compose_cdm_media_gallerie(array(
      'mediaList' => $media,
      'galleryName' => $gallery_name,
      'maxExtend' => $gallery_settings['cdm_dataportal_media_maxextend'],
      'cols' => $gallery_settings['cdm_dataportal_media_cols'],
      'maxRows' => 0, // Ignore maxrows settings.
      'captionElements' => $captionElements,
      'mediaLinkType' => $mediaLinkType,
      'alternativeMediaUri' => NULL,
      'galleryLinkUri' => NULL,
      'showCaption' => $gallery_settings['cdm_dataportal_show_thumbnail_captions'],
    ));
    $out .= '</div>';
  }
  else {
    $out = 'No images available.';
  }
  return $out;
}

/**
 * TODO Implementation of Hook taxon_image_gallery()
 *
 * @param object $taxon
 * @param object $media
 *
 * @return string
 *  Markup for the fsi media gallery
 *
 * @throws Exception
 */
function taxon_image_gallery_fsi($taxon, $media) {
  $flashLink = isset($media[0]);

  if ($flashLink) {

    if (module_exists("fsi_gallery")) {
      $out = theme("fsi_gallery", array('taxon' => $taxon, 'media' => $media));
    }
    else {
      $message = t('In order to use the FSI gallery you must enable the according ') . l(t("module"), "admin/modules");
      drupal_set_message($message, "error");
      $out = '<h3>' . $message . '</h3>';
    }
  }
  else {
    $out = 'No images available.';
  }
  return $out;
}

/**
 * Returns a drupal render array for a single reference page.
 *
 * Composes a page with all data on a single reference.
 *
 * @param string $uuid
 *   An uuid for a cdm reference.
 *
 * @return array
 *  A drupal render array
 *
 * @throws Exception
 *
 * @ingroup compose
 */
function compose_cdm_reference_page($uuid) {

  $pathelement = "reference_page";
  RenderHints::pushToRenderStack($pathelement);
  $reference = cdm_ws_get(CDM_WS_REFERENCE, $uuid);
  if (isset($reference->titleCache)) {
    drupal_set_title($reference->titleCache, PASS_THROUGH);
  }

  $field_order = array(
    "title",
    "abbrevTitle",
    // "titleCache" abbrevTitleCache
    // "citation",
    "authorship",
    "editor",
    "publisher",
    "placePublished",
    "datePublished",
    "year",
    "edition",// Class Book.
    "volume",// Class Article.
    "seriesPart",
    "inReference",
    "nomRefBase", // Class BookSection, Book, Article.
    "pages",// Class Article.
    "series",// Class Article, PrintSeries.
    "school",// Class Thesis.
    "institution",// Class Report.
    "organization",// Class Proceedings.
    "nextVersion",
    "previousVersion",
    "isbn",// Class Book.
    "issn",// Class Journal.
    "doi",
    "uri"
  );

  $table_rows = array();

  if (!isset($reference->authorship)) {
    $authorship = cdm_ws_get(CDM_WS_REFERENCE_AUTHORTEAM, $reference->uuid);
    $reference->authorship = isset($authorship->titleCache) ? $authorship->titleCache : '';
  }

  if (!isset($reference->inReference)) {
    $reference->inReference = cdm_ws_get(CDM_WS_REFERENCE, array(
      $reference->uuid,
      "inReference",
    ));
  }

  foreach ($field_order as $fieldname) {

    if (isset($reference->$fieldname)) {

      if ($fieldname == "datePublished") {
        $period = $reference->$fieldname;
        $datePublished = timePeriodToString($period);
        if (isset($datePublished) && $datePublished != '') {
          $table_rows[] = array(
            t("Date published"),
            $datePublished,
          );
        }
      }
      elseif ($fieldname == "doi" && is_object($reference->doi)) {
        $table_rows[] = array(
          t('@fieldname', array('@fieldname' => ucfirst(strtolower($fieldname)))),
          cdm_doi($reference->doi, false)
        );
      }
      elseif ($fieldname == "uri" && isset($reference->uri) && $reference->uri) {
        $table_rows[] = array(
          t('@fieldname', array('@fieldname' => ucfirst(strtolower($fieldname)))),
          cdm_external_uri($reference->uri, false)
        );
      }
      elseif (is_object($reference->$fieldname)) {
        if ($fieldname == "authorship") {
          $dump = $reference->$fieldname;
          $teammembers = "teamMembers";
          $team = $dump->$teammembers;
          $nameArray = array();

          foreach ($team as $member) {
            if (strlen($member->lastname) > 0) {
              $nname = $member->lastname;
              $name = $nname;
              if (strlen($member->firstname) > 0) {
                $vname = $member->firstname;
                $name = $vname . " " . $nname;
              }
              $nameArray[] = $name;
            }
            else {
              if (strlen($member->titleCache) > 0) {
                $nameArray[] = $member->titleCache;
              }
            }
          }
          $value = join($nameArray, ", ");
        }
        elseif ($fieldname == "inReference") {
          $type = $reference->$fieldname->type;
          $value = l($reference->$fieldname->titleCache, path_to_reference($reference->$fieldname->uuid));
          switch ($type) {
            case "Book":
              $fieldname = "in book";
              break;
            case "Journal":
              $fieldname = "in journal";
              break;
            case "Proceedings":
              $fieldname = "in proceedings";
              break;
          }
        }
        else {
          $value = $reference->$fieldname->titleCache;
        }


        if (isset($value) && $value != '') {
          $table_rows[] = array(
            t('@fieldname', array('@fieldname' => ucfirst(strtolower($fieldname)))),
            $value,
          );
        }

      }
      else {
        if (isset($reference->$fieldname) && $reference->$fieldname != '') {
          $table_rows[] = array(
            t('@fieldname', array('@fieldname' => ucfirst(strtolower($fieldname)))),
            $reference->$fieldname,
          );
        }
      }
    }
  }

  $out = theme_table(array(
      'header' => array(),
      'rows' => $table_rows,
      'attributes' => array(
        'class' => html_class_attribute_ref($reference)
      ),
      'caption' => NULL,
      'colgroups' => NULL,
      'sticky' => NULL,
      'empty' => NULL,
  ));

  if(isset($reference->referenceAbstract)){
    $out .= '<h2 class="block-title">Abstract</h2><div class="abstract">' . $reference->referenceAbstract . '</div>';
  }


  // Annotations below the table
  $annotations = cdm_fetch_visible_annotations($reference);
  $out .= theme("cdm_annotations", array('annotations' => $annotations));

  $registration_working_set = cdm_ws_get("registrationWorkingSetDTO", array($uuid));
  if($registration_working_set && count($registration_working_set->registrationDTOs) > 0){
    $out .= "<h3>Nomenclatural acts:</h3><div class=\"cdm-item-list registration-item-list\">";
    foreach($registration_working_set->registrationDTOs as $registration_dto){
      if($registration_dto->status == "PUBLISHED"){
        $registration_render_a = compose_registration_dto_compact($registration_dto, 'citation');
        $registration_render_a["#prefix"] = "<div class=\"item item-registration\">";
        $registration_render_a["#suffix"] = "</div>";
        $out .= drupal_render($registration_render_a);
      }
    }
    $out .= "</div>";
  }

  RenderHints::popFromRenderStack();

  return markup_to_render_array($out);
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_media_page($variables) {

  $media = $variables['media'];
  $mediarepresentation_uuid = $variables['mediarepresentation_uuid'];
  $partId = $variables['partId'];
  $out = '';

  // Determine which representation and which part to show
  $active_representation_index = 0;

  if (!$mediarepresentation_uuid) {
    // no representation requested by the method parameters, find the best one
    $representations = cdm_preferred_media_representations($media, array('image/png', 'image/jpeg', 'image/gif'), null, null);
    if($representations  && count($representations) > 0){
      $preferred_representation = array_shift($representations);
      $mediarepresentation_uuid = $preferred_representation->uuid;
    }
  }

  if($mediarepresentation_uuid){
    foreach ($media->representations as $representation) {
      if ($representation->uuid == $mediarepresentation_uuid) {
        break;
      }
      $active_representation_index++;
    }
  }


  $active_part_index = 0;
  if (is_uuid($partId)) {
    foreach ($media->representations[$active_representation_index]->parts as $part) {
      if ($part->uuid == $partId) {
        break;
      }
      $active_part_index++;
    }
  }
  else if(is_numeric($partId)){
    $active_part_index = $partId;
  }

  $media_metadata = read_media_metadata($media);
  // $title = $media->titleCache;
  $title = $media_metadata['title'];

  $imageMaxExtend = variable_get('image-page-maxextend', 400);

  if (!$title) {
    $title = 'Media ' . $media->uuid . '';
  }

  drupal_set_title($title, PASS_THROUGH);

  $out .= '<div class="media cdm_media_viewer_image">';

  if(preg_match('/cdm_dataportal\/taxon\//', $_SERVER['HTTP_REFERER']) ){
    if(variable_get('cdm_dataportal_taxonpage_tabs', 1)){
      // taxon page with tabs
      $out .= '<div id="backToGalleryButton">' . l(t('Back to images'), $_SESSION['cdm']['last_gallery']) . '</div>';
    } else {
      // tabless mode
      $out .= '<div id="backToGalleryButton">' . l(t('Back to taxon page'), $_SESSION['cdm']['last_gallery']) . '</div>';
    }
  }
  $out .= '<div class="viewer">';
  $out .= cdm_openlayers_image($media->representations[$active_representation_index]->parts[$active_part_index], $imageMaxExtend);
  $out .= '</div>';

  // General media metadata.
  $metadataToPrint = theme('cdm_media_caption', array('media' => $media, 'sources_as_content' => true));
  $out .= $metadataToPrint;

  $cdm_standard_image_viewer_settings = get_array_variable_merged(CDM_STANDARD_IMAGE_VIEWER, CDM_STANDARD_IMAGE_VIEWER_DEFAULT);
  if ($cdm_standard_image_viewer_settings['media_representation_details_enabled'] == 1){
    // Tabs for the different representations.
    // Representation(-part) specific metadata.
    $thumbnailMaxExtend = 100;
    $out .= '<h3>' .t('Media representations') .'</h3><ul id="media-representations">';
    $r_i = 0;
    foreach ($media->representations as $representation) {
      $out .= '<li><strong>'. t('Representation') . ' ' . $r_i . "</strong> ($representation->mimeType)" ;
      // parts
      $active_part_index = 0;
      $table_class_attribute = '';
      if($partIdx == $active_part_index && $active_representation_index == $r_i ){
        $table_class_attribute = 'class="active"';
      }
      $out .= "<table $table_class_attribute>";
      foreach ($representation->parts as $part) {
        $out .= '<tr><th>' . t('Part') . ' ' . ($active_part_index + 1) . '</th></tr><tr><td>';
        switch ($part->class) {
          case 'ImageFile':
            $out .= $part->width . 'x' . $part->height . ' px - ' . $part->size . ' kB';
            break;
          case 'AudioFile':
          case 'MovieFile':
            $out .= t('Duration') . ': ' . $part->duration . 's - ' . $part->size . ' kB';
            break;
          default:
            $out .= $part->size . 'k';
        }

        $out .= '</td><td><a href="' . url(path_to_media($media->uuid, $representation->uuid, $active_part_index)) . '">'
          . cdm_media_gallerie_image($part, $thumbnailMaxExtend, TRUE);
        $active_part_index++;
      }
      $out .= '</table>';
      $out .=  '</li>';
      $r_i++;
    }
    $out .= '</ul>';
  }

  $out .= '</div>';
  return $out;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_cdm_polytomousKey_page($variables) {
  $polytomousKey = $variables['polytomousKey'];
  drupal_set_title($polytomousKey->titleCache, PASS_THROUGH);

  $out = theme("cdm_IdentificationKey", array(
    'identificationKey' => $polytomousKey,
    'doLinkToKeyPage' => FALSE,
    'showIdentificationKeyTitle' => FALSE,
    ));

  // Key nodes in linked style.
  $out .= theme('cdm_polytomousKey', array('polytomousKey' => $polytomousKey));
  /*
   * FIXME implement node type for keys !!!
   * (wrapping the content in the cdm_dataportal.node becomes obsolete then).
   */
  return '<div id="identificationKey">' . $out . '</div>';
}