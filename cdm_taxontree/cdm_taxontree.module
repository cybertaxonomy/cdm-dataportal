<?php
// $Id$

/*
 * @file
 * cdm_taxontree.module
 *
 * Copyright (C) 2007 EDIT
 * European Distributed Institute of Taxonomy
 * http://www.e-taxonomy.eu
 */



/**
 * Implementation of hook_menu()
 */
function cdm_taxontree_menu($may_cache) {

	$items = array();
	if ($may_cache) {

		$items[] = array(
          'path' => 'cdm_taxontree/set',
          'callback' => 'cdm_taxontree_set',
          'access' => true,
          'type' => MENU_CALLBACK,
		);

		$items[] = array(

          'path' => 'cdm_taxontree/filter',
          'callback' => 'cdm_taxontree_view_filter',
          'access' => true,
          'type' => MENU_CALLBACK,
		);

		$items[] = array(
          'path' => 'cdm_taxontree/taxonomy/children',
          'callback' => 'cdm_taxontree_taxonomy_children',
          'access' => true,
          'type' => MENU_CALLBACK,
		);

	} else {

		//      DISABLED since the taxontree-widged is no longer being used!!!
		//
		//      if(variable_get('cdm_taxontree_cache', 0)){
		//    		$items[] = array('path' => 'admin/settings/cdm_dataportal/clear_cache',
		//          'title' => t('Empty CDM Taxontree Cache'),
		//          'callback' => 'cdm_taxontree_cache_clear',
		//          'access' => user_access('administer cdm_dataportal'),
		//          'weight' => 2,
		//          'type' => MENU_NORMAL_ITEM,
		//    		);
		//      }

	}
	return $items;
}

/**
 * Implementation of hook_block()
 *
 * @param String $op
 * @param int $delta
 */
function cdm_taxontree_block($op='list', $delta=0, $edit = array()) {
	if ($op == "list") {
		$block['cdm_tree']["info"] = t('CDM taxon tree');
		$block['filters']["info"] = t('Active filters');
		$block[1]["info"] = t('Drupal taxonomy tree');
		return $block;
	}
	else if ($op == 'view') {
		switch($delta){
			case 'cdm_tree':
				$block['subject'] = t('Classification');
				$taxonUuid_inFocus = _cdm_get_taxonuuid();
				$tree = cdm_taxontree_build_tree($taxonUuid_inFocus);
				$magicbox_enable = variable_get('cdm_taxontree_magicbox_enable', 0);

				if(count(cdm_get_taxontrees_as_options()) > 1){
					$block['content'] = cdm_taxonomictree_selector();
				}
				$block['content'] .= theme('cdm_taxontree_block', $tree, $delta, FALSE, FALSE /*, 'cdm_taxontree_node_concept_switch'*/);
				// java script
				$verticalSroller = $magicbox_enable ? 'cdm_taxontree_scroller_x' : 'cdm_taxontree_scroller_xy';
				theme('cdm_taxontree_add_scripts');
				drupal_add_js('
        if (Drupal.jsEnabled) {
        $(document).ready(function()
        {
          $(\'ul.cdm_taxontree\').cdm_taxontree();
          $(\'div.'.$verticalSroller.'\').scrollTo($(\'.focused\'), 400, {over:-3});});
        }', 'inline');
				return $block;

			case 'filters':
				$block['subject'] = t('Active filters');
				$block['content'] = cdm_taxontree_view_filter('list');
				return $block;

			case 1:
				$block['subject'] = t('Taxonomy tree');
				$term_inFocus = arg(0) == 'taxonomy' && arg(1) == 'term' ? arg(2) : 0;
				$tree = cdm_taxontree_build_tree($term_inFocus, true, variable_get('cdm_taxontree_block_1_vid', 0));
				$block['content'] = theme('cdm_taxontree_block', $tree, $delta, FALSE);
				theme('cdm_taxontree_add_scripts');
				drupal_add_js('
        if (Drupal.jsEnabled) {
        $(document).ready(function()
        {
          $(\'ul.cdm_taxontree\').cdm_taxontree();
          $(\'div.cdm_taxontree_scroller_x\').scrollTo($(\'.active\'), 400, {over:-3});});
        }', 'inline');

				return $block;
		}
	} else if ($op == 'configure') {
		switch($delta){
			case 1:
				$vocs = taxonomy_get_vocabularies();
				$options = array();
				foreach($vocs as $voc){
					$options[$voc->vid] = $voc->name;
				}
				$form['vid'] = array(
            '#type' => 'select',
            '#title' => t('Category'),
            '#default_value' => variable_get('cdm_taxontree_block_1_vid', 0),
            '#options' => $options,
				);
				return $form;
		}
	} else if ($op == 'save') {
		switch($delta){
			case 1:
				variable_set('cdm_taxontree_block_1_vid', $edit['vid']);
				return;
		}
	}
}

/**
 * Implementation of hook_help().
 *
 * @param unknown_type $section
 * @return unknown
 */
function cdm_taxontree_help($section) {
	switch ($section) {
		case 'admin/modules#description':
			return t('Defines a selection widget for massive taxonomy structures.');
	}
}

/**
 * Implementation of hook_field_info().
 */
function cdm_taxontree_field_info() {
	return array(
    'cdm_taxontree' => array('label' => 'CDM Taxontree'),
	);
}



function cdm_taxontree_field_formatter_info() {
	return array(
    'default' => array(
      'label' => t('Default'),
      'field types' => array('cdm_taxontree'),
	),
    'link' => array(
      'label' => t('With link'),
      'field types' => array('cdm_taxontree'),
	),
	);
}



/*
 * formatters to prepare the correct links for taxa
 */
function cdm_taxontree_field_formatter($field, $item, $formatter, $node) {
	switch ($formatter) {
		case 'link':
			$term = taxonomy_get_term($item['tid']);
			$taxa = db_result(db_query('SELECT name FROM {vocabulary} WHERE vid = %d', $term->vid));
			switch($taxa){
				case 'Taxonomy':
					$link = 'interest_by_taxonomy/';
					break;
				case 'Georegion':
					$link = 'interest_by_georegion/';
					break;
				default:
					$link = 'taxonomy/term/';
			}
			return l($term->name, $link.$term->tid);

		default:
			$name = db_result(db_query('SELECT name FROM {term_data} WHERE tid = %d', $item['tid']));
			return $name;
	}
}


/**
 * Transforms an unpredictably and irregularly nested set of tids (as returned
 * from a taxonomy form) into a linear array of tids.
 * borrow from taxonomy_browser.module
 */
function _cdm_taxontree_get_all_children($tids = null, $include_children = false) {
	static $tid_list;

	if (isset($tids) && is_array($tids)) {
		$tid_list = array();
		foreach ($tids as $key => $tid) {
			if (!empty($tid)) {
				if (is_array($tid)) {
					foreach ($tid as $key2 => $tid2) {
						if (!empty($tid2)) {
							$tid_list[$tid2] = $tid2;
						}
					}
				}
				else {
					$tid_list[$tid] = $tid;
				}
			} /* end !empty */
		} /* end foreach */
	}

	if ($include_children) {
		foreach ($tid_list as $tid) {
			_cdm_taxontree_get_children($tid_list, $tid);
		}
	}

	return $tid_list;
}

function _cdm_taxontree_get_children(&$tid_list, $tid) {
	$child_nodes = taxonomy_get_children($tid);
	if (!empty($child_nodes)) {
		foreach ($child_nodes as $child_tid => $child_term) {
			$tid_list[$tid] = $tid;
			_cdm_taxontree_get_children($tid_list, $child_tid);
		}
	}
	else {
		$tid_list[$tid] = $tid;
	}
}

function cdm_taxontree_set($key, $value){

	if(is_string($key)){
		$_SESSION['cdm']['taxontree'][$key] = $value;
	}

	if($_REQUEST['destination']){
		$destination = $_REQUEST['destination'];
		unset($_REQUEST['destination']);
		drupal_goto($destination);
	}
}


/**
 * Enter description here...
 *
 * @param UUID $secUuid
 * @return unknown
 */
function cdm_taxontree_secRefTitle_for($secUuid){

	$reference = cdm_api_secref_cache_get($secUuid);
	if($reference){
		$cit = $reference->titleCache;
	} else {
		$cit = '[no title for:'.$secUuid.']';
	}
	return $cit;
}



/**
 * Queries the Drupal database for the location of a certain block with the given $delta
 *
 * @param [String | Number] $delta
 * @return values (left |Â right | <empty>)
 */
function _get_block_region($delta){
	global $user, $theme_key;

	$result = db_fetch_array(db_query("SELECT DISTINCT b.region FROM {blocks} b LEFT JOIN {blocks_roles} r ON b.module = r.module AND b.delta = r.delta WHERE b.theme = '%s' AND b.status = 1 AND (r.rid IN (%s) OR r.rid IS NULL) AND b.module = '%s' AND b.delta = '%s'", $theme_key, implode(',', array_keys($user->roles)), 'cdm_taxontree', $delta));
	return $result['region'];
}

/**
 * Enter description here...
 *
 * @return unknown
 */
function _get_compact_mode(){

	if(!isset($_SESSION['cdm']['taxontree']['compact_mode'])){
		$_SESSION['cdm']['taxontree']['compact_mode'] = 'expanded';
	}
	return  $_SESSION['cdm']['taxontree']['compact_mode'];
}


/**
 * Converts an array of drupal taxonomy terms into an
 * array of partially instantiated cdm tree nodes by adding the fields
 * relevant for tree node processing in cdm_taxontree
 *
 *
 * term       =>      cdm tree node
 * ------------------------------------
 * tid       ->     uuid
 name      ->     titleCache
 taggedName
 secUuid
 isAccepted
 taxonomicChildrenCount
 alternativeConceptRefs
 *
 * @param unknown_type $terms
 */
function cdm_taxontree_terms2treenodes(&$terms){
	foreach($terms as &$term){
		$term->uuid = $term->tid;
		$term->titleCache = $term->name;
		$term->taxonomicChildrenCount = count(taxonomy_get_children($term->tid, $term->vid));
	}
	return $terms;
}

/**
 * Enter description here...
 *
 * @param unknown_type $tid
 * @param unknown_type $vid
 * @param unknown_type $theme
 */
function cdm_taxontree_taxonomy_children($tid, $vid, $theme){
	$args = func_get_args();
	$tid = array_shift($args);
	$vid = array_shift($args);
	$theme = array_shift($args);

	$children = cdm_taxontree_get_children($tid, $vid);
	$children = cdm_taxontree_terms2treenodes($children);
	array_unshift($args, $theme, $children);
	print call_user_func_array('theme', $args);
}

/**
 * Enter description here...
 *
 * @param unknown_type $vid
 * @param unknown_type $secRefUuuid
 * @return unknown
 */
function cdm_taxontree_get_root($vid = null){
	if(is_numeric($vid)){
		// vid, $parent = 0, $depth = -1, $max_depth = NULL) {
		$terms = taxonomy_get_tree($vid, 0, -1, 1);
		return cdm_taxontree_terms2treenodes($terms);
	} else {
		return cdm_ws_taxonomy();
	}
}

/**
 * Enter description here...
 *
 * @param unknown_type $uuid
 * @param unknown_type $vid
 * @return unknown
 */
function cdm_taxontree_get_children($uuid, $vid = null){

	if(is_numeric($vid)){
		$terms = taxonomy_get_children($uuid, $vid);
		return cdm_taxontree_terms2treenodes($terms);
	} else {
		//FIXME replace $uuid by path of parent $uuids

		return cdm_ws_taxonomy($uuid);
	}
}

/**
 * Enter description here...
 *
 * @param unknown_type $uuid
 * @return unknown
 */
function cdm_taxontree_get_parents($uuid){

	if(!is_uuid($uuid)){
		// using Drupal taxonomy
		$terms = taxonomy_get_parents($uuid);
		array_push($terms, taxonomy_get_term($uuid));
		$terms = array_reverse($terms);
		return cdm_taxontree_terms2treenodes($terms);
	} else {
		// using cdm
		$terms = cdm_ws_taxonomy_pathFromRoot($uuid);
		if(!$terms){
			return;
		}
		$terms = array_reverse($terms);
		return $terms;
	}
}

/**
 * builds a tree of TaxonNode instances, whereas the instances are extended by some fields:
 *
 *  - $node->filter: values ( 'on', 'excluded', 'included' )
 *  - $node->expanded: values ( 'expanded', 'collapsed' )
 *    $node->focused: values ( TRUE, FALSE )
 *
 * @param unknown_type $taxonUuid
 * @return unknown
 */
function cdm_taxontree_build_tree($taxonUuid = null, $hideOtherConcepts = true, $vid = null){
	//TODO remove $hideOtherConcepts from method signature

	if(is_null($vid)){

		if($taxonUuid){
			$taxon =  cdm_ws_get(CDM_WS_PORTAL_TAXON, $taxonUuid);
		}

		$compact_tree = cdm_taxontree_filters_active() && _get_compact_mode() != 'expanded';
	}
	/* valid compact_modes: 'expanded', 'compact', 'flattened' */

	// get the root level
	$root_tree = cdm_taxontree_get_root($vid);
	//  if(!$root_tree || !is_array($root_tree)){
	//    return array();
	//  }
	$root_tree = _cdm_resultset2nodelist($root_tree, cdm_taxontree_filters_active());


	if(cdm_taxontree_filters_active()){
		// the paths up to active filters are inactive in the user interface and
		// thus cannot be browsed by expanding nodes
		// therefore we need to build up the branches for all nodes which are set as filters
		// the branches are merged with the root
		foreach(cdm_taxontree_filters_get() as $uuid=>$filter){
			$branch = cdm_taxontree_build_path($uuid, TRUE, ($compact_tree === false ? true :null));
			$root_tree = _cdm_taxontree_merge($root_tree, $branch);
		}
	}

	// build the the branch for the focused node and merge it with the root
	if($taxonUuid){
		$branch = cdm_taxontree_build_path($taxonUuid, NULL, (cdm_taxontree_filters_active() ? NULL : TRUE), TRUE);
		$root_tree = _cdm_taxontree_merge($root_tree, $branch);
	}

	//reorder siblings & populate expanded nodes with children and propagate the filter attribute
	$root_tree = cdm_taxontree_populate($root_tree, $compact_tree === false);

	// flatten tree
	if($compact_tree){
		if( _get_compact_mode() == 'flattened'){
			$root_tree = cdm_taxontree_flatten($root_tree);
		} else if(_get_compact_mode() == 'compact') {
			foreach($root_tree as $uuid => $node){
				if( $node->filter == 'excluded' && !$node->children){
					unset($root_tree[$uuid]);
				}
			}
		}
	}

	return $root_tree;
}

/**
 * Builds the specific branch path for $taxonUuid.
 * The branch path reaches from the parent root node of $taxonUuid up to $taxonUuid.
 *
 * @param UUID $taxonUuid
 * @param Boolean $is_filter_path whether the upmost node of this path is mapped by an active filter
 * @param Boolean $is_expanded whether all nodes along the tree are expanded
 * @param Boolean $is_focused whether to upper most element of this branch is set as filter
 * @return a subtree
 */
function cdm_taxontree_build_path($taxonUuid, $is_filter_path = null, $is_expanded = null, $is_focused = FALSE){

	$branch_path = array();

	$parents = cdm_taxontree_get_parents($taxonUuid);
	if(!$parents){
		if($is_filter_path){
			// remove invalid filter
			cdm_taxontree_filters_remove($taxonUuid);
		}
		return false;
	}

	$parents = _cdm_resultset2nodelist($parents, NULL);
	$lastParent = null;
	foreach($parents as $pnode){
		$pnode->focused = false; //TODO to be relaced by ($pnode->taxonUuid == $taxonUuid); ?? compare usage of $is_focused
		if($lastParent){
			$pnode->children = array($lastParent->taxonUuid => $lastParent);
			if(!is_null($is_filter_path)){
				$pnode->filter = ($is_filter_path ? 'excludes' : 'included');
			}
			if(!is_null($is_expanded)){
				$pnode->expanded = ($is_expanded ? 'expanded' : 'collapsed');
			}
		} else {
			// the uppermost node of branch
			if(!is_null($is_filter_path)){
				$pnode->filter = ($is_filter_path ? 'on' : 'includes');
			}
			// uppermost node is always expanded if it has children
			$pnode->focused = $is_focused;
			$pnode->expanded = ($pnode->taxonomicChildrenCount ? 'expanded' : 'collapsed');
		}
		$lastParent = $pnode;
	}
	$branch_path[$pnode->taxonUuid] = $pnode;
	return $branch_path;
}

/**
 * Performs two steps on each level of the tree:
 *  1. reorder siblings except root (is expected to be ordered jet) alphabetically
 *  2. populate children of expanded nodes  & propagate the filter attribute
 *
 * @param unknown_type $tree
 * @return unknown
 */
function cdm_taxontree_populate($tree, $expand_excluded, $filter_default = null){

	if(!is_array($tree)){
		return false;
	}
	foreach(array_keys($tree) as $uuid){

		if(!isset($tree[$uuid]->filter) && !is_null($filter_default)){
			$tree[$uuid]->filter = $filter_default;
		}

		if( $tree[$uuid]->expanded == 'expanded' && ($expand_excluded || $tree[$uuid]->filter != 'excluded')){
			$children = cdm_taxontree_get_children($uuid, $tree[$uuid]->vid);
			$children = _cdm_resultset2nodelist($children, ($tree[$uuid]->filter == 'excludes'));

			// store the children of the node for later processing
			if(is_array($tree[$uuid]->children)){
				$pnode_children = $tree[$uuid]->children;
			} else {
				$pnode_children = false;
			}
			// replace the children by the newly retrieved child nodes
			$tree[$uuid]->children = $children;

			if($pnode_children){
				// recurse into the childtree which was stored before
				$pnode_children =  cdm_taxontree_populate($pnode_children, $expand_excluded ,$tree[$uuid]->filter);
				// recombine
				foreach($pnode_children as $childUuid=>$cnode){
					$tree[$uuid]->children[$childUuid] = $cnode;
				}
			}
		} else {
			// reorder nodes which are not expanded, expanded nodes are reordered implicitly above
			if(isset($tree[$uuid]->children) && count($tree[$uuid]->children) > 1) {
				// copy the children into an array which can be sorted by its keys
				$ordered = array();
				foreach($tree[$uuid]->children as $cnode){
					// concatenate full name and uid
					$reordered[str_pad($cnode->titleCache, 255, '-').$cnode->taxonUuid] = $cnode;
				}
				// sort
				ksort($reordered);
				// move the children back into the parent node
				$tree[$uuid]->children = array();
				foreach($reordered as $cnode){
					$tree[$uuid]->children[$cnode->taxonUuid] = $cnode;
				}
			}
			$tree[$uuid]->children = cdm_taxontree_populate($tree[$uuid]->children, $expand_excluded, $tree[$uuid]->filter);
		}
	}
	return $tree;
}

/**
 * Enter description here...
 *
 * @param unknown_type $tree
 * @param unknown_type $new_root
 * @return unknown
 */
function cdm_taxontree_flatten($tree, &$new_root = null){
	if(!$new_root){
		$new_root = array();
	}
	foreach($tree as $node){
		if($node->filter == 'on'){
			$new_root[$node->taxonUuid] = $node;
		} else if(is_array($node->children)){
			cdm_taxontree_flatten($node->children, $new_root);
		}
	}
	return $new_root;
}


/**
 * Merge a branch into a tree whereas the tree dominated the branch except
 * nodes having property filter set to "on". These always dominate
 * nevertheless if they are in tree or branch.
 *
 * @param unknown_type $tree the dominant tree
 * @param unknown_type $branch the tree to be merged in
 * @return the merged $tree
 */
function _cdm_taxontree_merge($tree, $branch) {

	if(!$branch){
		return $tree;
	}

	foreach(array_keys($tree) as $uuid) {
		// check if node exists in $branch
		if(!empty($branch[$uuid])) {
			// preserve filter property
			if(isset($tree[$uuid]->filter) && !(isset($branch[$uuid]->filter) && $branch[$uuid]->filter == 'on') ){
				$branch[$uuid]->filter = $tree[$uuid]->filter;
			} else if(isset($branch[$uuid]->filter)){
				$tree[$uuid]->filter = $branch[$uuid]->filter;
			}
			// preserve expanded property
			if(isset($tree[$uuid]->expanded)){
				$branch[$uuid]->expanded = $tree[$uuid]->expanded;
			} else if(isset($branch[$uuid]->expanded)){
				$tree[$uuid]->expanded = $branch[$uuid]->expanded;
			}
		  // preserve focused property
      if(isset($tree[$uuid]->focused)){
        $branch[$uuid]->focused = $tree[$uuid]->focused;
      } else if(isset($branch[$uuid]->focused)){
        $tree[$uuid]->focused = $branch[$uuid]->focused;
      }
			// $Uuid exists check if the node in tree1 or tree2 contains children
			if(is_array($branch[$uuid]->children) && is_array($tree[$uuid]->children)) {
				// merge recursive
				$tree[$uuid]->children = _cdm_taxontree_merge($tree[$uuid]->children, $branch[$uuid]->children);
			} else if(is_array($branch[$uuid]->children)){
				$tree[$uuid] =  $branch[$uuid];
			}
			unset($branch[$uuid]);
		}
	}
	// append remaining items from branch to tree
	foreach(array_keys($branch) as $uuid){
		$tree[$uuid] =  $branch[$uuid];
	}
	return $tree;
}


/**
 * Replaces the keys of an array of TreeNode instances
 * by the $treenode->taxonUuid of the single array elements.
 * An sets additional fields
 *
 * @param $resultset array of TreeNode instances as +returned by the cdm web service
 * @param $excluded  whether the $resultset is included by a active filter. Is ignored if NULL.
 * @param $expanded  whether the children of the nodes in the $resultset are expanded or not. Is ignored if NULL.
 */
function _cdm_resultset2nodelist($resultset, $excluded = null, $expanded = null){

	if(! is_array($resultset)) {
		return false;
	}

	$tree = array();
	foreach($resultset as $treeNode){
		if(!is_null($excluded)){
			$treeNode->filter = ($excluded ? 'excluded': 'included');
		}
		if(!is_null($expanded)){
			$treeNode->expanded = ($expanded ? 'expanded': 'collapsed');
		}
		$tree[$treeNode->taxonUuid] = $treeNode;
	}
	return $tree;
}


// ------------------------ THEME --------------------------- //


function theme_cdm_taxontree_add_scripts(){
	$path_cdm_taxontree = drupal_get_path('module', 'cdm_taxontree');
	$path_preferred_module = drupal_get_path('module', 'cdm_dataportal') ? drupal_get_path('module', 'cdm_dataportal') : $path_cdm_taxontree;
	drupal_add_css($path_cdm_taxontree.'/cdm_taxontree.css');
	drupal_add_js($path_preferred_module.'/js/jquery.dimensions.js');
	drupal_add_js($path_cdm_taxontree.'/js/cdm_taxontree.js');
	drupal_add_js($path_cdm_taxontree.'/js/jquery.scrollTo.js');
}


/**
 * @param $tree 				the tree of TreeNode to be displayed
 * @param $magicbox 			if true, the tree will be embedded into a set of div tags which allow the
 *            					tree to expand and overlap other content. This is useful if the node titles are
 *            					quite long or if the tree is nested deeply.
 *            					If $magicbox ist set to the delta of the containing block the direction into which the
 *            					box expands is dependent on the region in which the blockis located.
 *            					See also Variable $left_expand_region in this function!
 * @param $show_filter_switch 	The tree can offer buttons to add a node to a set of filters
 *            					which can then be applied to the tree to limit the visible subtrees and thus
 *            					to compact the tree. Three different compact modes are available.
 * @param $tree_node_callback 	name of a callback method which will be called for each node
 *            					in theme_cdm_taxontree_node(). The output of this callback, which takes the
 *            					$node object as single arument, is appended to the end of the redered node.
 */
function theme_cdm_taxontree_block($tree, $delta, $magicbox = false, $show_filter_switch = false, $tree_node_callback = false){

	// THEMERS: change the line below according the specific regions of your theme
	$left_expand_region = 'right';

	$out = '';
	if(cdm_taxontree_filters_active()){
		$out .= theme('cdm_taxontree_contoller', _get_compact_mode());
	}
	if($magicbox){
		if(is_numeric($magicbox) || is_string($magicbox)){
			$region = _get_block_region($magicbox);
		}
		// the magicbox expands to the right by default,
		// if the class 'expand-left' to  the cdm_taxontree_scroller_x the box will expand to the left
		$expand_direction = $region == 'right' ? 'expand-left' : '';
		$out .= '<div class="cdm_taxontree_scroller_x '.$expand_direction.'"><div class="cdm_taxontree_container"><div class="cdm_taxontree_scroller_y">';
	} else {
		$out .= '<div class="cdm_taxontree_scroller_xy">';
	}

	$out .= theme('cdm_taxontree', $tree, !cdm_taxontree_filters_active(), $show_filter_switch , $tree_node_callback);

	if($magicbox){
		$out .= '</div></div></div>';
	} else {
		$out .= '</div>';
	}
	return $out;
}

function theme_cdm_taxontree_contoller($compact_mode){

	static $modes = array('expanded', 'compact', 'flattened');

	$out = '<div class="settings">';
	foreach($modes as $mode){
		if($compact_mode == $mode){
			$out .= t($mode);
		} else {
			$out .= l(t($mode), 'cdm_taxontree/set/compact_mode/'.$mode, array(), drupal_get_destination());
		}
		$out .= ' ';
	}

	return $out.'</div>';
}

function theme_cdm_taxontree($tree, $filterIncludes = null, $show_filter_switch = false, $tree_node_callback = false, $element_name = false){

	if(!is_array($tree)) {
		//    $out = '<ul class="cdm_taxontree">';
		//    $out .= '<li>----------------------------NO TREE---------------------------------------</li>';
		//    $out .= '</ul>';
		//    return $out;
		return false;
	}

	if(is_null($filterIncludes)){
		// set $filterIncludes true if no filters are set.
		$filterIncludes = !cdm_taxontree_filters_active();
	}

	// append element name to get multiple taxontrees on one page working
	$out = '<ul class="cdm_taxontree' . (($element_name) ? ' ' . $element_name : '') . '">';
	foreach($tree as $node){
		$out .= theme('cdm_taxontree_node', $node, $filterIncludes, $show_filter_switch, $tree_node_callback);
	}
	$out .= '</ul>';
	return $out;
}

function theme_cdm_taxontree_node($node, $filterIncludes, $show_filter_switch = false, $tree_node_callback = false){

	$is_leaf = !$node->taxonomicChildrenCount || $node->taxonomicChildrenCount == 0;
	$is_expanded = isset($node->expanded) && $node->expanded = 'expanded';
/*
if($node->taxonUuid == '1a0bb171-9461-4713-b98d-d0a5f03dfcb1'){
}
*/
	if($node->tid){
		$node_name = $node->name;
		$path = "taxonomy/term/".$node->tid;
		// disable filterswitch
		$show_filter_switch = false;

	} else if(module_exists('cdm_dataportal')){
		$node_name = cdm_dataportal_shortname_of($node);
		$path = path_to_taxon($node->taxonUuid);
	} else {
		$node_name = "module cdm_dataportal missing";
		$path = "";
	}

	if($filterIncludes){
		$name = l($node_name, $path);
		// no names for terms in filter widget; as discussed with A. MÃ¼ller
		//$name = '';

		$filter_class = 'filter_included';
	} else {
		if($node->filter == 'on') {
			$name = l($node_name,  $path);
			$filter_class = 'filter_on';
		} else {
			$name .= $node_name;
			$filter_class = 'filter_excluded';
		}
	}
	$nextLevelIncluded = $node->filter == 'on' || $filterIncludes;

	$ahah_url = false;
	if(!$is_leaf && !$is_expanded && $filter_class != 'filter_excluded'){
		if($node->tid){
			$ahah_url = url('cdm_taxontree/taxonomy/children/'.$node->tid.'/'.$node->vid.'/cdm_taxontree/'.($nextLevelIncluded ? 1 : 0).'/'.($show_filter_switch ? 1 : 0).'/'.$tree_node_callback);
		} else if(module_exists('cdm_dataportal')) {
			$ws_url = cdm_compose_taxonomy_path($node->taxonUuid);
			$ahah_url = url('cdm_api/proxy/'.urlencode($ws_url).'/cdm_taxontree/'.($nextLevelIncluded ? 1 : 0).'/'.($show_filter_switch ? 1 : 0).'/'.$tree_node_callback);
		}
	}

	// list item
	$out = '<li class="'
	.($node->focused ? 'focused ' : '')
	.($is_leaf ? 'leaf ':($is_expanded ?'expanded ':'collapsed '))
	.$filter_class.'"'
	.($ahah_url ? 'ref="'.$ahah_url.'"' : '')
	.'>';


	if($show_filter_switch){
		// filter icon
		$out .= theme('cdm_taxontree_node_filter_switch', $node, $filter_class);
	}

	// taxon name
	$out .= $name;

	// concept_switch or other theme callbacks
	if($tree_node_callback){
		$out .= theme($tree_node_callback, $node);
	}

/*
	foreach ($node->children as $element){
		$nameStr = '';
		foreach($element->taggedTitle as $tagtxt){
			if($tagtxt->type == 'name' || $tagtxt->type == 'rank'){
				$nameStr .= ($nameStr ? ' ' : '').$tagtxt->text;
			}
		}
		$nameStr = trim($nameStr);
		if (stristr(strtolower($tagtxt->text), 'incertae sedis') !== FALSE ||
		    stristr(strtolower($tagtxt->text), 'nomina excludenda') !== FALSE){
			var_dump('PREMIO');
			var_dump($element);
		}
	}
	*/

	if($node->children && is_array($node->children)){
		$out .= theme('cdm_taxontree', $node->children, $nextLevelIncluded, $show_filter_switch, $tree_node_callback);
	}
	$out .= '</li>';

	return $out;
}

function theme_cdm_taxontree_node_filter_switch(&$node, $filter_class){
	if(!module_exists('cdm_dataportal')) {
		return '';
	}

	$out = '';
	switch($filter_class){
		case 'filter_included':
			$filter_icon = 'visible_implicit_small.gif';
			break;
		case 'filter_excluded':
			$filter_icon = 'invisible_small.gif';
			break;
		case 'filter_on':
			$filter_icon = 'visible_small.gif';
			break;
	}

	$filter_op = $node->filter == 'on' ? 'remove' : 'add';

	$out .= '&nbsp;'
	.l('<img src="'.drupal_get_path('module', 'cdm_taxontree').'/'.$filter_icon.'" alt="[f]" />',
    'cdm_taxontree/filter/'.$filter_op.'/'.$node->taxonUuid, array('class'=>'filter_'.$filter_op),
    'destination='.path_to_taxon($node->taxonUuid),
	null, false, true);

	return $out;
}

/**
 *
 * @param unknown_type $node
 * @return unknown_type
 */
function theme_cdm_taxontree_node_concept_switch(&$node){
	$out = '';

	if(isset($node->alternativeConceptRefs[0])){
		$out = l(
      '<img src="'.drupal_get_path('module', 'cdm_taxontree').'/concept_switch.gif" alt="[-&gt;]" />',
      'cdm_dataportal/taxon/alternative/'.$node->taxonUuid,
		array('rel'=>'cdm_dataportal/taxon/alternative/'.$node->taxonUuid, 'class'=>'concept_switch'),
		null, null, false, true);
	}
	return $out;
}

// ----------------- FILTERS -------------------------- //

/**
 * filters on children, overrides already set parent filters and vice versa
 *
 * @param STRING $op [add | remove] a taxon from the filtered taxa
 * 					 TODO at the moment there is also a 'list' operation that displays all set filters and provides the ability to delete them.
 * 						  This option depends on function is defined in cdm_dataportal. Problem is, that the dependency is the other way round.
 * @param UUID $taxonUuid
 * @return unknown
 */
function cdm_taxontree_view_filter($op, $taxonUuid = null){

	if(!isset($_SESSION['cdm']['filters'])){
		$_SESSION['cdm']['filters'] = array();
	}
	if($taxonUuid || $op == 'list'){
		switch($op){
			case 'add':
				cdm_taxontree_filters_add($taxonUuid);
				break;
			case 'remove':
				cdm_taxontree_filters_remove($taxonUuid);
				break;
			case 'list':
				//TODO put in cdm_dataportal_theme to decouple both modules by this!!!
				$out = '<ul>';
				foreach($_SESSION['cdm']['filters'] as $uuid=>$node){
					$out .= '<li>'.cdm_dataportal_shortname_of($node).' '.l('[x]', 'cdm_dataportal/filter/remove/'.$uuid, array(), drupal_get_destination()).'</li>';
				}
				$out .= '</ul>';
				return $out;
		}
	}
	if($_REQUEST['destination']){
		$destination = $_REQUEST['destination'];
		unset($_REQUEST['destination']);
		drupal_goto($destination);
	}
}

/**
 * Filters are set in cdm_dataportal_view_filter().
 * functions using filters should remove invalid filters
 *
 * @return true if any filter is active
 */
function cdm_taxontree_filters_active(){
	return isset($_SESSION['cdm']['filters']) && count($_SESSION['cdm']['filters']) > 0;
}

/**
 * Filters are set in cdm_dataportal_view_filter().
 *
 * @return a reference on the filters array stored in the SESSION
 */
function &cdm_taxontree_filters_get(){
	if(!isset($_SESSION['cdm']['filters'])){
		$_SESSION['cdm']['filters'] = array();
	}
	return $_SESSION['cdm']['filters'];
}

/**
 * Adds a taxon to the filtered taxa array
 *
 * @param UUID $taxonUuid
 */
function cdm_taxontree_filters_add($taxonUuid){

	$parents = cdm_ws_taxonomy_pathFromRoot($taxonUuid);

	$parents = array_reverse($parents);

	// pop off last element since this is the TreeNode object for $taxonUuid!
	$this_node = array_pop($parents);
	// will contain the uuid of the parent nodes excluding the $taxonUuid node itself
	$parent_uuids = array();

	// children override parents rule: remove all parent filters,
	foreach($parents as $pnode){
		unset($_SESSION['cdm']['filters'][$pnode->taxonUuid]);
		$parent_uuids[] = $pnode->taxonUuid;
	}

	// search for potential children of this $taxonUuid
	foreach($_SESSION['cdm']['filters'] as $uuid=>$node){
		if(in_array($taxonUuid, $node->parentUuids)){
			unset($_SESSION['cdm']['filters'][$node->taxonUuid]);
		}
	}
	// finally add this $taxonUuid as new filter
	$this_node->parentUuids = $parent_uuids;
	$_SESSION['cdm']['filters'][$taxonUuid] = $this_node;
}

/**
 * Unsets a taxon from the filtered taxa array
 *
 * @param UUID $taxonUuid
 */
function cdm_taxontree_filters_remove($taxonUuid){
	unset($_SESSION['cdm']['filters'][$taxonUuid]);
}


// ------------------------ PRIVATE --------------------------- //

/**
 * Analyses the current Drupal path.
 * If a certain taxon was requested in the request, returns the UUID of that taxon.
 * A stored UUID if no taxon was requested.
 * TODO where does the stored UUID come from?
 *
 * @return UUID
 */
function _cdm_get_taxonuuid(){

	//TODO make the path configurable
	if (arg(0)=="cdm_dataportal" && arg(1)=="taxon" && arg(2)!==0){
		$taxon_uuid = arg(2);
	} else {
		$taxon_uuid = $_SESSION['cdm_dataportal']['tree']['taxon_uuid'];
	}
	return $taxon_uuid;
}

